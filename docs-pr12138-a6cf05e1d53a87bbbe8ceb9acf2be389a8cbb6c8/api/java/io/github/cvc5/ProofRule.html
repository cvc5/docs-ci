<!DOCTYPE HTML>
<html lang="en">
<head>

<title>ProofRule</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="declaration: package: io.github.cvc5, enum: ProofRule">
<meta name="generator" content="javadoc/ClassWriterImpl">
<link rel="stylesheet" type="text/css" href="../../../stylesheet.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../script-dir/jquery-ui.min.css" title="Style">
<script type="text/javascript" src="../../../script.js"></script>
<script type="text/javascript" src="../../../script-dir/jquery-3.7.1.min.js"></script>
<script type="text/javascript" src="../../../script-dir/jquery-ui.min.js"></script>
</head>
<body class="class-declaration-page">
<script type="text/javascript">var pathtoroot = "../../../";
loadScripts(document, 'script');</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<div class="flex-box">
<header role="banner" class="flex-header">
<nav role="navigation">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="top-nav" id="navbar-top"><button id="navbar-toggle-button" aria-controls="navbar-top" aria-expanded="false" aria-label="Toggle navigation links"><span class="nav-bar-toggle-icon">&nbsp;</span><span class="nav-bar-toggle-icon">&nbsp;</span><span class="nav-bar-toggle-icon">&nbsp;</span></button>
<div class="skip-nav"><a href="#skip-navbar-top" title="Skip navigation links">Skip navigation links</a></div>
<div class="about-language"> <script> window.MathJax = { 'loader': { 'load': ['[tex]/ams','[tex]/bussproofs'], }, 'tex': { 'packages': { '[+]': ['ams','bussproofs'], }, 'macros': { 'xor': '\\mathbin{xor}', 'ite': ['#1~\\mathbin{?}~#2~\\mathbin{:}~#3',3], 'inferrule': ['\\begin{prooftree}\\AxiomC{$#1$}\\UnaryInfC{$#2$}\\end{prooftree}',2], 'inferruleSC': ['\\begin{prooftree}\\AxiomC{$#1$}\\RightLabel{~#3}\\UnaryInfC{$#2$}\\end{prooftree}',3], } } } </script> <script type='text/javascript' id='MathJax-script' async src='https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'> </script> </div>
<ul id="navbar-top-firstrow" class="nav-list" title="Navigation">
<li><a href="../../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="nav-bar-cell1-rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../index-all.html">Index</a></li>
<li><a href="../../../help-doc.html#class">Help</a></li>
</ul>
<ul class="sub-nav-list-small">
<li>
<p>Summary:</p>
<ul>
<li><a href="#nested-class-summary">Nested</a></li>
<li><a href="#enum-constant-summary">Enum Constants</a></li>
<li>Field</li>
<li><a href="#method-summary">Method</a></li>
</ul>
</li>
<li>
<p>Detail:</p>
<ul>
<li><a href="#enum-constant-detail">Enum Constants</a></li>
<li>Field</li>
<li><a href="#method-detail">Method</a></li>
</ul>
</li>
</ul>
</div>
<div class="sub-nav">
<div id="navbar-sub-list">
<ul class="sub-nav-list">
<li>Summary:&nbsp;</li>
<li><a href="#nested-class-summary">Nested</a>&nbsp;|&nbsp;</li>
<li><a href="#enum-constant-summary">Enum Constants</a>&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#method-summary">Method</a></li>
</ul>
<ul class="sub-nav-list">
<li>Detail:&nbsp;</li>
<li><a href="#enum-constant-detail">Enum Constants</a>&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#method-detail">Method</a></li>
</ul>
</div>
<div class="nav-list-search"><a href="../../../search.html">SEARCH</a>
<input type="text" id="search-input" disabled placeholder="Search">
<input type="reset" id="reset-button" disabled value="reset">
</div>
</div>
<!-- ========= END OF TOP NAVBAR ========= -->
<span class="skip-nav" id="skip-navbar-top"></span></nav>
</header>
<div class="flex-content">
<main role="main">
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="sub-title"><span class="package-label-in-type">Package</span>&nbsp;<a href="package-summary.html">io.github.cvc5</a></div>
<h1 title="Enum Class ProofRule" class="title">Enum Class ProofRule</h1>
</div>
<div class="inheritance" title="Inheritance Tree"><a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Object.html" title="class or interface in java.lang" class="external-link">java.lang.Object</a>
<div class="inheritance"><a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Enum.html" title="class or interface in java.lang" class="external-link">java.lang.Enum</a>&lt;<a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a>&gt;
<div class="inheritance">io.github.cvc5.ProofRule</div>
</div>
</div>
<section class="class-description" id="class-description">
<dl class="notes">
<dt>All Implemented Interfaces:</dt>
<dd><code><a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/io/Serializable.html" title="class or interface in java.io" class="external-link">Serializable</a></code>, <code><a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Comparable.html" title="class or interface in java.lang" class="external-link">Comparable</a>&lt;<a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a>&gt;</code>, <code><a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/constant/Constable.html" title="class or interface in java.lang.constant" class="external-link">Constable</a></code></dd>
</dl>
<hr>
<div class="type-signature"><span class="modifiers">public enum </span><span class="element-name type-name-label">ProofRule</span>
<span class="extends-implements">extends <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Enum.html" title="class or interface in java.lang" class="external-link">Enum</a>&lt;<a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a>&gt;</span></div>
<div class="block">Enum representing the set of possible values for ProofRule.</div>
</section>
<section class="summary">
<ul class="summary-list">
<!-- ======== NESTED CLASS SUMMARY ======== -->
<li>
<section class="nested-class-summary" id="nested-class-summary">
<h2>Nested Class Summary</h2>
<div class="inherited-list">
<h2 id="nested-classes-inherited-from-class-java.lang.Enum">Nested classes/interfaces inherited from class&nbsp;java.lang.<a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Enum.html" title="class or interface in java.lang" class="external-link">Enum</a></h2>
<code><a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Enum.EnumDesc.html" title="class or interface in java.lang" class="external-link">Enum.EnumDesc</a>&lt;<a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Enum.EnumDesc.html" title="class or interface in java.lang" class="external-link">E</a> extends <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Enum.html" title="class or interface in java.lang" class="external-link">Enum</a>&lt;<a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Enum.EnumDesc.html" title="class or interface in java.lang" class="external-link">E</a>&gt;&gt;</code></div>
</section>
</li>
<!-- =========== ENUM CONSTANT SUMMARY =========== -->
<li>
<section class="constants-summary" id="enum-constant-summary">
<h2>Enum Constant Summary</h2>
<div class="caption"><span>Enum Constants</span></div>
<div class="summary-table two-column-summary">
<div class="table-header col-first">Enum Constant</div>
<div class="table-header col-last">Description</div>
<div class="col-first even-row-color"><code><a href="#ABSORB" class="member-name-link">ABSORB</a></code></div>
<div class="col-last even-row-color">
<div class="block">Builtin theory &ndash; absorb
 
 \[
 
   \inferrule{- \mid t = z}{t = z}
 \]
 where \(t\) contains \(z\) as a subterm, where \(z\)
 is a zero element.</div>
</div>
<div class="col-first odd-row-color"><code><a href="#ACI_NORM" class="member-name-link">ACI_NORM</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Builtin theory &ndash; associative/commutative/idempotency/identity \
 normalization
 
 \[
 
   \inferrule{- \mid t = s}{t = s}
 \]
 where \(t\) and \(s\) are equivalent modulo associativity
 and identity elements, and (optionally) commutativity and idempotency.</div>
</div>
<div class="col-first even-row-color"><code><a href="#ALETHE_RULE" class="member-name-link">ALETHE_RULE</a></code></div>
<div class="col-last even-row-color">
<div class="block">External &ndash; Alethe
 
 Place holder for Alethe rules.</div>
</div>
<div class="col-first odd-row-color"><code><a href="#ALPHA_EQUIV" class="member-name-link">ALPHA_EQUIV</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Quantifiers &ndash; Alpha equivalence
 
 \[
 
   \inferruleSC{-\mid F, (y_1 \ldots y_n), (z_1,\dots, z_n)}
   {F = F\{y_1\mapsto z_1,\dots,y_n\mapsto z_n\}}
   {if $y_1,\dots,y_n, z_1,\dots,z_n$ are unique bound variables}
 \]
 Notice that this rule is correct only when \(z_1,\dots,z_n\) are not
 contained in \(FV(F) \setminus \{ y_1,\dots, y_n \}\), where
 \(FV(F)\) are the free variables of \(F\).</div>
</div>
<div class="col-first even-row-color"><code><a href="#AND_ELIM" class="member-name-link">AND_ELIM</a></code></div>
<div class="col-last even-row-color">
<div class="block">Boolean &ndash; And elimination
 
 \[
 
   \inferrule{(F_1 \land \dots \land F_n) \mid i}{F_i}
 \]</div>
</div>
<div class="col-first odd-row-color"><code><a href="#AND_INTRO" class="member-name-link">AND_INTRO</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Boolean &ndash; And introduction
 
 \[
 
   \inferrule{F_1 \dots F_n \mid -}{(F_1 \land \dots \land F_n)}
 \]</div>
</div>
<div class="col-first even-row-color"><code><a href="#ARITH_MULT_ABS_COMPARISON" class="member-name-link">ARITH_MULT_ABS_COMPARISON</a></code></div>
<div class="col-last even-row-color">
<div class="block">Arithmetic &ndash; Non-linear multiply absolute value comparison
 
 \[
 
   \inferrule{F_1 \dots F_n \mid -}{F}
 \]
 where \(F\) is of the form
 \(\left| t_1 \cdot t_n \right| \diamond \left| s_1 \cdot s_n \right|\).</div>
</div>
<div class="col-first odd-row-color"><code><a href="#ARITH_MULT_NEG" class="member-name-link">ARITH_MULT_NEG</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Arithmetic &ndash; Multiplication with negative factor
 
 \[
 
   \inferrule{- \mid m, l \diamond r}{(m &lt; 0 \land l \diamond r) \rightarrow m \cdot l \diamond_{inv} m \cdot r}
 \]
 where \(\diamond\) is a relation symbol and \(\diamond_{inv}\) the
 inverted relation symbol.</div>
</div>
<div class="col-first even-row-color"><code><a href="#ARITH_MULT_POS" class="member-name-link">ARITH_MULT_POS</a></code></div>
<div class="col-last even-row-color">
<div class="block">Arithmetic &ndash; Multiplication with positive factor
 
 \[
 
   \inferrule{- \mid m, l \diamond r}{(m &gt; 0 \land l \diamond r) \rightarrow m \cdot l \diamond m \cdot r}
 \]
 where \(\diamond\) is a relation symbol.</div>
</div>
<div class="col-first odd-row-color"><code><a href="#ARITH_MULT_SIGN" class="member-name-link">ARITH_MULT_SIGN</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Arithmetic &ndash; Sign inference
 
 \[
 
   \inferrule{- \mid f_1 \dots f_k, m}{(f_1 \land \dots \land f_k) \rightarrow m \diamond 0}
 \]
 where \(f_1 \dots f_k\) are variables compared to zero (less, greater
 or not equal), \(m\) is a monomial from these variables and
 \(\diamond\) is the comparison (less or greater) that results from the
 signs of the variables.</div>
</div>
<div class="col-first even-row-color"><code><a href="#ARITH_MULT_TANGENT" class="member-name-link">ARITH_MULT_TANGENT</a></code></div>
<div class="col-last even-row-color">
<div class="block">Arithmetic &ndash; Multiplication tangent plane
 
 \[
 
   \inferruleSC{- \mid x, y, a, b, \sigma}{(t \leq tplane) = ((x \leq a \land y \geq b) \lor (x \geq a \land y \leq b))}{if $\sigma = \bot$}
 
   \inferruleSC{- \mid x, y, a, b, \sigma}{(t \geq tplane) = ((x \leq a \land y \leq b) \lor (x \geq a \land y \geq b))}{if $\sigma = \top$}
 \]
 where \(x,y\) are real terms (variables or extended terms),
 \(t = x \cdot y\), \(a,b\) are real
 constants, \(\sigma \in \{ \top, \bot\}\) and \(tplane := b \cdot x + a \cdot y - a \cdot b\) is the tangent plane of \(x \cdot y\) at \((a,b)\).</div>
</div>
<div class="col-first odd-row-color"><code><a href="#ARITH_POLY_NORM" class="member-name-link">ARITH_POLY_NORM</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Arithmetic &ndash; Polynomial normalization
 
 \[
 
   \inferrule{- \mid t = s}{t = s}
 \]
 where \(\texttt{arith::PolyNorm::isArithPolyNorm(t, s)} = \top\).</div>
</div>
<div class="col-first even-row-color"><code><a href="#ARITH_POLY_NORM_REL" class="member-name-link">ARITH_POLY_NORM_REL</a></code></div>
<div class="col-last even-row-color">
<div class="block">Arithmetic &ndash; Polynomial normalization for relations
 
 ..</div>
</div>
<div class="col-first odd-row-color"><code><a href="#ARITH_REDUCTION" class="member-name-link">ARITH_REDUCTION</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Arithmetic &ndash; Reduction
 
 \[
 
   \inferrule{- \mid t}{F}
 \]
 where \(t\) is an application of an extended arithmetic operator (e.g.</div>
</div>
<div class="col-first even-row-color"><code><a href="#ARITH_SUM_UB" class="member-name-link">ARITH_SUM_UB</a></code></div>
<div class="col-last even-row-color">
<div class="block">Arithmetic &ndash; Sum upper bounds
 
 \[
 
   \inferrule{P_1 \dots P_n \mid -}{L \diamond R}
 \]
 where \(P_i\) has the form \(L_i \diamond_i R_i\) and
 \(\diamond_i \in \{&lt;, \leq, =\}\).</div>
</div>
<div class="col-first odd-row-color"><code><a href="#ARITH_TRANS_EXP_APPROX_ABOVE_NEG" class="member-name-link">ARITH_TRANS_EXP_APPROX_ABOVE_NEG</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Arithmetic &ndash; Transcendentals &ndash; Exp is approximated from above for \
 negative values
 
 \[
 
   \inferrule{- \mid d,t,l,u}{(t \geq l \land t \leq u) \rightarrow exp(t)
   \leq \texttt{secant}(\exp, l, u, t)}
 \]
 where \(d\) is an even positive number, \(t\) an arithmetic term
 and \(l,u\) are lower and upper bounds on \(t\).</div>
</div>
<div class="col-first even-row-color"><code><a href="#ARITH_TRANS_EXP_APPROX_ABOVE_POS" class="member-name-link">ARITH_TRANS_EXP_APPROX_ABOVE_POS</a></code></div>
<div class="col-last even-row-color">
<div class="block">Arithmetic &ndash; Transcendentals &ndash; Exp is approximated from above for \
 positive values
 
 \[
 
   \inferrule{- \mid d,t,l,u}{(t \geq l \land t \leq u) \rightarrow exp(t)
   \leq \texttt{secant-pos}(\exp, l, u, t)}
 \]
 where \(d\) is an even positive number, \(t\) an arithmetic term
 and \(l,u\) are lower and upper bounds on \(t\).</div>
</div>
<div class="col-first odd-row-color"><code><a href="#ARITH_TRANS_EXP_APPROX_BELOW" class="member-name-link">ARITH_TRANS_EXP_APPROX_BELOW</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Arithmetic &ndash; Transcendentals &ndash; Exp is approximated from below
 
 \[
 
   \inferrule{- \mid d,c,t}{t \geq c \rightarrow exp(t) \geq \texttt{maclaurin}(\exp, d, c)}
 \]
 where \(d\) is a non-negative number, \(t\) an arithmetic term and
 \(\texttt{maclaurin}(\exp, n+1, c)\) is the \((n+1)\)'th taylor
 polynomial at zero (also called the Maclaurin series) of the exponential
 function evaluated at \(c\) where \(n\) is \(2 \cdot d\).</div>
</div>
<div class="col-first even-row-color"><code><a href="#ARITH_TRANS_EXP_NEG" class="member-name-link">ARITH_TRANS_EXP_NEG</a></code></div>
<div class="col-last even-row-color">
<div class="block">Arithmetic &ndash; Transcendentals &ndash; Exp at negative values
 
 \[
 
   \inferrule{- \mid t}{(t &lt; 0.0) \leftrightarrow (\exp(t) &lt; 1.0)}
 \]</div>
</div>
<div class="col-first odd-row-color"><code><a href="#ARITH_TRANS_EXP_POSITIVITY" class="member-name-link">ARITH_TRANS_EXP_POSITIVITY</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Arithmetic &ndash; Transcendentals &ndash; Exp is always positive
 
 \[
 
   \inferrule{- \mid t}{\exp(t) &gt; 0.0}
 \]</div>
</div>
<div class="col-first even-row-color"><code><a href="#ARITH_TRANS_EXP_SUPER_LIN" class="member-name-link">ARITH_TRANS_EXP_SUPER_LIN</a></code></div>
<div class="col-last even-row-color">
<div class="block">Arithmetic &ndash; Transcendentals &ndash; Exp grows super-linearly for positive
 values
 
 \[
 
   \inferrule{- \mid t}{t \leq 0.0 \lor \exp(t) &gt; t+1.0}
 \]</div>
</div>
<div class="col-first odd-row-color"><code><a href="#ARITH_TRANS_EXP_ZERO" class="member-name-link">ARITH_TRANS_EXP_ZERO</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Arithmetic &ndash; Transcendentals &ndash; Exp at zero
 
 \[
 
   \inferrule{- \mid t}{(t=0.0) \leftrightarrow (\exp(t) = 1.0)}
 \]</div>
</div>
<div class="col-first even-row-color"><code><a href="#ARITH_TRANS_PI" class="member-name-link">ARITH_TRANS_PI</a></code></div>
<div class="col-last even-row-color">
<div class="block">Arithmetic &ndash; Transcendentals &ndash; Assert bounds on Pi
 
 \[
 
   \inferrule{- \mid l, u}{\texttt{real.pi} \geq l \land \texttt{real.pi}
   \leq u}
 \]
 where \(l,u\) are valid lower and upper bounds on \(\pi\).</div>
</div>
<div class="col-first odd-row-color"><code><a href="#ARITH_TRANS_SINE_APPROX_ABOVE_NEG" class="member-name-link">ARITH_TRANS_SINE_APPROX_ABOVE_NEG</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Arithmetic &ndash; Transcendentals &ndash; Sine is approximated from above for\
 negative values
 
 \[
 
   \inferrule{- \mid d,t,lb,ub,l,u}{(t \geq lb \land t \leq ub) \rightarrow
   \sin(t) \leq \texttt{secant}(\sin, l, u, t)}
 \]
 where \(d\) is an even positive number, \(t\) an arithmetic term,
 \(lb,ub\) are symbolic lower and upper bounds on \(t\) (possibly
 containing \(\pi\)) and \(l,u\) the evaluated lower and upper
 bounds on \(t\).</div>
</div>
<div class="col-first even-row-color"><code><a href="#ARITH_TRANS_SINE_APPROX_ABOVE_POS" class="member-name-link">ARITH_TRANS_SINE_APPROX_ABOVE_POS</a></code></div>
<div class="col-last even-row-color">
<div class="block">Arithmetic &ndash; Transcendentals &ndash; Sine is approximated from above for \
 positive values
 
 \[
 
   \inferrule{- \mid d,t,c,lb,ub}{(t \geq lb \land t \leq ub) \rightarrow
   \sin(t) \leq \texttt{upper}(\sin, c)}
 \]
 where \(d\) is an even positive number, \(t\) an arithmetic term,
 \(c\) an arithmetic constant and \(lb,ub\) are symbolic lower and
 upper bounds on \(t\) (possibly containing \(\pi\)).</div>
</div>
<div class="col-first odd-row-color"><code><a href="#ARITH_TRANS_SINE_APPROX_BELOW_NEG" class="member-name-link">ARITH_TRANS_SINE_APPROX_BELOW_NEG</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Arithmetic &ndash; Transcendentals &ndash; Sine is approximated from below for \
 negative values
 
 \[
 
   \inferrule{- \mid d,t,c,lb,ub}{(t \geq lb \land t \leq ub) \rightarrow
   \sin(t) \geq \texttt{lower}(\sin, c)}
 \]
 where \(d\) is an even positive number, \(t\) an arithmetic term,
 \(c\) an arithmetic constant and \(lb,ub\) are symbolic lower and
 upper bounds on \(t\) (possibly containing \(\pi\)).</div>
</div>
<div class="col-first even-row-color"><code><a href="#ARITH_TRANS_SINE_APPROX_BELOW_POS" class="member-name-link">ARITH_TRANS_SINE_APPROX_BELOW_POS</a></code></div>
<div class="col-last even-row-color">
<div class="block">Arithmetic &ndash; Transcendentals &ndash; Sine is approximated from below for \
 positive values
 
 \[
 
   \inferrule{- \mid d,t,lb,ub,l,u}{(t \geq lb \land t \leq ub) \rightarrow
   \sin(t) \geq \texttt{secant}(\sin, l, u, t)}
 \]
 where \(d\) is an even positive number, \(t\) an arithmetic term,
 \(lb,ub\) are symbolic lower and upper bounds on \(t\) (possibly
 containing \(\pi\)) and \(l,u\) the evaluated lower and upper
 bounds on \(t\).</div>
</div>
<div class="col-first odd-row-color"><code><a href="#ARITH_TRANS_SINE_BOUNDS" class="member-name-link">ARITH_TRANS_SINE_BOUNDS</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Arithmetic &ndash; Transcendentals &ndash; Sine is always between -1 and 1
 
 \[
 
   \inferrule{- \mid t}{\sin(t) \leq 1.0 \land \sin(t) \geq -1.0}
 \]</div>
</div>
<div class="col-first even-row-color"><code><a href="#ARITH_TRANS_SINE_SHIFT" class="member-name-link">ARITH_TRANS_SINE_SHIFT</a></code></div>
<div class="col-last even-row-color">
<div class="block">Arithmetic &ndash; Transcendentals &ndash; Sine is shifted to -pi...pi
 
 \[
 
   \inferrule{- \mid x}{-\pi \leq y \leq \pi \land \sin(y) = \sin(x)
   \land (\ite{-\pi \leq x \leq \pi}{x = y}{x = y + 2 \pi s})}
 \]
 where \(x\) is the argument to sine, \(y\) is a new real skolem
 that is \(x\) shifted into \(-\pi \dots \pi\) and \(s\) is a
 new integer skolem that is the number of phases \(y\) is shifted.</div>
</div>
<div class="col-first odd-row-color"><code><a href="#ARITH_TRANS_SINE_SYMMETRY" class="member-name-link">ARITH_TRANS_SINE_SYMMETRY</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Arithmetic &ndash; Transcendentals &ndash; Sine is symmetric with respect to \
 negation of the argument
 
 \[
 
   \inferrule{- \mid t}{\sin(t) + \sin(-t) = 0.0}
 \]</div>
</div>
<div class="col-first even-row-color"><code><a href="#ARITH_TRANS_SINE_TANGENT_PI" class="member-name-link">ARITH_TRANS_SINE_TANGENT_PI</a></code></div>
<div class="col-last even-row-color">
<div class="block">Arithmetic &ndash; Transcendentals &ndash; Sine is bounded by the tangents at -pi and pi
 
 \[
 
   \inferrule{- \mid t}{(t &gt; -\pi \rightarrow \sin(t) &gt; -\pi - t) \land (t &lt;
   \pi \rightarrow \sin(t) &lt; \pi - t)}
 \]</div>
</div>
<div class="col-first odd-row-color"><code><a href="#ARITH_TRANS_SINE_TANGENT_ZERO" class="member-name-link">ARITH_TRANS_SINE_TANGENT_ZERO</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Arithmetic &ndash; Transcendentals &ndash; Sine is bounded by the tangent at zero
 
 \[
 
   \inferrule{- \mid t}{(t &gt; 0.0 \rightarrow \sin(t) &lt; t) \land (t &lt; 0.0
   \rightarrow \sin(t) &gt; t)}
 \]</div>
</div>
<div class="col-first even-row-color"><code><a href="#ARITH_TRICHOTOMY" class="member-name-link">ARITH_TRICHOTOMY</a></code></div>
<div class="col-last even-row-color">
<div class="block">Arithmetic &ndash; Trichotomy of the reals
 
 \[
 
   \inferrule{A, B \mid -}{C}
 \]
 where \(\neg A, \neg B, C\) are \(x &lt; c, x = c, x &gt; c\) in some order.</div>
</div>
<div class="col-first odd-row-color"><code><a href="#ARRAYS_EXT" class="member-name-link">ARRAYS_EXT</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Arrays &ndash; Arrays extensionality
 
 \[
 
   \inferrule{a \neq b\mid -}
   {\mathit{select}(a,k)\neq\mathit{select}(b,k)}
 \]
 where \(k\) is the \(\texttt{ARRAY_DEQ_DIFF}\) skolem for `(a, b)`.</div>
</div>
<div class="col-first even-row-color"><code><a href="#ARRAYS_READ_OVER_WRITE" class="member-name-link">ARRAYS_READ_OVER_WRITE</a></code></div>
<div class="col-last even-row-color">
<div class="block">Arrays &ndash; Read over write
 
 \[
 
   \inferrule{i_1 \neq i_2\mid \mathit{select}(\mathit{store}(a,i_1,e),i_2)}
   {\mathit{select}(\mathit{store}(a,i_1,e),i_2) = \mathit{select}(a,i_2)}
 \]</div>
</div>
<div class="col-first odd-row-color"><code><a href="#ARRAYS_READ_OVER_WRITE_1" class="member-name-link">ARRAYS_READ_OVER_WRITE_1</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Arrays &ndash; Read over write 1
 
 \[
 
   \inferrule{-\mid \mathit{select}(\mathit{store}(a,i,e),i)}
   {\mathit{select}(\mathit{store}(a,i,e),i)=e}
 \]</div>
</div>
<div class="col-first even-row-color"><code><a href="#ARRAYS_READ_OVER_WRITE_CONTRA" class="member-name-link">ARRAYS_READ_OVER_WRITE_CONTRA</a></code></div>
<div class="col-last even-row-color">
<div class="block">Arrays &ndash; Read over write, contrapositive
 
 \[
 
   \inferrule{\mathit{select}(\mathit{store}(a,i_2,e),i_1) \neq
   \mathit{select}(a,i_1)\mid -}{i_1=i_2}
 \]</div>
</div>
<div class="col-first odd-row-color"><code><a href="#ASSUME" class="member-name-link">ASSUME</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Assumption (a leaf)
 
 \[
 
   \inferrule{- \mid F}{F}
 \]
 This rule has special status, in that an application of assume is an
 open leaf in a proof that is not (yet) justified.</div>
</div>
<div class="col-first even-row-color"><code><a href="#BV_BITBLAST_STEP" class="member-name-link">BV_BITBLAST_STEP</a></code></div>
<div class="col-last even-row-color">
<div class="block">Bit-vectors &ndash; Bitblast bit-vector constant, variable, and terms
 
 For constant and variables:
 
 \[
 
   \inferrule{-\mid t}{t = \texttt{bitblast}(t)}
 \]
 For terms:
 
 \[
 
   \inferrule{-\mid k(\texttt{bitblast}(t_1),\dots,\texttt{bitblast}(t_n))}
   {k(\texttt{bitblast}(t_1),\dots,\texttt{bitblast}(t_n)) =
   \texttt{bitblast}(t)}
 \]
 where \(t\) is \(k(t_1,\dots,t_n)\).</div>
</div>
<div class="col-first odd-row-color"><code><a href="#BV_EAGER_ATOM" class="member-name-link">BV_EAGER_ATOM</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Bit-vectors &ndash; Bit-vector eager atom
 
 \[
 
   \inferrule{-\mid F}{F = F[0]}
 \]
 where \(F\) is of kind <code>BITVECTOR_EAGER_ATOM</code>.</div>
</div>
<div class="col-first even-row-color"><code><a href="#BV_POLY_NORM" class="member-name-link">BV_POLY_NORM</a></code></div>
<div class="col-last even-row-color">
<div class="block">Bit-vectors &ndash; Polynomial normalization
 
 \[
 
   \inferrule{- \mid t = s}{t = s}
 \]
 where \(\texttt{arith::PolyNorm::isArithPolyNorm(t, s)} = \top\).</div>
</div>
<div class="col-first odd-row-color"><code><a href="#BV_POLY_NORM_EQ" class="member-name-link">BV_POLY_NORM_EQ</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Bit-vectors &ndash; Polynomial normalization for relations
 
 ..</div>
</div>
<div class="col-first even-row-color"><code><a href="#CHAIN_M_RESOLUTION" class="member-name-link">CHAIN_M_RESOLUTION</a></code></div>
<div class="col-last even-row-color">
<div class="block">Boolean &ndash; Chain multiset resolution
 
 This rule combines Resolution + Factoring + Reordering.</div>
</div>
<div class="col-first odd-row-color"><code><a href="#CHAIN_RESOLUTION" class="member-name-link">CHAIN_RESOLUTION</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Boolean &ndash; N-ary Resolution
 
 \[
 
   \inferrule{C_1 \dots C_n \mid (pol_1 \dots pol_{n-1}), (L_1 \dots L_{n-1})}{C}
 \]
 where
 
 
 let \(C_1 \dots C_n\) be nodes viewed as clauses, as defined above
 
 let \(C_1 \diamond_{L,pol} C_2\) represent the resolution of
   \(C_1\) with \(C_2\) with pivot \(L\) and polarity
   \(pol\), as defined above
 
 let \(C_1' = C_1\),
 
 for each \(i &gt; 1\), let \(C_i' = C_{i-1} \diamond_{L_{i-1}, pol_{i-1}} C_i'\)
 
 
 Note the list of polarities and pivots are provided as s-expressions.</div>
</div>
<div class="col-first even-row-color"><code><a href="#CNF_AND_NEG" class="member-name-link">CNF_AND_NEG</a></code></div>
<div class="col-last even-row-color">
<div class="block">Boolean &ndash; CNF &ndash; And Negative
 
 \[
 
   \inferrule{- \mid (F_1 \land \dots \land F_n)}{(F_1 \land \dots \land
   F_n) \lor \neg F_1 \lor \dots \lor \neg F_n}
 \]</div>
</div>
<div class="col-first odd-row-color"><code><a href="#CNF_AND_POS" class="member-name-link">CNF_AND_POS</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Boolean &ndash; CNF &ndash; And Positive
 
 \[
 
   \inferrule{- \mid (F_1 \land \dots \land F_n), i}{\neg (F_1 \land \dots
   \land F_n) \lor F_i}
 \]</div>
</div>
<div class="col-first even-row-color"><code><a href="#CNF_EQUIV_NEG1" class="member-name-link">CNF_EQUIV_NEG1</a></code></div>
<div class="col-last even-row-color">
<div class="block">Boolean &ndash; CNF &ndash; Equiv Negative 1
 
 \[
 
   \inferrule{- \mid F_1 = F_2}{(F_1 = F_2) \lor F_1 \lor F_2}
 \]</div>
</div>
<div class="col-first odd-row-color"><code><a href="#CNF_EQUIV_NEG2" class="member-name-link">CNF_EQUIV_NEG2</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Boolean &ndash; CNF &ndash; Equiv Negative 2
 
 \[
 
   \inferrule{- \mid F_1 = F_2}{(F_1 = F_2) \lor \neg F_1 \lor \neg F_2}
 \]</div>
</div>
<div class="col-first even-row-color"><code><a href="#CNF_EQUIV_POS1" class="member-name-link">CNF_EQUIV_POS1</a></code></div>
<div class="col-last even-row-color">
<div class="block">Boolean &ndash; CNF &ndash; Equiv Positive 1
 
 \[
 
   \inferrule{- \mid F_1 = F_2}{F_1 \neq F_2 \lor \neg F_1 \lor F_2}
 \]</div>
</div>
<div class="col-first odd-row-color"><code><a href="#CNF_EQUIV_POS2" class="member-name-link">CNF_EQUIV_POS2</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Boolean &ndash; CNF &ndash; Equiv Positive 2
 
 \[
 
   \inferrule{- \mid F_1 = F_2}{F_1 \neq F_2 \lor F_1 \lor \neg F_2}
 \]</div>
</div>
<div class="col-first even-row-color"><code><a href="#CNF_IMPLIES_NEG1" class="member-name-link">CNF_IMPLIES_NEG1</a></code></div>
<div class="col-last even-row-color">
<div class="block">Boolean &ndash; CNF &ndash; Implies Negative 1
 
 \[
 
   \inferrule{- \mid F_1 \rightarrow F_2}{(F_1 \rightarrow F_2) \lor F_1}
 \]</div>
</div>
<div class="col-first odd-row-color"><code><a href="#CNF_IMPLIES_NEG2" class="member-name-link">CNF_IMPLIES_NEG2</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Boolean &ndash; CNF &ndash; Implies Negative 2
 
 \[
 
   \inferrule{- \mid F_1 \rightarrow F_2}{(F_1 \rightarrow F_2) \lor \neg F_2}
 \]</div>
</div>
<div class="col-first even-row-color"><code><a href="#CNF_IMPLIES_POS" class="member-name-link">CNF_IMPLIES_POS</a></code></div>
<div class="col-last even-row-color">
<div class="block">Boolean &ndash; CNF &ndash; Implies Positive
 
 \[
 
   \inferrule{- \mid F_1 \rightarrow F_2}{\neg(F_1 \rightarrow F_2) \lor \neg F_1
   \lor F_2}
 \]</div>
</div>
<div class="col-first odd-row-color"><code><a href="#CNF_ITE_NEG1" class="member-name-link">CNF_ITE_NEG1</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Boolean &ndash; CNF &ndash; ITE Negative 1
 
 \[
 
   \inferrule{- \mid (\ite{C}{F_1}{F_2})}{(\ite{C}{F_1}{F_2}) \lor \neg C
   \lor \neg F_1}
 \]</div>
</div>
<div class="col-first even-row-color"><code><a href="#CNF_ITE_NEG2" class="member-name-link">CNF_ITE_NEG2</a></code></div>
<div class="col-last even-row-color">
<div class="block">Boolean &ndash; CNF &ndash; ITE Negative 2
 
 \[
 
   \inferrule{- \mid (\ite{C}{F_1}{F_2})}{(\ite{C}{F_1}{F_2}) \lor C \lor
   \neg F_2}
 \]</div>
</div>
<div class="col-first odd-row-color"><code><a href="#CNF_ITE_NEG3" class="member-name-link">CNF_ITE_NEG3</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Boolean &ndash; CNF &ndash; ITE Negative 3
 
 \[
 
   \inferrule{- \mid (\ite{C}{F_1}{F_2})}{(\ite{C}{F_1}{F_2}) \lor \neg F_1
   \lor \neg F_2}
 \]</div>
</div>
<div class="col-first even-row-color"><code><a href="#CNF_ITE_POS1" class="member-name-link">CNF_ITE_POS1</a></code></div>
<div class="col-last even-row-color">
<div class="block">Boolean &ndash; CNF &ndash; ITE Positive 1
 
 \[
 
   \inferrule{- \mid (\ite{C}{F_1}{F_2})}{\neg(\ite{C}{F_1}{F_2}) \lor \neg
   C \lor F_1}
 \]</div>
</div>
<div class="col-first odd-row-color"><code><a href="#CNF_ITE_POS2" class="member-name-link">CNF_ITE_POS2</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Boolean &ndash; CNF &ndash; ITE Positive 2
 
 \[
 
   \inferrule{- \mid (\ite{C}{F_1}{F_2})}{\neg(\ite{C}{F_1}{F_2}) \lor C
   \lor F_2}
 \]</div>
</div>
<div class="col-first even-row-color"><code><a href="#CNF_ITE_POS3" class="member-name-link">CNF_ITE_POS3</a></code></div>
<div class="col-last even-row-color">
<div class="block">Boolean &ndash; CNF &ndash; ITE Positive 3
 
 \[
 
   \inferrule{- \mid (\ite{C}{F_1}{F_2})}{\neg(\ite{C}{F_1}{F_2}) \lor F_1
   \lor F_2}
 \]</div>
</div>
<div class="col-first odd-row-color"><code><a href="#CNF_OR_NEG" class="member-name-link">CNF_OR_NEG</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Boolean &ndash; CNF &ndash; Or Negative
 
 \[
 
   \inferrule{- \mid (F_1 \lor \dots \lor F_n), i}{(F_1 \lor \dots \lor F_n)
   \lor \neg F_i}
 \]</div>
</div>
<div class="col-first even-row-color"><code><a href="#CNF_OR_POS" class="member-name-link">CNF_OR_POS</a></code></div>
<div class="col-last even-row-color">
<div class="block">Boolean &ndash; CNF &ndash; Or Positive
 
 \[
 
   \inferrule{- \mid (F_1 \lor \dots \lor F_n)}{\neg(F_1 \lor \dots \lor
   F_n) \lor F_1 \lor \dots \lor F_n}
 \]</div>
</div>
<div class="col-first odd-row-color"><code><a href="#CNF_XOR_NEG1" class="member-name-link">CNF_XOR_NEG1</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Boolean &ndash; CNF &ndash; XOR Negative 1
 
 \[
 
   \inferrule{- \mid F_1 \xor F_2}{(F_1 \xor F_2) \lor \neg F_1 \lor F_2}
 \]</div>
</div>
<div class="col-first even-row-color"><code><a href="#CNF_XOR_NEG2" class="member-name-link">CNF_XOR_NEG2</a></code></div>
<div class="col-last even-row-color">
<div class="block">Boolean &ndash; CNF &ndash; XOR Negative 2
 
 \[
 
   \inferrule{- \mid F_1 \xor F_2}{(F_1 \xor F_2) \lor F_1 \lor \neg F_2}
 \]</div>
</div>
<div class="col-first odd-row-color"><code><a href="#CNF_XOR_POS1" class="member-name-link">CNF_XOR_POS1</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Boolean &ndash; CNF &ndash; XOR Positive 1
 
 \[
 
   \inferrule{- \mid F_1 \xor F_2}{\neg(F_1 \xor F_2) \lor F_1 \lor F_2}
 \]</div>
</div>
<div class="col-first even-row-color"><code><a href="#CNF_XOR_POS2" class="member-name-link">CNF_XOR_POS2</a></code></div>
<div class="col-last even-row-color">
<div class="block">Boolean &ndash; CNF &ndash; XOR Positive 2
 
 \[
 
   \inferrule{- \mid F_1 \xor F_2}{\neg(F_1 \xor F_2) \lor \neg F_1 \lor
   \neg F_2}
 \]</div>
</div>
<div class="col-first odd-row-color"><code><a href="#CONCAT_CPROP" class="member-name-link">CONCAT_CPROP</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Strings &ndash; Core rules &ndash; Concatenation constant propagation
 
 \[
 
   \inferrule{(t_1 \cdot w_1 \cdot \ldots \cdot t_n) = (w_2 \cdot s_2 \cdot \ldots \cdot s_m),\,
   \mathit{len}(t_1) \neq 0\mid \bot}{(t_1 = t_3\cdot r)}
 \]
 where \(w_1,\,w_2\) are words, \(t_3\) is
 \(\mathit{pre}(w_2,p)\), \(p\) is
 \(\texttt{Word::overlap}(\mathit{suf}(w_2,1), w_1)\), and \(r\) is
 the purification skolem for
 \(\mathit{suf}(t_1,\mathit{len}(w_3))\).</div>
</div>
<div class="col-first even-row-color"><code><a href="#CONCAT_CSPLIT" class="member-name-link">CONCAT_CSPLIT</a></code></div>
<div class="col-last even-row-color">
<div class="block">Strings &ndash; Core rules &ndash; Concatenation split for constants
 
 \[
 
   \inferrule{(t_1\cdot \ldots \cdot t_n) = (c \cdot t_2 \ldots \cdot s_m),\,\mathit{len}(t_1) \neq 0\mid \bot}{(t_1 = c\cdot r)}
 \]
 where \(r\) is the purification skolem for \(\mathit{suf}(t_1,1)\).</div>
</div>
<div class="col-first odd-row-color"><code><a href="#CONCAT_EQ" class="member-name-link">CONCAT_EQ</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Strings &ndash; Core rules &ndash; Concatenation equality
 
 \[
 
   \inferrule{(t_1 \cdot \ldots \cdot t_n \cdot t) = (t_1 \cdot \ldots \cdot t_n \cdot s)\mid \bot}{t = s}
 \]
 Alternatively for the reverse:
 
   \inferrule{(t \cdot t_1 \cdot \ldots \cdot t_n) = (s \cdot t_1 \cdot \ldots \cdot t_n)\mid \top}{t = s}
 
 Notice that \(t\) or \(s\) may be empty, in which case they are
 implicit in the concatenation above.</div>
</div>
<div class="col-first even-row-color"><code><a href="#CONCAT_LPROP" class="member-name-link">CONCAT_LPROP</a></code></div>
<div class="col-last even-row-color">
<div class="block">Strings &ndash; Core rules &ndash; Concatenation length propagation
 
 \[
 
   \inferrule{(t_1\cdot \ldots \cdot t_n) = (s_1 \cdot \ldots \cdot s_m),\,
   \mathit{len}(t_1) &gt; \mathit{len}(s_1)\mid \bot}{(t_1 = s_1\cdot r)}
 \]
 where \(r\) is the purification Skolem for
 \(\mathit{ite}(
 \mathit{len}(t_1) &gt;= \mathit{len}(s_1),
 \mathit{suf}(t_1,\mathit{len}(s_1)),
 \mathit{suf}(s_1,\mathit{len}(t_1)))\).</div>
</div>
<div class="col-first odd-row-color"><code><a href="#CONCAT_SPLIT" class="member-name-link">CONCAT_SPLIT</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Strings &ndash; Core rules &ndash; Concatenation split
 
 \[
 
   \inferruleSC{(t_1 \cdot \ldots \cdot t_n) = (s_1 \cdot \ldots \cdot s_m),\,
   \mathit{len}(t_1) \neq \mathit{len}(s_1)\mid \bot}{((t_1 = s_1\cdot r)
   \vee (s_1 = t_1\cdot r)) \wedge r \neq \epsilon \wedge \mathit{len}(r)&gt;0}
 \]
 where \(r\) is the purification skolem for
 \(\mathit{ite}(
 \mathit{len}(t_1) &gt;= \mathit{len}(s_1),
 \mathit{suf}(t_1,\mathit{len}(s_1)),
 \mathit{suf}(s_1,\mathit{len}(t_1)))\)
 and \(\epsilon\) is the empty string (or sequence).</div>
</div>
<div class="col-first even-row-color"><code><a href="#CONCAT_UNIFY" class="member-name-link">CONCAT_UNIFY</a></code></div>
<div class="col-last even-row-color">
<div class="block">Strings &ndash; Core rules &ndash; Concatenation unification
 
 \[
 
   \inferrule{(t_1 \cdot \ldots \cdot t_n) = (s_1 \cdot \ldots \cdot s_m),\, \mathit{len}(t_1) =
   \mathit{len}(s_1)\mid \bot}{t_1 = s_1}
 \]
 Alternatively for the reverse:
 
 \[
 
   \inferrule{(t_1 \cdot \ldots \cdot t_n) = (s_1 \cdot \ldots \cdot s_m),\, \mathit{len}(t_n) =
   \mathit{len}(s_m)\mid \top}{t_n = s_m}
 \]</div>
</div>
<div class="col-first odd-row-color"><code><a href="#CONG" class="member-name-link">CONG</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Equality &ndash; Congruence
 
 \[
 
   \inferrule{t_1=s_1,\dots,t_n=s_n\mid f(t_1,\dots, t_n)}{f(t_1,\dots, t_n) = f(s_1,\dots, s_n)}
 \]
 This rule is used when the kind of \(f(t_1,\dots, t_n)\) has a fixed
 arity.</div>
</div>
<div class="col-first even-row-color"><code><a href="#CONTRA" class="member-name-link">CONTRA</a></code></div>
<div class="col-last even-row-color">
<div class="block">Boolean &ndash; Contradiction
 
 \[
 
   \inferrule{F, \neg F \mid -}{\bot}
 \]</div>
</div>
<div class="col-first odd-row-color"><code><a href="#DISTINCT_VALUES" class="member-name-link">DISTINCT_VALUES</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Builtin theory &ndash; Distinct values
 
 \[
 
   \inferrule{- \mid t, s}{\neg t = s}
 \]
 where \(t\) and \(s\) are distinct values.</div>
</div>
<div class="col-first even-row-color"><code><a href="#DRAT_REFUTATION" class="member-name-link">DRAT_REFUTATION</a></code></div>
<div class="col-last even-row-color">
<div class="block">DRAT Refutation
 
 \[
 
   \inferrule{F_1 \dots F_n \mid D, P}{\bot}
 \]
 where \(F_1 \dots F_n\) correspond to the clauses in the
 DIMACS file given by filename `D` and `P` is a filename of a file storing
 a DRAT proof.</div>
</div>
<div class="col-first odd-row-color"><code><a href="#DSL_REWRITE" class="member-name-link">DSL_REWRITE</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Builtin theory &ndash; DSL rewrite
 
 \[
 
   \inferrule{F_1 \dots F_n \mid id t_1 \dots t_n}{F}
 \]
 where `id` is a ProofRewriteRule whose definition in the
 RARE DSL is \(\forall x_1 \dots x_n.</div>
</div>
<div class="col-first even-row-color"><code><a href="#DT_SPLIT" class="member-name-link">DT_SPLIT</a></code></div>
<div class="col-last even-row-color">
<div class="block">Datatypes &ndash; Split
 
 \[
 
   \inferrule{-\mid t}{\mathit{is}_{C_1}(t)\vee\cdots\vee\mathit{is}_{C_n}(t)}
 \]
 where \(C_1,\dots,C_n\) are all the constructors of the type of \(t\).</div>
</div>
<div class="col-first odd-row-color"><code><a href="#ENCODE_EQ_INTRO" class="member-name-link">ENCODE_EQ_INTRO</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Builtin theory &ndash; Encode equality introduction
 
 \[
 
   \inferrule{- \mid t}{t=t'}
 \]
 where \(t\) and \(t'\) are equivalent up to their encoding in an
 external proof format.</div>
</div>
<div class="col-first even-row-color"><code><a href="#EQ_RESOLVE" class="member-name-link">EQ_RESOLVE</a></code></div>
<div class="col-last even-row-color">
<div class="block">Boolean &ndash; Equality resolution
 
 \[
 
   \inferrule{F_1, (F_1 = F_2) \mid -}{F_2}
 \]
 Note this can optionally be seen as a macro for
 EQUIV_ELIM1 &lt;cvc5.<a href="#EQUIV_ELIM1"><code>EQUIV_ELIM1</code></a>&gt; +
 RESOLUTION &lt;cvc5.<a href="#RESOLUTION"><code>RESOLUTION</code></a>&gt;.</div>
</div>
<div class="col-first odd-row-color"><code><a href="#EQUIV_ELIM1" class="member-name-link">EQUIV_ELIM1</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Boolean &ndash; Equivalence elimination version 1
 
 \[
 
   \inferrule{F_1 = F_2 \mid -}{\neg F_1 \lor F_2}
 \]</div>
</div>
<div class="col-first even-row-color"><code><a href="#EQUIV_ELIM2" class="member-name-link">EQUIV_ELIM2</a></code></div>
<div class="col-last even-row-color">
<div class="block">Boolean &ndash; Equivalence elimination version 2
 
 \[
 
   \inferrule{F_1 = F_2 \mid -}{F_1 \lor \neg F_2}
 \]</div>
</div>
<div class="col-first odd-row-color"><code><a href="#EVALUATE" class="member-name-link">EVALUATE</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Builtin theory &ndash; Evaluate
 
 \[
 
   \inferrule{- \mid t}{t = \texttt{evaluate}(t)}
 \]
 where \(\texttt{evaluate}\) is implemented by calling the method
 \(\texttt{Evalutor::evaluate}\) in :cvc5src:`theory/evaluator.h` with an
 empty substitution.</div>
</div>
<div class="col-first even-row-color"><code><a href="#EXISTS_STRING_LENGTH" class="member-name-link">EXISTS_STRING_LENGTH</a></code></div>
<div class="col-last even-row-color">
<div class="block">Quantifiers &ndash; Exists string length
 
 \[
 
   \inferrule{-\mid T n i} {\mathit{len}(k) = n}
 \]
 where \(k\) is a skolem of string or sequence type \(T\) and
 \(n\) is a non-negative integer.</div>
</div>
<div class="col-first odd-row-color"><code><a href="#FACTORING" class="member-name-link">FACTORING</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Boolean &ndash; Factoring
 
 \[
 
   \inferrule{C_1 \mid -}{C_2}
 \]
 where \(C_2\) is the clause \(C_1\), but every occurrence of a literal
 after its first occurrence is omitted.</div>
</div>
<div class="col-first even-row-color"><code><a href="#FALSE_ELIM" class="member-name-link">FALSE_ELIM</a></code></div>
<div class="col-last even-row-color">
<div class="block">Equality &ndash; False elim
 
 \[
 
   \inferrule{F=\bot\mid -}{\neg F}
 \]</div>
</div>
<div class="col-first odd-row-color"><code><a href="#FALSE_INTRO" class="member-name-link">FALSE_INTRO</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Equality &ndash; False intro
 
 \[
 
   \inferrule{\neg F\mid -}{F = \bot}
 \]</div>
</div>
<div class="col-first even-row-color"><code><a href="#HO_APP_ENCODE" class="member-name-link">HO_APP_ENCODE</a></code></div>
<div class="col-last even-row-color">
<div class="block">Equality &ndash; Higher-order application encoding
 
 \[
 
   \inferrule{-\mid t}{t=t'}
 \]
 where `t'` is the higher-order application that is equivalent to `t`,
 as implemented by <code>uf.TheoryUfRewriter.getHoApplyForApplyUf</code>.</div>
</div>
<div class="col-first odd-row-color"><code><a href="#HO_CONG" class="member-name-link">HO_CONG</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Equality &ndash; Higher-order congruence
 
 \[
 
   \inferrule{f=g, t_1=s_1,\dots,t_n=s_n\mid k}{k(f, t_1,\dots, t_n) =
   k(g, s_1,\dots, s_n)}
 \]
 Notice that this rule is only used when the application kind \(k\) is
 either `cvc5.Kind.APPLY_UF` or `cvc5.Kind.HO_APPLY`.</div>
</div>
<div class="col-first even-row-color"><code><a href="#IMPLIES_ELIM" class="member-name-link">IMPLIES_ELIM</a></code></div>
<div class="col-last even-row-color">
<div class="block">Boolean &ndash; Implication elimination
 
 \[
 
   \inferrule{F_1 \rightarrow F_2 \mid -}{\neg F_1 \lor F_2}
 \]</div>
</div>
<div class="col-first odd-row-color"><code><a href="#INSTANTIATE" class="member-name-link">INSTANTIATE</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Quantifiers &ndash; Instantiation
 
 \[
 
   \inferrule{\forall x_1\dots x_n.\&gt; F\mid (t_1 \dots t_n), (id\, (t)?)?}
   {F\{x_1\mapsto t_1,\dots,x_n\mapsto t_n\}}
 \]
 The list of terms to instantiate \((t_1 \dots t_n)\) is provided as
 an s-expression as the first argument.</div>
</div>
<div class="col-first even-row-color"><code><a href="#INT_TIGHT_LB" class="member-name-link">INT_TIGHT_LB</a></code></div>
<div class="col-last even-row-color">
<div class="block">Arithmetic &ndash; Tighten strict integer lower bounds
 
 \[
 
   \inferrule{i &gt; c \mid -}{i \geq \lceil c \rceil}
 \]
 where \(i\) has integer type.</div>
</div>
<div class="col-first odd-row-color"><code><a href="#INT_TIGHT_UB" class="member-name-link">INT_TIGHT_UB</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Arithmetic &ndash; Tighten strict integer upper bounds
 
 \[
 
   \inferrule{i &lt; c \mid -}{i \leq \lfloor c \rfloor}
 \]
 where \(i\) has integer type.</div>
</div>
<div class="col-first even-row-color"><code><a href="#ITE_ELIM1" class="member-name-link">ITE_ELIM1</a></code></div>
<div class="col-last even-row-color">
<div class="block">Boolean &ndash; ITE elimination version 1
 
 \[
 
   \inferrule{(\ite{C}{F_1}{F_2}) \mid -}{\neg C \lor F_1}
 \]</div>
</div>
<div class="col-first odd-row-color"><code><a href="#ITE_ELIM2" class="member-name-link">ITE_ELIM2</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Boolean &ndash; ITE elimination version 2
 
 \[
 
   \inferrule{(\ite{C}{F_1}{F_2}) \mid -}{C \lor F_2}
 \]</div>
</div>
<div class="col-first even-row-color"><code><a href="#ITE_EQ" class="member-name-link">ITE_EQ</a></code></div>
<div class="col-last even-row-color">
<div class="block">Processing rules &ndash; If-then-else equivalence
 
 \[
 
   \inferrule{- \mid \ite{C}{t_1}{t_2}}{\ite{C}{((\ite{C}{t_1}{t_2}) = t_1)}{((\ite{C}{t_1}{t_2}) = t_2)}}
 \]</div>
</div>
<div class="col-first odd-row-color"><code><a href="#LFSC_RULE" class="member-name-link">LFSC_RULE</a></code></div>
<div class="col-last odd-row-color">
<div class="block">External &ndash; LFSC
 
 Place holder for LFSC rules.</div>
</div>
<div class="col-first even-row-color"><code><a href="#MACRO_ARITH_SCALE_SUM_UB" class="member-name-link">MACRO_ARITH_SCALE_SUM_UB</a></code></div>
<div class="col-last even-row-color">
<div class="block">Arithmetic &ndash; Adding inequalities
 
 An arithmetic literal is a term of the form \(p \diamond c\) where
 \(\diamond \in \{ &lt;, \leq, =, \geq, &gt; \}\), \(p\) a
 polynomial and \(c\) a rational constant.</div>
</div>
<div class="col-first odd-row-color"><code><a href="#MACRO_BV_BITBLAST" class="member-name-link">MACRO_BV_BITBLAST</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Bit-vectors &ndash; (Macro) Bitblast
 
 \[
 
   \inferrule{-\mid t}{t = \texttt{bitblast}(t)}
 \]
 where \(\texttt{bitblast}\) represents the result of the bit-blasted term as
 a bit-vector consisting of the output bits of the bit-blasted circuit
 representation of the term.</div>
</div>
<div class="col-first even-row-color"><code><a href="#MACRO_RESOLUTION" class="member-name-link">MACRO_RESOLUTION</a></code></div>
<div class="col-last even-row-color">
<div class="block">Boolean &ndash; N-ary Resolution + Factoring + Reordering
 
 \[
 
   \inferrule{C_1 \dots C_n \mid C, pol_1,L_1 \dots pol_{n-1},L_{n-1}}{C}
 \]
 where
 
 
 let \(C_1 \dots C_n\) be nodes viewed as clauses, as defined in
   RESOLUTION &lt;cvc5.<a href="#RESOLUTION"><code>RESOLUTION</code></a>&gt;
 
 let \(C_1 \diamond_{L,\mathit{pol}} C_2\) represent the resolution of
   \(C_1\) with \(C_2\) with pivot \(L\) and polarity
   \(pol\), as defined in
   RESOLUTION &lt;cvc5.<a href="#RESOLUTION"><code>RESOLUTION</code></a>&gt;
 
 let \(C_1'\) be equal, in its set representation, to \(C_1\),
 
 for each \(i &gt; 1\), let \(C_i'\) be equal, in its set
   representation, to \(C_{i-1} \diamond_{L_{i-1},\mathit{pol}_{i-1}}
   C_i'\)
 
 
 The result of the chain resolution is \(C\), which is equal, in its set
 representation, to \(C_n'\)</div>
</div>
<div class="col-first odd-row-color"><code><a href="#MACRO_RESOLUTION_TRUST" class="member-name-link">MACRO_RESOLUTION_TRUST</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Boolean &ndash; N-ary Resolution + Factoring + Reordering unchecked
 
 Same as
 MACRO_RESOLUTION &lt;cvc5.<a href="#MACRO_RESOLUTION"><code>MACRO_RESOLUTION</code></a>&gt;, but
 not checked by the internal proof checker.</div>
</div>
<div class="col-first even-row-color"><code><a href="#MACRO_REWRITE" class="member-name-link">MACRO_REWRITE</a></code></div>
<div class="col-last even-row-color">
<div class="block">Builtin theory &ndash; Rewrite
 
 \[
 
   \inferrule{- \mid t, idr}{t = \texttt{rewrite}_{idr}(t)}
 \]
 where \(idr\) is a MethodId identifier, which determines the kind of
 rewriter to apply, e.g., Rewriter.rewrite.</div>
</div>
<div class="col-first odd-row-color"><code><a href="#MACRO_SR_EQ_INTRO" class="member-name-link">MACRO_SR_EQ_INTRO</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Builtin theory &ndash; Substitution + Rewriting equality introduction
 
 In this rule, we provide a term \(t\) and conclude that it is equal to
 its rewritten form under a (proven) substitution.</div>
</div>
<div class="col-first even-row-color"><code><a href="#MACRO_SR_PRED_ELIM" class="member-name-link">MACRO_SR_PRED_ELIM</a></code></div>
<div class="col-last even-row-color">
<div class="block">Builtin theory &ndash; Substitution + Rewriting predicate elimination
 
 \[
 
   \inferrule{F, F_1 \dots F_n \mid (ids (ida
   (idr)?)?)?}{\texttt{rewrite}_{idr}(F \circ \sigma_{ids, ida}(F_n) \circ
   \cdots \circ \sigma_{ids, ida}(F_1))}
 \]
 where \(ids\) and \(idr\) are method identifiers.</div>
</div>
<div class="col-first odd-row-color"><code><a href="#MACRO_SR_PRED_INTRO" class="member-name-link">MACRO_SR_PRED_INTRO</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Builtin theory &ndash; Substitution + Rewriting predicate introduction
 
 In this rule, we provide a formula \(F\) and conclude it, under the
 condition that it rewrites to true under a proven substitution.</div>
</div>
<div class="col-first even-row-color"><code><a href="#MACRO_SR_PRED_TRANSFORM" class="member-name-link">MACRO_SR_PRED_TRANSFORM</a></code></div>
<div class="col-last even-row-color">
<div class="block">Builtin theory &ndash; Substitution + Rewriting predicate elimination
 
 \[
 
   \inferrule{F, F_1 \dots F_n \mid G, (ids (ida (idr)?)?)?}{G}
 \]
 where
 
 \[
 
   \texttt{rewrite}_{idr}(F \circ \sigma_{ids, ida}(F_n) \circ\cdots \circ \sigma_{ids, ida}(F_1)) =\\ \texttt{rewrite}_{idr}(G \circ \sigma_{ids, ida}(F_n) \circ \cdots \circ \sigma_{ids, ida}(F_1))
 \]
 More generally, this rule also holds when:
 \(\texttt{Rewriter::rewrite}(\texttt{toOriginal}(F')) = \texttt{Rewriter::rewrite}(\texttt{toOriginal}(G'))\)
 where \(F'\) and \(G'\) are the result of each side of the equation
 above.</div>
</div>
<div class="col-first odd-row-color"><code><a href="#MACRO_STRING_INFERENCE" class="member-name-link">MACRO_STRING_INFERENCE</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Strings &ndash; (Macro) String inference
 
 \[
 
   \inferrule{?\mid F,\mathit{id},\mathit{isRev},\mathit{exp}}{F}
 \]
 used to bookkeep an inference that has not yet been converted via
 \(\texttt{strings::InferProofCons::convert}\).</div>
</div>
<div class="col-first even-row-color"><code><a href="#MODUS_PONENS" class="member-name-link">MODUS_PONENS</a></code></div>
<div class="col-last even-row-color">
<div class="block">Boolean &ndash; Modus Ponens
 
 \[
 
   \inferrule{F_1, (F_1 \rightarrow F_2) \mid -}{F_2}
 \]
 Note this can optionally be seen as a macro for
 IMPLIES_ELIM &lt;cvc5.<a href="#IMPLIES_ELIM"><code>IMPLIES_ELIM</code></a>&gt; +
 RESOLUTION &lt;cvc5.<a href="#RESOLUTION"><code>RESOLUTION</code></a>&gt;.</div>
</div>
<div class="col-first odd-row-color"><code><a href="#NARY_CONG" class="member-name-link">NARY_CONG</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Equality &ndash; N-ary Congruence
 
 \[
 
   \inferrule{t_1=s_1,\dots,t_n=s_n\mid f(t_1,\dots, t_n)}{f(t_1,\dots, t_n) = f(s_1,\dots, s_n)}
 \]
 This rule is used for terms \(f(t_1,\dots, t_n)\) whose kinds
 \(k\) have variadic arity, such as <code>cvc5.Kind.AND</code>,
 <code>cvc5.Kind.PLUS</code> and so on.</div>
</div>
<div class="col-first even-row-color"><code><a href="#NOT_AND" class="member-name-link">NOT_AND</a></code></div>
<div class="col-last even-row-color">
<div class="block">Boolean &ndash; De Morgan &ndash; Not And
 
 \[
 
   \inferrule{\neg(F_1 \land \dots \land F_n) \mid -}{\neg F_1 \lor \dots
   \lor \neg F_n}
 \]</div>
</div>
<div class="col-first odd-row-color"><code><a href="#NOT_EQUIV_ELIM1" class="member-name-link">NOT_EQUIV_ELIM1</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Boolean &ndash; Not Equivalence elimination version 1
 
 \[
 
   \inferrule{F_1 \neq F_2 \mid -}{F_1 \lor F_2}
 \]</div>
</div>
<div class="col-first even-row-color"><code><a href="#NOT_EQUIV_ELIM2" class="member-name-link">NOT_EQUIV_ELIM2</a></code></div>
<div class="col-last even-row-color">
<div class="block">Boolean &ndash; Not Equivalence elimination version 2
 
 \[
 
   \inferrule{F_1 \neq F_2 \mid -}{\neg F_1 \lor \neg F_2}
 \]</div>
</div>
<div class="col-first odd-row-color"><code><a href="#NOT_IMPLIES_ELIM1" class="member-name-link">NOT_IMPLIES_ELIM1</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Boolean &ndash; Not Implication elimination version 1
 
 \[
 
   \inferrule{\neg(F_1 \rightarrow F_2) \mid -}{F_1}
 \]</div>
</div>
<div class="col-first even-row-color"><code><a href="#NOT_IMPLIES_ELIM2" class="member-name-link">NOT_IMPLIES_ELIM2</a></code></div>
<div class="col-last even-row-color">
<div class="block">Boolean &ndash; Not Implication elimination version 2
 
 \[
 
   \inferrule{\neg(F_1 \rightarrow F_2) \mid -}{\neg F_2}
 \]</div>
</div>
<div class="col-first odd-row-color"><code><a href="#NOT_ITE_ELIM1" class="member-name-link">NOT_ITE_ELIM1</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Boolean &ndash; Not ITE elimination version 1
 
 \[
 
   \inferrule{\neg(\ite{C}{F_1}{F_2}) \mid -}{\neg C \lor \neg F_1}
 \]</div>
</div>
<div class="col-first even-row-color"><code><a href="#NOT_ITE_ELIM2" class="member-name-link">NOT_ITE_ELIM2</a></code></div>
<div class="col-last even-row-color">
<div class="block">Boolean &ndash; Not ITE elimination version 2
 
 \[
 
   \inferrule{\neg(\ite{C}{F_1}{F_2}) \mid -}{C \lor \neg F_2}
 \]</div>
</div>
<div class="col-first odd-row-color"><code><a href="#NOT_NOT_ELIM" class="member-name-link">NOT_NOT_ELIM</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Boolean &ndash; Double negation elimination
 
 \[
 
   \inferrule{\neg (\neg F) \mid -}{F}
 \]</div>
</div>
<div class="col-first even-row-color"><code><a href="#NOT_OR_ELIM" class="member-name-link">NOT_OR_ELIM</a></code></div>
<div class="col-last even-row-color">
<div class="block">Boolean &ndash; Not Or elimination
 
 \[
 
   \inferrule{\neg(F_1 \lor \dots \lor F_n) \mid i}{\neg F_i}
 \]</div>
</div>
<div class="col-first odd-row-color"><code><a href="#NOT_XOR_ELIM1" class="member-name-link">NOT_XOR_ELIM1</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Boolean &ndash; Not XOR elimination version 1
 
 \[
 
   \inferrule{\neg(F_1 \xor F_2) \mid -}{F_1 \lor \neg F_2}
 \]</div>
</div>
<div class="col-first even-row-color"><code><a href="#NOT_XOR_ELIM2" class="member-name-link">NOT_XOR_ELIM2</a></code></div>
<div class="col-last even-row-color">
<div class="block">Boolean &ndash; Not XOR elimination version 2
 
 \[
 
   \inferrule{\neg(F_1 \xor F_2) \mid -}{\neg F_1 \lor F_2}
 \]</div>
</div>
<div class="col-first odd-row-color"><code><a href="#QUANT_VAR_REORDERING" class="member-name-link">QUANT_VAR_REORDERING</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Quantifiers &ndash; Variable reordering
 
 \[
 
   \inferrule{-\mid (\forall X.\&gt; F) = (\forall Y.\&gt; F)}
   {(\forall X.\&gt; F) = (\forall Y.\&gt; F)}
 \]
 where \(Y\) is a reordering of \(X\).</div>
</div>
<div class="col-first even-row-color"><code><a href="#RE_CONCAT" class="member-name-link">RE_CONCAT</a></code></div>
<div class="col-last even-row-color">
<div class="block">Strings &ndash; Regular expressions &ndash; Concatenation
 
 \[
 
   \inferrule{t_1\in R_1,\,\ldots,\,t_n\in R_n\mid -}{\text{str.++}(t_1, \ldots, t_n)\in \text{re.++}(R_1, \ldots, R_n)}
 \]</div>
</div>
<div class="col-first odd-row-color"><code><a href="#RE_INTER" class="member-name-link">RE_INTER</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Strings &ndash; Regular expressions &ndash; Intersection
 
 \[
 
   \inferrule{t\in R_1,\,t\in R_2\mid -}{t\in \mathit{re.inter}(R_1,R_2)}
 \]</div>
</div>
<div class="col-first even-row-color"><code><a href="#RE_UNFOLD_NEG" class="member-name-link">RE_UNFOLD_NEG</a></code></div>
<div class="col-last even-row-color">
<div class="block">Strings &ndash; Regular expressions &ndash; Negative Unfold
 
 \[
 
   \inferrule{t \not \in \mathit{re}.\text{*}(R) \mid -}{t \neq \ \epsilon \ \wedge \forall L.</div>
</div>
<div class="col-first odd-row-color"><code><a href="#RE_UNFOLD_NEG_CONCAT_FIXED" class="member-name-link">RE_UNFOLD_NEG_CONCAT_FIXED</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Strings &ndash; Regular expressions &ndash; Unfold negative concatenation, fixed
 
 ..</div>
</div>
<div class="col-first even-row-color"><code><a href="#RE_UNFOLD_POS" class="member-name-link">RE_UNFOLD_POS</a></code></div>
<div class="col-last even-row-color">
<div class="block">Strings &ndash; Regular expressions &ndash; Positive Unfold
 
 \[
 
   \inferrule{t\in R\mid -}{F}
 \]
 where \(F\) corresponds to the one-step unfolding of the premise.</div>
</div>
<div class="col-first odd-row-color"><code><a href="#REFL" class="member-name-link">REFL</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Equality &ndash; Reflexivity
 
 \[
 
   \inferrule{-\mid t}{t = t}
 \]</div>
</div>
<div class="col-first even-row-color"><code><a href="#REORDERING" class="member-name-link">REORDERING</a></code></div>
<div class="col-last even-row-color">
<div class="block">Boolean &ndash; Reordering
 
 \[
 
   \inferrule{C_1 \mid C_2}{C_2}
 \]
 where
 the multiset representations of \(C_1\) and \(C_2\) are the same.</div>
</div>
<div class="col-first odd-row-color"><code><a href="#RESOLUTION" class="member-name-link">RESOLUTION</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Boolean &ndash; Resolution
 
 \[
 
   \inferrule{C_1, C_2 \mid pol, L}{C}
 \]
 where
 
 
 \(C_1\) and \(C_2\) are nodes viewed as clauses, i.e., either an
   <code>OR</code> node with each children viewed as a literal or a node viewed as a
   literal.</div>
</div>
<div class="col-first even-row-color"><code><a href="#SAT_EXTERNAL_PROVE" class="member-name-link">SAT_EXTERNAL_PROVE</a></code></div>
<div class="col-last even-row-color">
<div class="block">SAT external prove Refutation
 
 \[
 
   \inferrule{F_1 \dots F_n \mid D}{\bot}
 \]
 where \(F_1 \dots F_n\) correspond to the input clauses in the
 DIMACS file `D`.</div>
</div>
<div class="col-first odd-row-color"><code><a href="#SAT_REFUTATION" class="member-name-link">SAT_REFUTATION</a></code></div>
<div class="col-last odd-row-color">
<div class="block">SAT Refutation for assumption-based unsat cores
 
 \[
 
   \inferrule{F_1 \dots F_n \mid -}{\bot}
 \]
 where \(F_1 \dots F_n\) correspond to the unsat core determined by the
 SAT solver.</div>
</div>
<div class="col-first even-row-color"><code><a href="#SCOPE" class="member-name-link">SCOPE</a></code></div>
<div class="col-last even-row-color">
<div class="block">Scope (a binder for assumptions)
 
 \[
 
   \inferruleSC{F \mid F_1 \dots F_n}{(F_1 \land \dots \land F_n)
   \Rightarrow F}{if $F\neq\bot$} \textrm{ or } \inferruleSC{F \mid F_1
   \dots F_n}{\neg (F_1 \land \dots \land F_n)}{if $F=\bot$}
 \]
 This rule has a dual purpose with
 ASSUME &lt;cvc5.<a href="#ASSUME"><code>ASSUME</code></a>&gt;.</div>
</div>
<div class="col-first odd-row-color"><code><a href="#SETS_EXT" class="member-name-link">SETS_EXT</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Sets &ndash; Sets extensionality
 
 \[
 
   \inferrule{a \neq b\mid -}
   {\mathit{set.member}(k,a)\neq\mathit{set.member}(k,b)}
 \]
 where \(k\) is the \(\texttt{SETS_DEQ_DIFF}\) skolem for `(a, b)`.</div>
</div>
<div class="col-first even-row-color"><code><a href="#SETS_FILTER_DOWN" class="member-name-link">SETS_FILTER_DOWN</a></code></div>
<div class="col-last even-row-color">
<div class="block">Sets &ndash; Sets filter down
 
 \[
 
   \inferrule{\mathit{set.member}(x,\mathit{set.filter}(P, a))\mid -}
   {\mathit{set.member}(x,a) \wedge P(x)}
 \]</div>
</div>
<div class="col-first odd-row-color"><code><a href="#SETS_FILTER_UP" class="member-name-link">SETS_FILTER_UP</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Sets &ndash; Sets filter up
 
 \[
 
   \inferrule{\mathit{set.member}(x,a)\mid P}
   {\mathit{set.member}(x, \mathit{set.filter}(P, a)) = P(x)}
 \]</div>
</div>
<div class="col-first even-row-color"><code><a href="#SETS_SINGLETON_INJ" class="member-name-link">SETS_SINGLETON_INJ</a></code></div>
<div class="col-last even-row-color">
<div class="block">Sets &ndash; Singleton injectivity
 
 \[
 
   \inferrule{\mathit{set.singleton}(t) = \mathit{set.singleton}(s)\mid -}{t=s}
 \]</div>
</div>
<div class="col-first odd-row-color"><code><a href="#SKOLEM_INTRO" class="member-name-link">SKOLEM_INTRO</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Quantifiers &ndash; Skolem introduction
 
 \[
 
   \inferrule{-\mid k}{k = t}
 \]
 where \(t\) is the unpurified form of skolem \(k\).</div>
</div>
<div class="col-first even-row-color"><code><a href="#SKOLEMIZE" class="member-name-link">SKOLEMIZE</a></code></div>
<div class="col-last even-row-color">
<div class="block">Quantifiers &ndash; Skolemization
 
 \[
 
   \inferrule{\neg (\forall x_1\dots x_n.\&gt; F)\mid -}{\neg F\sigma}
 \]
 where \(\sigma\) maps \(x_1,\dots,x_n\) to their representative
 skolems, which are skolems \(k_1,\dots,k_n\).</div>
</div>
<div class="col-first odd-row-color"><code><a href="#SPLIT" class="member-name-link">SPLIT</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Boolean &ndash; Split
 
 \[
 
   \inferrule{- \mid F}{F \lor \neg F}
 \]</div>
</div>
<div class="col-first even-row-color"><code><a href="#STRING_CODE_INJ" class="member-name-link">STRING_CODE_INJ</a></code></div>
<div class="col-last even-row-color">
<div class="block">Strings &ndash; Code points
 
 \[
 
   \inferrule{-\mid t,s}{\mathit{to\_code}(t) = -1 \vee \mathit{to\_code}(t) \neq
   \mathit{to\_code}(s) \vee t = s}
 \]</div>
</div>
<div class="col-first odd-row-color"><code><a href="#STRING_DECOMPOSE" class="member-name-link">STRING_DECOMPOSE</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Strings &ndash; Core rules &ndash; String decomposition
 
 \[
 
   \inferrule{\mathit{len}(t) \geq n\mid \bot}{t = w_1\cdot w_2 \wedge
   \mathit{len}(w_1) = n}
 \]
 where \(w_1\) is the purification skolem for \(\mathit{pre}(t,n)\)
 and \(w_2\) is the purification skolem for \(\mathit{suf}(t,n)\).</div>
</div>
<div class="col-first even-row-color"><code><a href="#STRING_EAGER_REDUCTION" class="member-name-link">STRING_EAGER_REDUCTION</a></code></div>
<div class="col-last even-row-color">
<div class="block">Strings &ndash; Extended functions &ndash; Eager reduction
 
 \[
 
   \inferrule{-\mid t}{R}
 \]
 where \(R\) is \(\texttt{TermRegistry::eagerReduce}(t)\).</div>
</div>
<div class="col-first odd-row-color"><code><a href="#STRING_EXT" class="member-name-link">STRING_EXT</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Strings &ndash; Extensionality
 
 \[
 
   \inferrule{s \neq t\mid -}
   {\mathit{seq.len}(s) \neq \mathit{seq.len}(t) \vee (\mathit{seq.nth}(s,k)\neq\mathit{set.nth}(t,k) \wedge 0 \leq k \wedge k &lt; \mathit{seq.len}(s))}
 \]
 where \(s,t\) are terms of sequence type, \(k\) is the
 \(\texttt{STRINGS_DEQ_DIFF}\) skolem for \(s,t\).</div>
</div>
<div class="col-first even-row-color"><code><a href="#STRING_LENGTH_NON_EMPTY" class="member-name-link">STRING_LENGTH_NON_EMPTY</a></code></div>
<div class="col-last even-row-color">
<div class="block">Strings &ndash; Core rules &ndash; Length non-empty
 
 \[
 
   \inferrule{t\neq \epsilon\mid -}{\mathit{len}(t) \neq 0}
 \]</div>
</div>
<div class="col-first odd-row-color"><code><a href="#STRING_LENGTH_POS" class="member-name-link">STRING_LENGTH_POS</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Strings &ndash; Core rules &ndash; Length positive
 
 \[
 
   \inferrule{-\mid t}{(\mathit{len}(t) = 0\wedge t= \epsilon)\vee \mathit{len}(t)
   &gt; 0}
 \]</div>
</div>
<div class="col-first even-row-color"><code><a href="#STRING_REDUCTION" class="member-name-link">STRING_REDUCTION</a></code></div>
<div class="col-last even-row-color">
<div class="block">Strings &ndash; Extended functions &ndash; Reduction
 
 \[
 
   \inferrule{-\mid t}{R\wedge t = w}
 \]
 where \(w\) is \(\texttt{StringsPreprocess::reduce}(t, R,
 \dots)\).</div>
</div>
<div class="col-first odd-row-color"><code><a href="#STRING_SEQ_UNIT_INJ" class="member-name-link">STRING_SEQ_UNIT_INJ</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Strings &ndash; Sequence unit
 
 \[
 
   \inferrule{\mathit{unit}(x) = \mathit{unit}(y)\mid -}{x = y}
 \]
 Also applies to the case where \(\mathit{unit}(y)\) is a constant
 sequence of length one.</div>
</div>
<div class="col-first even-row-color"><code><a href="#SUBS" class="member-name-link">SUBS</a></code></div>
<div class="col-last even-row-color">
<div class="block">Builtin theory &ndash; Substitution
 
 \[
 
   \inferrule{F_1 \dots F_n \mid t, ids?}{t = t \circ \sigma_{ids}(F_n)
   \circ \cdots \circ \sigma_{ids}(F_1)}
 \]
 where \(\sigma_{ids}(F_i)\) are substitutions, which notice are applied
 in reverse order.</div>
</div>
<div class="col-first odd-row-color"><code><a href="#SYMM" class="member-name-link">SYMM</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Equality &ndash; Symmetry
 
 \[
 
   \inferrule{t_1 = t_2\mid -}{t_2 = t_1}
 \]
 or
 
 \[
 
   \inferrule{t_1 \neq t_2\mid -}{t_2 \neq t_1}
 \]</div>
</div>
<div class="col-first even-row-color"><code><a href="#THEORY_REWRITE" class="member-name-link">THEORY_REWRITE</a></code></div>
<div class="col-last even-row-color">
<div class="block">Other theory rewrite rules
 
 \[
 
   \inferrule{- \mid id, t = t'}{t = t'}
 \]
 where `id` is the ProofRewriteRule of the theory rewrite
 rule which transforms \(t\) to \(t'\).</div>
</div>
<div class="col-first odd-row-color"><code><a href="#TRANS" class="member-name-link">TRANS</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Equality &ndash; Transitivity
 
 \[
 
   \inferrule{t_1=t_2,\dots,t_{n-1}=t_n\mid -}{t_1 = t_n}
 \]</div>
</div>
<div class="col-first even-row-color"><code><a href="#TRUE_ELIM" class="member-name-link">TRUE_ELIM</a></code></div>
<div class="col-last even-row-color">
<div class="block">Equality &ndash; True elim
 
 \[
 
   \inferrule{F=\top\mid -}{F}
 \]</div>
</div>
<div class="col-first odd-row-color"><code><a href="#TRUE_INTRO" class="member-name-link">TRUE_INTRO</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Equality &ndash; True intro
 
 \[
 
   \inferrule{F\mid -}{F = \top}
 \]</div>
</div>
<div class="col-first even-row-color"><code><a href="#TRUST" class="member-name-link">TRUST</a></code></div>
<div class="col-last even-row-color">
<div class="block">Trusted rule
 
 \[
 
   \inferrule{F_1 \dots F_n \mid tid, F, ...}{F}
 \]
 where \(tid\) is an identifier and \(F\) is a formula.</div>
</div>
<div class="col-first odd-row-color"><code><a href="#TRUST_THEORY_REWRITE" class="member-name-link">TRUST_THEORY_REWRITE</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Trusted rules &ndash; Theory rewrite
 
 \[
 
   \inferrule{- \mid F, tid, rid}{F}
 \]
 where \(F\) is an equality of the form \(t = t'\) where \(t'\)
 is obtained by applying the kind of rewriting given by the method
 identifier \(rid\), which is one of:
 <code>RW_REWRITE_THEORY_PRE</code>, <code>RW_REWRITE_THEORY_POST</code>,
 <code>RW_REWRITE_EQ_EXT</code>.</div>
</div>
<div class="col-first even-row-color"><code><a href="#UNKNOWN" class="member-name-link">UNKNOWN</a></code></div>
<div class="col-last even-row-color">
<div class="block">External &ndash; Alethe
 
 Place holder for Alethe rules.</div>
</div>
<div class="col-first odd-row-color"><code><a href="#XOR_ELIM1" class="member-name-link">XOR_ELIM1</a></code></div>
<div class="col-last odd-row-color">
<div class="block">Boolean &ndash; XOR elimination version 1
 
 \[
 
   \inferrule{F_1 \xor F_2 \mid -}{F_1 \lor F_2}
 \]</div>
</div>
<div class="col-first even-row-color"><code><a href="#XOR_ELIM2" class="member-name-link">XOR_ELIM2</a></code></div>
<div class="col-last even-row-color">
<div class="block">Boolean &ndash; XOR elimination version 2
 
 \[
 
   \inferrule{F_1 \xor F_2 \mid -}{\neg F_1 \lor \neg F_2}
 \]</div>
</div>
</div>
</section>
</li>
<!-- ========== METHOD SUMMARY =========== -->
<li>
<section class="method-summary" id="method-summary">
<h2>Method Summary</h2>
<div id="method-summary-table">
<div class="table-tabs" role="tablist" aria-orientation="horizontal"><button id="method-summary-table-tab0" role="tab" aria-selected="true" aria-controls="method-summary-table.tabpanel" tabindex="0" onkeydown="switchTab(event)" onclick="show('method-summary-table', 'method-summary-table', 3)" class="active-table-tab">All Methods</button><button id="method-summary-table-tab1" role="tab" aria-selected="false" aria-controls="method-summary-table.tabpanel" tabindex="-1" onkeydown="switchTab(event)" onclick="show('method-summary-table', 'method-summary-table-tab1', 3)" class="table-tab">Static Methods</button><button id="method-summary-table-tab2" role="tab" aria-selected="false" aria-controls="method-summary-table.tabpanel" tabindex="-1" onkeydown="switchTab(event)" onclick="show('method-summary-table', 'method-summary-table-tab2', 3)" class="table-tab">Instance Methods</button><button id="method-summary-table-tab4" role="tab" aria-selected="false" aria-controls="method-summary-table.tabpanel" tabindex="-1" onkeydown="switchTab(event)" onclick="show('method-summary-table', 'method-summary-table-tab4', 3)" class="table-tab">Concrete Methods</button></div>
<div id="method-summary-table.tabpanel" role="tabpanel" aria-labelledby="method-summary-table-tab0">
<div class="summary-table three-column-summary">
<div class="table-header col-first">Modifier and Type</div>
<div class="table-header col-second">Method</div>
<div class="table-header col-last">Description</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static <a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#fromInt(int)" class="member-name-link">fromInt</a><wbr>(int&nbsp;value)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Converts an integer value to the corresponding enum constant.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>int</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#getValue()" class="member-name-link">getValue</a>()</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">Get the integer value associated with this enum constant.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static <a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#valueOf(java.lang.String)" class="member-name-link">valueOf</a><wbr>(<a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a>&nbsp;name)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Returns the enum constant of this class with the specified name.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code>static <a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a>[]</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4"><code><a href="#values()" class="member-name-link">values</a>()</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab1 method-summary-table-tab4">
<div class="block">Returns an array containing the constants of this enum class, in
the order they are declared.</div>
</div>
</div>
</div>
</div>
<div class="inherited-list">
<h3 id="methods-inherited-from-class-java.lang.Enum">Methods inherited from class&nbsp;java.lang.<a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Enum.html" title="class or interface in java.lang" class="external-link">Enum</a></h3>
<code><a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Enum.html#clone()" title="class or interface in java.lang" class="external-link">clone</a>, <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Enum.html#compareTo(E)" title="class or interface in java.lang" class="external-link">compareTo</a>, <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Enum.html#describeConstable()" title="class or interface in java.lang" class="external-link">describeConstable</a>, <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Enum.html#equals(java.lang.Object)" title="class or interface in java.lang" class="external-link">equals</a>, <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Enum.html#finalize()" title="class or interface in java.lang" class="external-link">finalize</a>, <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Enum.html#getDeclaringClass()" title="class or interface in java.lang" class="external-link">getDeclaringClass</a>, <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Enum.html#hashCode()" title="class or interface in java.lang" class="external-link">hashCode</a>, <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Enum.html#name()" title="class or interface in java.lang" class="external-link">name</a>, <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Enum.html#ordinal()" title="class or interface in java.lang" class="external-link">ordinal</a>, <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Enum.html#toString()" title="class or interface in java.lang" class="external-link">toString</a>, <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Enum.html#valueOf(java.lang.Class,java.lang.String)" title="class or interface in java.lang" class="external-link">valueOf</a></code></div>
<div class="inherited-list">
<h3 id="methods-inherited-from-class-java.lang.Object">Methods inherited from class&nbsp;java.lang.<a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Object.html" title="class or interface in java.lang" class="external-link">Object</a></h3>
<code><a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Object.html#getClass()" title="class or interface in java.lang" class="external-link">getClass</a>, <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Object.html#notify()" title="class or interface in java.lang" class="external-link">notify</a>, <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Object.html#notifyAll()" title="class or interface in java.lang" class="external-link">notifyAll</a>, <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Object.html#wait()" title="class or interface in java.lang" class="external-link">wait</a>, <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Object.html#wait(long)" title="class or interface in java.lang" class="external-link">wait</a>, <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Object.html#wait(long,int)" title="class or interface in java.lang" class="external-link">wait</a></code></div>
</section>
</li>
</ul>
</section>
<section class="details">
<ul class="details-list">
<!-- ============ ENUM CONSTANT DETAIL =========== -->
<li>
<section class="constant-details" id="enum-constant-detail">
<h2>Enum Constant Details</h2>
<ul class="member-list">
<li>
<section class="detail" id="ASSUME">
<h3>ASSUME</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">ASSUME</span></div>
<div class="block">Assumption (a leaf)
 
 \[
 
   \inferrule{- \mid F}{F}
 \]
 This rule has special status, in that an application of assume is an
 open leaf in a proof that is not (yet) justified. An assume leaf is
 analogous to a free variable in a term, where we say "F is a free
 assumption in proof P" if it contains an application of F that is not
 bound by SCOPE &lt;cvc5.<a href="#SCOPE"><code>SCOPE</code></a>&gt; (see below).</div>
</section>
</li>
<li>
<section class="detail" id="SCOPE">
<h3>SCOPE</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">SCOPE</span></div>
<div class="block">Scope (a binder for assumptions)
 
 \[
 
   \inferruleSC{F \mid F_1 \dots F_n}{(F_1 \land \dots \land F_n)
   \Rightarrow F}{if $F\neq\bot$} \textrm{ or } \inferruleSC{F \mid F_1
   \dots F_n}{\neg (F_1 \land \dots \land F_n)}{if $F=\bot$}
 \]
 This rule has a dual purpose with
 ASSUME &lt;cvc5.<a href="#ASSUME"><code>ASSUME</code></a>&gt;. It is a way to close
 assumptions in a proof. We require that \(F_1 \dots F_n\) are free
 assumptions in P and say that \(F_1 \dots F_n\) are not free in
 <code>(SCOPE P)</code>. In other words, they are bound by this application. For
 example, the proof node:
 <code>(SCOPE (ASSUME F) :args F)</code>
 has the conclusion \(F \Rightarrow F\) and has no free assumptions.
 More generally, a proof with no free assumptions always concludes a valid
 formula.</div>
</section>
</li>
<li>
<section class="detail" id="SUBS">
<h3>SUBS</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">SUBS</span></div>
<div class="block">Builtin theory &ndash; Substitution
 
 \[
 
   \inferrule{F_1 \dots F_n \mid t, ids?}{t = t \circ \sigma_{ids}(F_n)
   \circ \cdots \circ \sigma_{ids}(F_1)}
 \]
 where \(\sigma_{ids}(F_i)\) are substitutions, which notice are applied
 in reverse order. Notice that \(ids\) is a MethodId identifier, which
 determines how to convert the formulas \(F_1 \dots F_n\) into
 substitutions. It is an optional argument, where by default the premises
 are equalities of the form `(= x y)` and converted into substitutions
 \(x\mapsto y\).</div>
</section>
</li>
<li>
<section class="detail" id="MACRO_REWRITE">
<h3>MACRO_REWRITE</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">MACRO_REWRITE</span></div>
<div class="block">Builtin theory &ndash; Rewrite
 
 \[
 
   \inferrule{- \mid t, idr}{t = \texttt{rewrite}_{idr}(t)}
 \]
 where \(idr\) is a MethodId identifier, which determines the kind of
 rewriter to apply, e.g., Rewriter.rewrite.</div>
</section>
</li>
<li>
<section class="detail" id="EVALUATE">
<h3>EVALUATE</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">EVALUATE</span></div>
<div class="block">Builtin theory &ndash; Evaluate
 
 \[
 
   \inferrule{- \mid t}{t = \texttt{evaluate}(t)}
 \]
 where \(\texttt{evaluate}\) is implemented by calling the method
 \(\texttt{Evalutor::evaluate}\) in :cvc5src:`theory/evaluator.h` with an
 empty substitution.
 Note this is equivalent to: <code>(REWRITE t {@link MethodId#RW_EVALUATE)}</code>.
 
 Note this proof rule only applies to atomic sorts, that is, operators on
 Int, Real, String, Bool or BitVector.</div>
</section>
</li>
<li>
<section class="detail" id="DISTINCT_VALUES">
<h3>DISTINCT_VALUES</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">DISTINCT_VALUES</span></div>
<div class="block">Builtin theory &ndash; Distinct values
 
 \[
 
   \inferrule{- \mid t, s}{\neg t = s}
 \]
 where \(t\) and \(s\) are distinct values.
 
 Note that cvc5 internally has a notion of which terms denote "values".
 This property is implemented for any sort that can appear in equalities.
 A term denotes a value if and only if it is the canonical representation
 of a value of that sort. For example, set values are a chain of unions of
 singleton sets whose elements are also values, where this chain is sorted.
 Any two distinct values are semantically disequal in all models.
 
 In practice, we use this rule only to show the distinctness of non-atomic
 sort, e.g. Sets, Sequences, Datatypes, Arrays, etc.
 
 Note that internally, the notion of value is implemented by the
 Node.isConst method.</div>
</section>
</li>
<li>
<section class="detail" id="ACI_NORM">
<h3>ACI_NORM</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">ACI_NORM</span></div>
<div class="block">Builtin theory &ndash; associative/commutative/idempotency/identity \
 normalization
 
 \[
 
   \inferrule{- \mid t = s}{t = s}
 \]
 where \(t\) and \(s\) are equivalent modulo associativity
 and identity elements, and (optionally) commutativity and idempotency.
 
 This method normalizes currently based on two kinds of operators:
 (1) those that are associative, commutative, idempotent, and have an
 identity element (examples are or, and, bvand),
 (2) those that are associative, commutative and have an identity
 element (bvxor),
 (3) those that are associative and have an identity element (examples
 are concat, str.++, re.++).
 
 This is implemented internally by checking that
 \(\texttt{expr::isACINorm(t, s)} = \top\). For details, see
 :cvc5src:`expr/aci_norm.h`.</div>
</section>
</li>
<li>
<section class="detail" id="ABSORB">
<h3>ABSORB</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">ABSORB</span></div>
<div class="block">Builtin theory &ndash; absorb
 
 \[
 
   \inferrule{- \mid t = z}{t = z}
 \]
 where \(t\) contains \(z\) as a subterm, where \(z\)
 is a zero element.
 
 In particular, \(t\) is expected to be an application of a
 function with a zero element \(z\), and \(z\) is contained
 as a subterm of \(t\) beneath applications of that function.
 For example, this may show that \((A \wedge ( B \wedge \bot)) = \bot\).
 
 This is implemented internally by checking that
 \(\texttt{expr::isAbsorb(t, z)} = \top\). For details, see
 :cvc5src:`expr/aci_norm.h`.</div>
</section>
</li>
<li>
<section class="detail" id="MACRO_SR_EQ_INTRO">
<h3>MACRO_SR_EQ_INTRO</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">MACRO_SR_EQ_INTRO</span></div>
<div class="block">Builtin theory &ndash; Substitution + Rewriting equality introduction
 
 In this rule, we provide a term \(t\) and conclude that it is equal to
 its rewritten form under a (proven) substitution.
 
 \[
 
   \inferrule{F_1 \dots F_n \mid t, (ids (ida (idr)?)?)?}{t =
   \texttt{rewrite}_{idr}(t \circ \sigma_{ids, ida}(F_n) \circ \cdots \circ
   \sigma_{ids, ida}(F_1))}
 \]
 In other words, from the point of view of Skolem forms, this rule
 transforms \(t\) to \(t'\) by standard substitution + rewriting.
 
 The arguments \(ids\), \(ida\) and \(idr\) are optional and
 specify the identifier of the substitution, the substitution application
 and rewriter respectively to be used. For details, see
 :cvc5src:`theory/builtin/proof_checker.h`.</div>
</section>
</li>
<li>
<section class="detail" id="MACRO_SR_PRED_INTRO">
<h3>MACRO_SR_PRED_INTRO</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">MACRO_SR_PRED_INTRO</span></div>
<div class="block">Builtin theory &ndash; Substitution + Rewriting predicate introduction
 
 In this rule, we provide a formula \(F\) and conclude it, under the
 condition that it rewrites to true under a proven substitution.
 
 \[
 
   \inferrule{F_1 \dots F_n \mid F, (ids (ida (idr)?)?)?}{F}
 \]
 where \(\texttt{rewrite}_{idr}(F \circ \sigma_{ids, ida}(F_n) \circ
 \cdots \circ \sigma_{ids, ida}(F_1)) = \top\) and \(ids\) and
 \(idr\) are method identifiers.
 
 More generally, this rule also holds when
 \(\texttt{Rewriter::rewrite}(\texttt{toOriginal}(F')) = \top\)
 where \(F'\) is the result of the left hand side of the equality above.
 Here, notice that we apply rewriting on the original form of \(F'\),
 meaning that this rule may conclude an \(F\) whose Skolem form is
 justified by the definition of its (fresh) Skolem variables. For example,
 this rule may justify the conclusion \(k = t\) where \(k\) is the
 purification Skolem for \(t\), e.g. where the original form of
 \(k\) is \(t\).
 
 Furthermore, notice that the rewriting and substitution is applied only
 within the side condition, meaning the rewritten form of the original form
 of \(F\) does not escape this rule.</div>
</section>
</li>
<li>
<section class="detail" id="MACRO_SR_PRED_ELIM">
<h3>MACRO_SR_PRED_ELIM</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">MACRO_SR_PRED_ELIM</span></div>
<div class="block">Builtin theory &ndash; Substitution + Rewriting predicate elimination
 
 \[
 
   \inferrule{F, F_1 \dots F_n \mid (ids (ida
   (idr)?)?)?}{\texttt{rewrite}_{idr}(F \circ \sigma_{ids, ida}(F_n) \circ
   \cdots \circ \sigma_{ids, ida}(F_1))}
 \]
 where \(ids\) and \(idr\) are method identifiers.
 
 We rewrite only on the Skolem form of \(F\), similar to
 MACRO_SR_EQ_INTRO &lt;cvc5.<a href="#MACRO_SR_EQ_INTRO"><code>MACRO_SR_EQ_INTRO</code></a>&gt;.</div>
</section>
</li>
<li>
<section class="detail" id="MACRO_SR_PRED_TRANSFORM">
<h3>MACRO_SR_PRED_TRANSFORM</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">MACRO_SR_PRED_TRANSFORM</span></div>
<div class="block">Builtin theory &ndash; Substitution + Rewriting predicate elimination
 
 \[
 
   \inferrule{F, F_1 \dots F_n \mid G, (ids (ida (idr)?)?)?}{G}
 \]
 where
 
 \[
 
   \texttt{rewrite}_{idr}(F \circ \sigma_{ids, ida}(F_n) \circ\cdots \circ \sigma_{ids, ida}(F_1)) =\\ \texttt{rewrite}_{idr}(G \circ \sigma_{ids, ida}(F_n) \circ \cdots \circ \sigma_{ids, ida}(F_1))
 \]
 More generally, this rule also holds when:
 \(\texttt{Rewriter::rewrite}(\texttt{toOriginal}(F')) = \texttt{Rewriter::rewrite}(\texttt{toOriginal}(G'))\)
 where \(F'\) and \(G'\) are the result of each side of the equation
 above. Here, original forms are used in a similar manner to
 MACRO_SR_PRED_INTRO &lt;cvc5.<a href="#MACRO_SR_PRED_INTRO"><code>MACRO_SR_PRED_INTRO</code></a>&gt;
 above.</div>
</section>
</li>
<li>
<section class="detail" id="ENCODE_EQ_INTRO">
<h3>ENCODE_EQ_INTRO</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">ENCODE_EQ_INTRO</span></div>
<div class="block">Builtin theory &ndash; Encode equality introduction
 
 \[
 
   \inferrule{- \mid t}{t=t'}
 \]
 where \(t\) and \(t'\) are equivalent up to their encoding in an
 external proof format.
 
 More specifically, it is the case that
 \(\texttt{RewriteDbNodeConverter::postConvert}(t) = t;\).
 This conversion method for instance may drop user patterns from quantified
 formulas or change the representation of \(t\) in a way that is a
 no-op in external proof formats.
 
 Note this rule can be treated as a
 REFL &lt;cvc5.<a href="#REFL"><code>REFL</code></a>&gt; when appropriate in
 external proof formats.</div>
</section>
</li>
<li>
<section class="detail" id="DSL_REWRITE">
<h3>DSL_REWRITE</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">DSL_REWRITE</span></div>
<div class="block">Builtin theory &ndash; DSL rewrite
 
 \[
 
   \inferrule{F_1 \dots F_n \mid id t_1 \dots t_n}{F}
 \]
 where `id` is a ProofRewriteRule whose definition in the
 RARE DSL is \(\forall x_1 \dots x_n. (G_1 \wedge G_n) \Rightarrow G\)
 where for \(i=1, \dots n\), we have that \(F_i = \sigma(G_i)\)
 and \(F = \sigma(G)\) where \(\sigma\) is the substitution
 \(\{x_1\mapsto t_1,\dots,x_n\mapsto t_n\}\).
 
 Notice that the application of the substitution takes into account the
 possible list semantics of variables \(x_1 \ldots x_n\). If
 \(x_i\) is a variable with list semantics, then \(t_i\) denotes a
 list of terms. The substitution implemented by
 \(\texttt{expr::narySubstitute}\) (for details, see
 :cvc5src:`expr/nary_term_util.h`) which replaces each \(x_i\) with the
 list \(t_i\) in its place.</div>
</section>
</li>
<li>
<section class="detail" id="THEORY_REWRITE">
<h3>THEORY_REWRITE</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">THEORY_REWRITE</span></div>
<div class="block">Other theory rewrite rules
 
 \[
 
   \inferrule{- \mid id, t = t'}{t = t'}
 \]
 where `id` is the ProofRewriteRule of the theory rewrite
 rule which transforms \(t\) to \(t'\).
 
 In contrast to DSL_REWRITE, theory rewrite rules used by
 this proof rule are not necessarily expressible in RARE. Each rule that can
 be used in this proof rule are documented explicitly in cases within the
 ProofRewriteRule enum.</div>
</section>
</li>
<li>
<section class="detail" id="ITE_EQ">
<h3>ITE_EQ</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">ITE_EQ</span></div>
<div class="block">Processing rules &ndash; If-then-else equivalence
 
 \[
 
   \inferrule{- \mid \ite{C}{t_1}{t_2}}{\ite{C}{((\ite{C}{t_1}{t_2}) = t_1)}{((\ite{C}{t_1}{t_2}) = t_2)}}
 \]</div>
</section>
</li>
<li>
<section class="detail" id="TRUST">
<h3>TRUST</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">TRUST</span></div>
<div class="block">Trusted rule
 
 \[
 
   \inferrule{F_1 \dots F_n \mid tid, F, ...}{F}
 \]
 where \(tid\) is an identifier and \(F\) is a formula. This rule
 is used when a formal justification of an inference step cannot be provided.
 The formulas \(F_1 \dots F_n\) refer to a set of formulas that
 entail \(F\), which may or may not be provided.</div>
</section>
</li>
<li>
<section class="detail" id="TRUST_THEORY_REWRITE">
<h3>TRUST_THEORY_REWRITE</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">TRUST_THEORY_REWRITE</span></div>
<div class="block">Trusted rules &ndash; Theory rewrite
 
 \[
 
   \inferrule{- \mid F, tid, rid}{F}
 \]
 where \(F\) is an equality of the form \(t = t'\) where \(t'\)
 is obtained by applying the kind of rewriting given by the method
 identifier \(rid\), which is one of:
 <code>RW_REWRITE_THEORY_PRE</code>, <code>RW_REWRITE_THEORY_POST</code>,
 <code>RW_REWRITE_EQ_EXT</code>. Notice that the checker for this rule does not
 replay the rewrite to ensure correctness, since theory rewriter methods are
 not static. For example, the quantifiers rewriter involves constructing new
 bound variables that are not guaranteed to be consistent on each call.</div>
</section>
</li>
<li>
<section class="detail" id="SAT_REFUTATION">
<h3>SAT_REFUTATION</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">SAT_REFUTATION</span></div>
<div class="block">SAT Refutation for assumption-based unsat cores
 
 \[
 
   \inferrule{F_1 \dots F_n \mid -}{\bot}
 \]
 where \(F_1 \dots F_n\) correspond to the unsat core determined by the
 SAT solver.</div>
</section>
</li>
<li>
<section class="detail" id="DRAT_REFUTATION">
<h3>DRAT_REFUTATION</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">DRAT_REFUTATION</span></div>
<div class="block">DRAT Refutation
 
 \[
 
   \inferrule{F_1 \dots F_n \mid D, P}{\bot}
 \]
 where \(F_1 \dots F_n\) correspond to the clauses in the
 DIMACS file given by filename `D` and `P` is a filename of a file storing
 a DRAT proof.</div>
</section>
</li>
<li>
<section class="detail" id="SAT_EXTERNAL_PROVE">
<h3>SAT_EXTERNAL_PROVE</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">SAT_EXTERNAL_PROVE</span></div>
<div class="block">SAT external prove Refutation
 
 \[
 
   \inferrule{F_1 \dots F_n \mid D}{\bot}
 \]
 where \(F_1 \dots F_n\) correspond to the input clauses in the
 DIMACS file `D`.</div>
</section>
</li>
<li>
<section class="detail" id="RESOLUTION">
<h3>RESOLUTION</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">RESOLUTION</span></div>
<div class="block">Boolean &ndash; Resolution
 
 \[
 
   \inferrule{C_1, C_2 \mid pol, L}{C}
 \]
 where
 
 <ul>
 <li>\(C_1\) and \(C_2\) are nodes viewed as clauses, i.e., either an
   <code>OR</code> node with each children viewed as a literal or a node viewed as a
   literal. Note that an <code>OR</code> node could also be a literal.
 </li>
 <li>\(pol\) is either true or false, representing the polarity of the
   pivot on the first clause
 </li>
 <li>\(L\) is the pivot of the resolution, which occurs as is (resp. under
   a <code>NOT</code>) in \(C_1\) and negatively (as is) in \(C_2\) if
   \(pol = \top\) (\(pol = \bot\)).
 
 </li></ul>
 \(C\) is a clause resulting from collecting all the literals in
 \(C_1\), minus the first occurrence of the pivot or its negation, and
 \(C_2\), minus the first occurrence of the pivot or its negation,
 according to the policy above. If the resulting clause has a single
 literal, that literal itself is the result; if it has no literals, then the
 result is false; otherwise it's an <code>OR</code> node of the resulting literals.
 
 Note that it may be the case that the pivot does not occur in the
 clauses. In this case the rule is not unsound, but it does not correspond
 to resolution but rather to a weakening of the clause that did not have a
 literal eliminated.</div>
</section>
</li>
<li>
<section class="detail" id="CHAIN_RESOLUTION">
<h3>CHAIN_RESOLUTION</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">CHAIN_RESOLUTION</span></div>
<div class="block">Boolean &ndash; N-ary Resolution
 
 \[
 
   \inferrule{C_1 \dots C_n \mid (pol_1 \dots pol_{n-1}), (L_1 \dots L_{n-1})}{C}
 \]
 where
 
 <ul>
 <li>let \(C_1 \dots C_n\) be nodes viewed as clauses, as defined above
 </li>
 <li>let \(C_1 \diamond_{L,pol} C_2\) represent the resolution of
   \(C_1\) with \(C_2\) with pivot \(L\) and polarity
   \(pol\), as defined above
 </li>
 <li>let \(C_1' = C_1\),
 </li>
 <li>for each \(i &gt; 1\), let \(C_i' = C_{i-1} \diamond_{L_{i-1}, pol_{i-1}} C_i'\)
 
 </li></ul>
 Note the list of polarities and pivots are provided as s-expressions.
 
 The result of the chain resolution is \(C = C_n'\)</div>
</section>
</li>
<li>
<section class="detail" id="FACTORING">
<h3>FACTORING</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">FACTORING</span></div>
<div class="block">Boolean &ndash; Factoring
 
 \[
 
   \inferrule{C_1 \mid -}{C_2}
 \]
 where \(C_2\) is the clause \(C_1\), but every occurrence of a literal
 after its first occurrence is omitted.</div>
</section>
</li>
<li>
<section class="detail" id="REORDERING">
<h3>REORDERING</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">REORDERING</span></div>
<div class="block">Boolean &ndash; Reordering
 
 \[
 
   \inferrule{C_1 \mid C_2}{C_2}
 \]
 where
 the multiset representations of \(C_1\) and \(C_2\) are the same.</div>
</section>
</li>
<li>
<section class="detail" id="MACRO_RESOLUTION">
<h3>MACRO_RESOLUTION</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">MACRO_RESOLUTION</span></div>
<div class="block">Boolean &ndash; N-ary Resolution + Factoring + Reordering
 
 \[
 
   \inferrule{C_1 \dots C_n \mid C, pol_1,L_1 \dots pol_{n-1},L_{n-1}}{C}
 \]
 where
 
 <ul>
 <li>let \(C_1 \dots C_n\) be nodes viewed as clauses, as defined in
   RESOLUTION &lt;cvc5.<a href="#RESOLUTION"><code>RESOLUTION</code></a>&gt;
 </li>
 <li>let \(C_1 \diamond_{L,\mathit{pol}} C_2\) represent the resolution of
   \(C_1\) with \(C_2\) with pivot \(L\) and polarity
   \(pol\), as defined in
   RESOLUTION &lt;cvc5.<a href="#RESOLUTION"><code>RESOLUTION</code></a>&gt;
 </li>
 <li>let \(C_1'\) be equal, in its set representation, to \(C_1\),
 </li>
 <li>for each \(i &gt; 1\), let \(C_i'\) be equal, in its set
   representation, to \(C_{i-1} \diamond_{L_{i-1},\mathit{pol}_{i-1}}
   C_i'\)
 
 </li></ul>
 The result of the chain resolution is \(C\), which is equal, in its set
 representation, to \(C_n'\)</div>
</section>
</li>
<li>
<section class="detail" id="MACRO_RESOLUTION_TRUST">
<h3>MACRO_RESOLUTION_TRUST</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">MACRO_RESOLUTION_TRUST</span></div>
<div class="block">Boolean &ndash; N-ary Resolution + Factoring + Reordering unchecked
 
 Same as
 MACRO_RESOLUTION &lt;cvc5.<a href="#MACRO_RESOLUTION"><code>MACRO_RESOLUTION</code></a>&gt;, but
 not checked by the internal proof checker.</div>
</section>
</li>
<li>
<section class="detail" id="CHAIN_M_RESOLUTION">
<h3>CHAIN_M_RESOLUTION</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">CHAIN_M_RESOLUTION</span></div>
<div class="block">Boolean &ndash; Chain multiset resolution
 
 This rule combines Resolution + Factoring + Reordering.
 
 \[
   \inferrule{C_1 \dots C_n \mid C, (pol_1 \dots pol_{n-1}), (L_1 \dots L_{n-1})}{C}
 \]
 where
 
 <ul>
 <li>let \(C_1 \dots C_n\) be nodes viewed as clauses, as defined in
   RESOLUTION &lt;cvc5.<a href="#RESOLUTION"><code>RESOLUTION</code></a>&gt;
 </li>
 <li>let \(C_1 \diamond_{L,\mathit{pol}} C_2\) represent the resolution of
   \(C_1\) with \(C_2\) with pivot \(L\) and polarity
   \(pol\), as defined in
   RESOLUTION &lt;cvc5.<a href="#RESOLUTION"><code>RESOLUTION</code></a>&gt;
 </li>
 <li>let \(C_1'\) be equal, in its set representation, to \(C_1\),
 </li>
 <li>for each \(i &gt; 1\), let \(C_i'\) be equal, in its set
   representation, to \(C_{i-1} \diamond_{L_{i-1},\mathit{pol}_{i-1}}
   C_i'\)
 
 </li></ul>
 The result of the chain resolution is \(C\), which is equal, in its set
 representation, to \(C_n'\).</div>
</section>
</li>
<li>
<section class="detail" id="SPLIT">
<h3>SPLIT</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">SPLIT</span></div>
<div class="block">Boolean &ndash; Split
 
 \[
 
   \inferrule{- \mid F}{F \lor \neg F}
 \]</div>
</section>
</li>
<li>
<section class="detail" id="EQ_RESOLVE">
<h3>EQ_RESOLVE</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">EQ_RESOLVE</span></div>
<div class="block">Boolean &ndash; Equality resolution
 
 \[
 
   \inferrule{F_1, (F_1 = F_2) \mid -}{F_2}
 \]
 Note this can optionally be seen as a macro for
 EQUIV_ELIM1 &lt;cvc5.<a href="#EQUIV_ELIM1"><code>EQUIV_ELIM1</code></a>&gt; +
 RESOLUTION &lt;cvc5.<a href="#RESOLUTION"><code>RESOLUTION</code></a>&gt;.</div>
</section>
</li>
<li>
<section class="detail" id="MODUS_PONENS">
<h3>MODUS_PONENS</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">MODUS_PONENS</span></div>
<div class="block">Boolean &ndash; Modus Ponens
 
 \[
 
   \inferrule{F_1, (F_1 \rightarrow F_2) \mid -}{F_2}
 \]
 Note this can optionally be seen as a macro for
 IMPLIES_ELIM &lt;cvc5.<a href="#IMPLIES_ELIM"><code>IMPLIES_ELIM</code></a>&gt; +
 RESOLUTION &lt;cvc5.<a href="#RESOLUTION"><code>RESOLUTION</code></a>&gt;.</div>
</section>
</li>
<li>
<section class="detail" id="NOT_NOT_ELIM">
<h3>NOT_NOT_ELIM</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">NOT_NOT_ELIM</span></div>
<div class="block">Boolean &ndash; Double negation elimination
 
 \[
 
   \inferrule{\neg (\neg F) \mid -}{F}
 \]</div>
</section>
</li>
<li>
<section class="detail" id="CONTRA">
<h3>CONTRA</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">CONTRA</span></div>
<div class="block">Boolean &ndash; Contradiction
 
 \[
 
   \inferrule{F, \neg F \mid -}{\bot}
 \]</div>
</section>
</li>
<li>
<section class="detail" id="AND_ELIM">
<h3>AND_ELIM</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">AND_ELIM</span></div>
<div class="block">Boolean &ndash; And elimination
 
 \[
 
   \inferrule{(F_1 \land \dots \land F_n) \mid i}{F_i}
 \]</div>
</section>
</li>
<li>
<section class="detail" id="AND_INTRO">
<h3>AND_INTRO</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">AND_INTRO</span></div>
<div class="block">Boolean &ndash; And introduction
 
 \[
 
   \inferrule{F_1 \dots F_n \mid -}{(F_1 \land \dots \land F_n)}
 \]</div>
</section>
</li>
<li>
<section class="detail" id="NOT_OR_ELIM">
<h3>NOT_OR_ELIM</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">NOT_OR_ELIM</span></div>
<div class="block">Boolean &ndash; Not Or elimination
 
 \[
 
   \inferrule{\neg(F_1 \lor \dots \lor F_n) \mid i}{\neg F_i}
 \]</div>
</section>
</li>
<li>
<section class="detail" id="IMPLIES_ELIM">
<h3>IMPLIES_ELIM</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">IMPLIES_ELIM</span></div>
<div class="block">Boolean &ndash; Implication elimination
 
 \[
 
   \inferrule{F_1 \rightarrow F_2 \mid -}{\neg F_1 \lor F_2}
 \]</div>
</section>
</li>
<li>
<section class="detail" id="NOT_IMPLIES_ELIM1">
<h3>NOT_IMPLIES_ELIM1</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">NOT_IMPLIES_ELIM1</span></div>
<div class="block">Boolean &ndash; Not Implication elimination version 1
 
 \[
 
   \inferrule{\neg(F_1 \rightarrow F_2) \mid -}{F_1}
 \]</div>
</section>
</li>
<li>
<section class="detail" id="NOT_IMPLIES_ELIM2">
<h3>NOT_IMPLIES_ELIM2</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">NOT_IMPLIES_ELIM2</span></div>
<div class="block">Boolean &ndash; Not Implication elimination version 2
 
 \[
 
   \inferrule{\neg(F_1 \rightarrow F_2) \mid -}{\neg F_2}
 \]</div>
</section>
</li>
<li>
<section class="detail" id="EQUIV_ELIM1">
<h3>EQUIV_ELIM1</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">EQUIV_ELIM1</span></div>
<div class="block">Boolean &ndash; Equivalence elimination version 1
 
 \[
 
   \inferrule{F_1 = F_2 \mid -}{\neg F_1 \lor F_2}
 \]</div>
</section>
</li>
<li>
<section class="detail" id="EQUIV_ELIM2">
<h3>EQUIV_ELIM2</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">EQUIV_ELIM2</span></div>
<div class="block">Boolean &ndash; Equivalence elimination version 2
 
 \[
 
   \inferrule{F_1 = F_2 \mid -}{F_1 \lor \neg F_2}
 \]</div>
</section>
</li>
<li>
<section class="detail" id="NOT_EQUIV_ELIM1">
<h3>NOT_EQUIV_ELIM1</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">NOT_EQUIV_ELIM1</span></div>
<div class="block">Boolean &ndash; Not Equivalence elimination version 1
 
 \[
 
   \inferrule{F_1 \neq F_2 \mid -}{F_1 \lor F_2}
 \]</div>
</section>
</li>
<li>
<section class="detail" id="NOT_EQUIV_ELIM2">
<h3>NOT_EQUIV_ELIM2</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">NOT_EQUIV_ELIM2</span></div>
<div class="block">Boolean &ndash; Not Equivalence elimination version 2
 
 \[
 
   \inferrule{F_1 \neq F_2 \mid -}{\neg F_1 \lor \neg F_2}
 \]</div>
</section>
</li>
<li>
<section class="detail" id="XOR_ELIM1">
<h3>XOR_ELIM1</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">XOR_ELIM1</span></div>
<div class="block">Boolean &ndash; XOR elimination version 1
 
 \[
 
   \inferrule{F_1 \xor F_2 \mid -}{F_1 \lor F_2}
 \]</div>
</section>
</li>
<li>
<section class="detail" id="XOR_ELIM2">
<h3>XOR_ELIM2</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">XOR_ELIM2</span></div>
<div class="block">Boolean &ndash; XOR elimination version 2
 
 \[
 
   \inferrule{F_1 \xor F_2 \mid -}{\neg F_1 \lor \neg F_2}
 \]</div>
</section>
</li>
<li>
<section class="detail" id="NOT_XOR_ELIM1">
<h3>NOT_XOR_ELIM1</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">NOT_XOR_ELIM1</span></div>
<div class="block">Boolean &ndash; Not XOR elimination version 1
 
 \[
 
   \inferrule{\neg(F_1 \xor F_2) \mid -}{F_1 \lor \neg F_2}
 \]</div>
</section>
</li>
<li>
<section class="detail" id="NOT_XOR_ELIM2">
<h3>NOT_XOR_ELIM2</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">NOT_XOR_ELIM2</span></div>
<div class="block">Boolean &ndash; Not XOR elimination version 2
 
 \[
 
   \inferrule{\neg(F_1 \xor F_2) \mid -}{\neg F_1 \lor F_2}
 \]</div>
</section>
</li>
<li>
<section class="detail" id="ITE_ELIM1">
<h3>ITE_ELIM1</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">ITE_ELIM1</span></div>
<div class="block">Boolean &ndash; ITE elimination version 1
 
 \[
 
   \inferrule{(\ite{C}{F_1}{F_2}) \mid -}{\neg C \lor F_1}
 \]</div>
</section>
</li>
<li>
<section class="detail" id="ITE_ELIM2">
<h3>ITE_ELIM2</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">ITE_ELIM2</span></div>
<div class="block">Boolean &ndash; ITE elimination version 2
 
 \[
 
   \inferrule{(\ite{C}{F_1}{F_2}) \mid -}{C \lor F_2}
 \]</div>
</section>
</li>
<li>
<section class="detail" id="NOT_ITE_ELIM1">
<h3>NOT_ITE_ELIM1</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">NOT_ITE_ELIM1</span></div>
<div class="block">Boolean &ndash; Not ITE elimination version 1
 
 \[
 
   \inferrule{\neg(\ite{C}{F_1}{F_2}) \mid -}{\neg C \lor \neg F_1}
 \]</div>
</section>
</li>
<li>
<section class="detail" id="NOT_ITE_ELIM2">
<h3>NOT_ITE_ELIM2</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">NOT_ITE_ELIM2</span></div>
<div class="block">Boolean &ndash; Not ITE elimination version 2
 
 \[
 
   \inferrule{\neg(\ite{C}{F_1}{F_2}) \mid -}{C \lor \neg F_2}
 \]</div>
</section>
</li>
<li>
<section class="detail" id="NOT_AND">
<h3>NOT_AND</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">NOT_AND</span></div>
<div class="block">Boolean &ndash; De Morgan &ndash; Not And
 
 \[
 
   \inferrule{\neg(F_1 \land \dots \land F_n) \mid -}{\neg F_1 \lor \dots
   \lor \neg F_n}
 \]</div>
</section>
</li>
<li>
<section class="detail" id="CNF_AND_POS">
<h3>CNF_AND_POS</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">CNF_AND_POS</span></div>
<div class="block">Boolean &ndash; CNF &ndash; And Positive
 
 \[
 
   \inferrule{- \mid (F_1 \land \dots \land F_n), i}{\neg (F_1 \land \dots
   \land F_n) \lor F_i}
 \]</div>
</section>
</li>
<li>
<section class="detail" id="CNF_AND_NEG">
<h3>CNF_AND_NEG</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">CNF_AND_NEG</span></div>
<div class="block">Boolean &ndash; CNF &ndash; And Negative
 
 \[
 
   \inferrule{- \mid (F_1 \land \dots \land F_n)}{(F_1 \land \dots \land
   F_n) \lor \neg F_1 \lor \dots \lor \neg F_n}
 \]</div>
</section>
</li>
<li>
<section class="detail" id="CNF_OR_POS">
<h3>CNF_OR_POS</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">CNF_OR_POS</span></div>
<div class="block">Boolean &ndash; CNF &ndash; Or Positive
 
 \[
 
   \inferrule{- \mid (F_1 \lor \dots \lor F_n)}{\neg(F_1 \lor \dots \lor
   F_n) \lor F_1 \lor \dots \lor F_n}
 \]</div>
</section>
</li>
<li>
<section class="detail" id="CNF_OR_NEG">
<h3>CNF_OR_NEG</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">CNF_OR_NEG</span></div>
<div class="block">Boolean &ndash; CNF &ndash; Or Negative
 
 \[
 
   \inferrule{- \mid (F_1 \lor \dots \lor F_n), i}{(F_1 \lor \dots \lor F_n)
   \lor \neg F_i}
 \]</div>
</section>
</li>
<li>
<section class="detail" id="CNF_IMPLIES_POS">
<h3>CNF_IMPLIES_POS</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">CNF_IMPLIES_POS</span></div>
<div class="block">Boolean &ndash; CNF &ndash; Implies Positive
 
 \[
 
   \inferrule{- \mid F_1 \rightarrow F_2}{\neg(F_1 \rightarrow F_2) \lor \neg F_1
   \lor F_2}
 \]</div>
</section>
</li>
<li>
<section class="detail" id="CNF_IMPLIES_NEG1">
<h3>CNF_IMPLIES_NEG1</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">CNF_IMPLIES_NEG1</span></div>
<div class="block">Boolean &ndash; CNF &ndash; Implies Negative 1
 
 \[
 
   \inferrule{- \mid F_1 \rightarrow F_2}{(F_1 \rightarrow F_2) \lor F_1}
 \]</div>
</section>
</li>
<li>
<section class="detail" id="CNF_IMPLIES_NEG2">
<h3>CNF_IMPLIES_NEG2</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">CNF_IMPLIES_NEG2</span></div>
<div class="block">Boolean &ndash; CNF &ndash; Implies Negative 2
 
 \[
 
   \inferrule{- \mid F_1 \rightarrow F_2}{(F_1 \rightarrow F_2) \lor \neg F_2}
 \]</div>
</section>
</li>
<li>
<section class="detail" id="CNF_EQUIV_POS1">
<h3>CNF_EQUIV_POS1</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">CNF_EQUIV_POS1</span></div>
<div class="block">Boolean &ndash; CNF &ndash; Equiv Positive 1
 
 \[
 
   \inferrule{- \mid F_1 = F_2}{F_1 \neq F_2 \lor \neg F_1 \lor F_2}
 \]</div>
</section>
</li>
<li>
<section class="detail" id="CNF_EQUIV_POS2">
<h3>CNF_EQUIV_POS2</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">CNF_EQUIV_POS2</span></div>
<div class="block">Boolean &ndash; CNF &ndash; Equiv Positive 2
 
 \[
 
   \inferrule{- \mid F_1 = F_2}{F_1 \neq F_2 \lor F_1 \lor \neg F_2}
 \]</div>
</section>
</li>
<li>
<section class="detail" id="CNF_EQUIV_NEG1">
<h3>CNF_EQUIV_NEG1</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">CNF_EQUIV_NEG1</span></div>
<div class="block">Boolean &ndash; CNF &ndash; Equiv Negative 1
 
 \[
 
   \inferrule{- \mid F_1 = F_2}{(F_1 = F_2) \lor F_1 \lor F_2}
 \]</div>
</section>
</li>
<li>
<section class="detail" id="CNF_EQUIV_NEG2">
<h3>CNF_EQUIV_NEG2</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">CNF_EQUIV_NEG2</span></div>
<div class="block">Boolean &ndash; CNF &ndash; Equiv Negative 2
 
 \[
 
   \inferrule{- \mid F_1 = F_2}{(F_1 = F_2) \lor \neg F_1 \lor \neg F_2}
 \]</div>
</section>
</li>
<li>
<section class="detail" id="CNF_XOR_POS1">
<h3>CNF_XOR_POS1</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">CNF_XOR_POS1</span></div>
<div class="block">Boolean &ndash; CNF &ndash; XOR Positive 1
 
 \[
 
   \inferrule{- \mid F_1 \xor F_2}{\neg(F_1 \xor F_2) \lor F_1 \lor F_2}
 \]</div>
</section>
</li>
<li>
<section class="detail" id="CNF_XOR_POS2">
<h3>CNF_XOR_POS2</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">CNF_XOR_POS2</span></div>
<div class="block">Boolean &ndash; CNF &ndash; XOR Positive 2
 
 \[
 
   \inferrule{- \mid F_1 \xor F_2}{\neg(F_1 \xor F_2) \lor \neg F_1 \lor
   \neg F_2}
 \]</div>
</section>
</li>
<li>
<section class="detail" id="CNF_XOR_NEG1">
<h3>CNF_XOR_NEG1</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">CNF_XOR_NEG1</span></div>
<div class="block">Boolean &ndash; CNF &ndash; XOR Negative 1
 
 \[
 
   \inferrule{- \mid F_1 \xor F_2}{(F_1 \xor F_2) \lor \neg F_1 \lor F_2}
 \]</div>
</section>
</li>
<li>
<section class="detail" id="CNF_XOR_NEG2">
<h3>CNF_XOR_NEG2</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">CNF_XOR_NEG2</span></div>
<div class="block">Boolean &ndash; CNF &ndash; XOR Negative 2
 
 \[
 
   \inferrule{- \mid F_1 \xor F_2}{(F_1 \xor F_2) \lor F_1 \lor \neg F_2}
 \]</div>
</section>
</li>
<li>
<section class="detail" id="CNF_ITE_POS1">
<h3>CNF_ITE_POS1</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">CNF_ITE_POS1</span></div>
<div class="block">Boolean &ndash; CNF &ndash; ITE Positive 1
 
 \[
 
   \inferrule{- \mid (\ite{C}{F_1}{F_2})}{\neg(\ite{C}{F_1}{F_2}) \lor \neg
   C \lor F_1}
 \]</div>
</section>
</li>
<li>
<section class="detail" id="CNF_ITE_POS2">
<h3>CNF_ITE_POS2</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">CNF_ITE_POS2</span></div>
<div class="block">Boolean &ndash; CNF &ndash; ITE Positive 2
 
 \[
 
   \inferrule{- \mid (\ite{C}{F_1}{F_2})}{\neg(\ite{C}{F_1}{F_2}) \lor C
   \lor F_2}
 \]</div>
</section>
</li>
<li>
<section class="detail" id="CNF_ITE_POS3">
<h3>CNF_ITE_POS3</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">CNF_ITE_POS3</span></div>
<div class="block">Boolean &ndash; CNF &ndash; ITE Positive 3
 
 \[
 
   \inferrule{- \mid (\ite{C}{F_1}{F_2})}{\neg(\ite{C}{F_1}{F_2}) \lor F_1
   \lor F_2}
 \]</div>
</section>
</li>
<li>
<section class="detail" id="CNF_ITE_NEG1">
<h3>CNF_ITE_NEG1</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">CNF_ITE_NEG1</span></div>
<div class="block">Boolean &ndash; CNF &ndash; ITE Negative 1
 
 \[
 
   \inferrule{- \mid (\ite{C}{F_1}{F_2})}{(\ite{C}{F_1}{F_2}) \lor \neg C
   \lor \neg F_1}
 \]</div>
</section>
</li>
<li>
<section class="detail" id="CNF_ITE_NEG2">
<h3>CNF_ITE_NEG2</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">CNF_ITE_NEG2</span></div>
<div class="block">Boolean &ndash; CNF &ndash; ITE Negative 2
 
 \[
 
   \inferrule{- \mid (\ite{C}{F_1}{F_2})}{(\ite{C}{F_1}{F_2}) \lor C \lor
   \neg F_2}
 \]</div>
</section>
</li>
<li>
<section class="detail" id="CNF_ITE_NEG3">
<h3>CNF_ITE_NEG3</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">CNF_ITE_NEG3</span></div>
<div class="block">Boolean &ndash; CNF &ndash; ITE Negative 3
 
 \[
 
   \inferrule{- \mid (\ite{C}{F_1}{F_2})}{(\ite{C}{F_1}{F_2}) \lor \neg F_1
   \lor \neg F_2}
 \]</div>
</section>
</li>
<li>
<section class="detail" id="REFL">
<h3>REFL</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">REFL</span></div>
<div class="block">Equality &ndash; Reflexivity
 
 \[
 
   \inferrule{-\mid t}{t = t}
 \]</div>
</section>
</li>
<li>
<section class="detail" id="SYMM">
<h3>SYMM</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">SYMM</span></div>
<div class="block">Equality &ndash; Symmetry
 
 \[
 
   \inferrule{t_1 = t_2\mid -}{t_2 = t_1}
 \]
 or
 
 \[
 
   \inferrule{t_1 \neq t_2\mid -}{t_2 \neq t_1}
 \]</div>
</section>
</li>
<li>
<section class="detail" id="TRANS">
<h3>TRANS</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">TRANS</span></div>
<div class="block">Equality &ndash; Transitivity
 
 \[
 
   \inferrule{t_1=t_2,\dots,t_{n-1}=t_n\mid -}{t_1 = t_n}
 \]</div>
</section>
</li>
<li>
<section class="detail" id="CONG">
<h3>CONG</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">CONG</span></div>
<div class="block">Equality &ndash; Congruence
 
 \[
 
   \inferrule{t_1=s_1,\dots,t_n=s_n\mid f(t_1,\dots, t_n)}{f(t_1,\dots, t_n) = f(s_1,\dots, s_n)}
 \]
 This rule is used when the kind of \(f(t_1,\dots, t_n)\) has a fixed
 arity. This includes kinds such as <code>cvc5.Kind.ITE</code>,
 <code>cvc5.Kind.EQUAL</code>, as well as indexed functions such as
 <code>cvc5.Kind.BITVECTOR_EXTRACT</code>.
 
 It is also used for <code>cvc5.Kind.APPLY_UF</code>, where \(f\) is an
 uninterpreted function.
 
 It is not used for kinds with variadic arity, or for kind
 <code>cvc5.Kind.HO_APPLY</code>, which respectively use the rules
 NARY_CONG &lt;cvc5.<a href="#NARY_CONG"><code>NARY_CONG</code></a>&gt; and
 HO_CONG &lt;cvc5.<a href="#HO_CONG"><code>HO_CONG</code></a>&gt; below.</div>
</section>
</li>
<li>
<section class="detail" id="NARY_CONG">
<h3>NARY_CONG</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">NARY_CONG</span></div>
<div class="block">Equality &ndash; N-ary Congruence
 
 \[
 
   \inferrule{t_1=s_1,\dots,t_n=s_n\mid f(t_1,\dots, t_n)}{f(t_1,\dots, t_n) = f(s_1,\dots, s_n)}
 \]
 This rule is used for terms \(f(t_1,\dots, t_n)\) whose kinds
 \(k\) have variadic arity, such as <code>cvc5.Kind.AND</code>,
 <code>cvc5.Kind.PLUS</code> and so on.</div>
</section>
</li>
<li>
<section class="detail" id="TRUE_INTRO">
<h3>TRUE_INTRO</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">TRUE_INTRO</span></div>
<div class="block">Equality &ndash; True intro
 
 \[
 
   \inferrule{F\mid -}{F = \top}
 \]</div>
</section>
</li>
<li>
<section class="detail" id="TRUE_ELIM">
<h3>TRUE_ELIM</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">TRUE_ELIM</span></div>
<div class="block">Equality &ndash; True elim
 
 \[
 
   \inferrule{F=\top\mid -}{F}
 \]</div>
</section>
</li>
<li>
<section class="detail" id="FALSE_INTRO">
<h3>FALSE_INTRO</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">FALSE_INTRO</span></div>
<div class="block">Equality &ndash; False intro
 
 \[
 
   \inferrule{\neg F\mid -}{F = \bot}
 \]</div>
</section>
</li>
<li>
<section class="detail" id="FALSE_ELIM">
<h3>FALSE_ELIM</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">FALSE_ELIM</span></div>
<div class="block">Equality &ndash; False elim
 
 \[
 
   \inferrule{F=\bot\mid -}{\neg F}
 \]</div>
</section>
</li>
<li>
<section class="detail" id="HO_APP_ENCODE">
<h3>HO_APP_ENCODE</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">HO_APP_ENCODE</span></div>
<div class="block">Equality &ndash; Higher-order application encoding
 
 \[
 
   \inferrule{-\mid t}{t=t'}
 \]
 where `t'` is the higher-order application that is equivalent to `t`,
 as implemented by <code>uf.TheoryUfRewriter.getHoApplyForApplyUf</code>.
 For details see :cvc5src:`theory/uf/theory_uf_rewriter.h`
 
 For example, this rule concludes \(f(x,y) = @( @(f,x), y)\), where
 \(@\) is the <code>HO_APPLY</code> kind.
 
 Note this rule can be treated as a
 REFL &lt;cvc5.<a href="#REFL"><code>REFL</code></a>&gt; when appropriate in
 external proof formats.</div>
</section>
</li>
<li>
<section class="detail" id="HO_CONG">
<h3>HO_CONG</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">HO_CONG</span></div>
<div class="block">Equality &ndash; Higher-order congruence
 
 \[
 
   \inferrule{f=g, t_1=s_1,\dots,t_n=s_n\mid k}{k(f, t_1,\dots, t_n) =
   k(g, s_1,\dots, s_n)}
 \]
 Notice that this rule is only used when the application kind \(k\) is
 either `cvc5.Kind.APPLY_UF` or `cvc5.Kind.HO_APPLY`.</div>
</section>
</li>
<li>
<section class="detail" id="ARRAYS_READ_OVER_WRITE">
<h3>ARRAYS_READ_OVER_WRITE</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">ARRAYS_READ_OVER_WRITE</span></div>
<div class="block">Arrays &ndash; Read over write
 
 \[
 
   \inferrule{i_1 \neq i_2\mid \mathit{select}(\mathit{store}(a,i_1,e),i_2)}
   {\mathit{select}(\mathit{store}(a,i_1,e),i_2) = \mathit{select}(a,i_2)}
 \]</div>
</section>
</li>
<li>
<section class="detail" id="ARRAYS_READ_OVER_WRITE_CONTRA">
<h3>ARRAYS_READ_OVER_WRITE_CONTRA</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">ARRAYS_READ_OVER_WRITE_CONTRA</span></div>
<div class="block">Arrays &ndash; Read over write, contrapositive
 
 \[
 
   \inferrule{\mathit{select}(\mathit{store}(a,i_2,e),i_1) \neq
   \mathit{select}(a,i_1)\mid -}{i_1=i_2}
 \]</div>
</section>
</li>
<li>
<section class="detail" id="ARRAYS_READ_OVER_WRITE_1">
<h3>ARRAYS_READ_OVER_WRITE_1</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">ARRAYS_READ_OVER_WRITE_1</span></div>
<div class="block">Arrays &ndash; Read over write 1
 
 \[
 
   \inferrule{-\mid \mathit{select}(\mathit{store}(a,i,e),i)}
   {\mathit{select}(\mathit{store}(a,i,e),i)=e}
 \]</div>
</section>
</li>
<li>
<section class="detail" id="ARRAYS_EXT">
<h3>ARRAYS_EXT</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">ARRAYS_EXT</span></div>
<div class="block">Arrays &ndash; Arrays extensionality
 
 \[
 
   \inferrule{a \neq b\mid -}
   {\mathit{select}(a,k)\neq\mathit{select}(b,k)}
 \]
 where \(k\) is the \(\texttt{ARRAY_DEQ_DIFF}\) skolem for `(a, b)`.</div>
</section>
</li>
<li>
<section class="detail" id="MACRO_BV_BITBLAST">
<h3>MACRO_BV_BITBLAST</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">MACRO_BV_BITBLAST</span></div>
<div class="block">Bit-vectors &ndash; (Macro) Bitblast
 
 \[
 
   \inferrule{-\mid t}{t = \texttt{bitblast}(t)}
 \]
 where \(\texttt{bitblast}\) represents the result of the bit-blasted term as
 a bit-vector consisting of the output bits of the bit-blasted circuit
 representation of the term. Terms are bit-blasted according to the
 strategies defined in :cvc5src:`theory/bv/bitblast/bitblast_strategies_template.h`.</div>
</section>
</li>
<li>
<section class="detail" id="BV_BITBLAST_STEP">
<h3>BV_BITBLAST_STEP</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">BV_BITBLAST_STEP</span></div>
<div class="block">Bit-vectors &ndash; Bitblast bit-vector constant, variable, and terms
 
 For constant and variables:
 
 \[
 
   \inferrule{-\mid t}{t = \texttt{bitblast}(t)}
 \]
 For terms:
 
 \[
 
   \inferrule{-\mid k(\texttt{bitblast}(t_1),\dots,\texttt{bitblast}(t_n))}
   {k(\texttt{bitblast}(t_1),\dots,\texttt{bitblast}(t_n)) =
   \texttt{bitblast}(t)}
 \]
 where \(t\) is \(k(t_1,\dots,t_n)\).</div>
</section>
</li>
<li>
<section class="detail" id="BV_EAGER_ATOM">
<h3>BV_EAGER_ATOM</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">BV_EAGER_ATOM</span></div>
<div class="block">Bit-vectors &ndash; Bit-vector eager atom
 
 \[
 
   \inferrule{-\mid F}{F = F[0]}
 \]
 where \(F\) is of kind <code>BITVECTOR_EAGER_ATOM</code>.</div>
</section>
</li>
<li>
<section class="detail" id="BV_POLY_NORM">
<h3>BV_POLY_NORM</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">BV_POLY_NORM</span></div>
<div class="block">Bit-vectors &ndash; Polynomial normalization
 
 \[
 
   \inferrule{- \mid t = s}{t = s}
 \]
 where \(\texttt{arith::PolyNorm::isArithPolyNorm(t, s)} = \top\). This
 method normalizes polynomials \(s\) and \(t\) over bitvectors.</div>
</section>
</li>
<li>
<section class="detail" id="BV_POLY_NORM_EQ">
<h3>BV_POLY_NORM_EQ</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">BV_POLY_NORM_EQ</span></div>
<div class="block">Bit-vectors &ndash; Polynomial normalization for relations
 
 .. math.
 
  \inferrule{c_x \cdot (x_1 - x_2) = c_y \cdot (y_1 - y_2) \mid (x_1 = x_2) = (y_1 = y_2)}
            {(x_1 = x_2) = (y_1 = y_2)}
 
 \(c_x\) and \(c_y\) are scaling factors, currently required to
 be one.</div>
</section>
</li>
<li>
<section class="detail" id="DT_SPLIT">
<h3>DT_SPLIT</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">DT_SPLIT</span></div>
<div class="block">Datatypes &ndash; Split
 
 \[
 
   \inferrule{-\mid t}{\mathit{is}_{C_1}(t)\vee\cdots\vee\mathit{is}_{C_n}(t)}
 \]
 where \(C_1,\dots,C_n\) are all the constructors of the type of \(t\).</div>
</section>
</li>
<li>
<section class="detail" id="SKOLEM_INTRO">
<h3>SKOLEM_INTRO</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">SKOLEM_INTRO</span></div>
<div class="block">Quantifiers &ndash; Skolem introduction
 
 \[
 
   \inferrule{-\mid k}{k = t}
 \]
 where \(t\) is the unpurified form of skolem \(k\).</div>
</section>
</li>
<li>
<section class="detail" id="SKOLEMIZE">
<h3>SKOLEMIZE</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">SKOLEMIZE</span></div>
<div class="block">Quantifiers &ndash; Skolemization
 
 \[
 
   \inferrule{\neg (\forall x_1\dots x_n.\&gt; F)\mid -}{\neg F\sigma}
 \]
 where \(\sigma\) maps \(x_1,\dots,x_n\) to their representative
 skolems, which are skolems \(k_1,\dots,k_n\). For each \(k_i\),
 its skolem identifier is
 QUANTIFIERS_SKOLEMIZE &lt;cvc5.<a href="SkolemId.html#QUANTIFIERS_SKOLEMIZE"><code>SkolemId.QUANTIFIERS_SKOLEMIZE</code></a>&gt;,
 and its indices are \((\forall x_1\dots x_n.\&gt; F)\) and \(x_i\).</div>
</section>
</li>
<li>
<section class="detail" id="INSTANTIATE">
<h3>INSTANTIATE</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">INSTANTIATE</span></div>
<div class="block">Quantifiers &ndash; Instantiation
 
 \[
 
   \inferrule{\forall x_1\dots x_n.\&gt; F\mid (t_1 \dots t_n), (id\, (t)?)?}
   {F\{x_1\mapsto t_1,\dots,x_n\mapsto t_n\}}
 \]
 The list of terms to instantiate \((t_1 \dots t_n)\) is provided as
 an s-expression as the first argument. The optional argument \(id\)
 indicates the inference id that caused the instantiation. The term
 \(t\) indicates an additional term (e.g. the trigger) associated with
 the instantiation, which depends on the id. If the id has prefix
 <code>QUANTIFIERS_INST_E_MATCHING</code>, then \(t\) is the trigger that
 generated the instantiation.</div>
</section>
</li>
<li>
<section class="detail" id="ALPHA_EQUIV">
<h3>ALPHA_EQUIV</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">ALPHA_EQUIV</span></div>
<div class="block">Quantifiers &ndash; Alpha equivalence
 
 \[
 
   \inferruleSC{-\mid F, (y_1 \ldots y_n), (z_1,\dots, z_n)}
   {F = F\{y_1\mapsto z_1,\dots,y_n\mapsto z_n\}}
   {if $y_1,\dots,y_n, z_1,\dots,z_n$ are unique bound variables}
 \]
 Notice that this rule is correct only when \(z_1,\dots,z_n\) are not
 contained in \(FV(F) \setminus \{ y_1,\dots, y_n \}\), where
 \(FV(F)\) are the free variables of \(F\). The internal
 quantifiers proof checker does not currently check that this is the case.</div>
</section>
</li>
<li>
<section class="detail" id="QUANT_VAR_REORDERING">
<h3>QUANT_VAR_REORDERING</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">QUANT_VAR_REORDERING</span></div>
<div class="block">Quantifiers &ndash; Variable reordering
 
 \[
 
   \inferrule{-\mid (\forall X.\&gt; F) = (\forall Y.\&gt; F)}
   {(\forall X.\&gt; F) = (\forall Y.\&gt; F)}
 \]
 where \(Y\) is a reordering of \(X\).</div>
</section>
</li>
<li>
<section class="detail" id="EXISTS_STRING_LENGTH">
<h3>EXISTS_STRING_LENGTH</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">EXISTS_STRING_LENGTH</span></div>
<div class="block">Quantifiers &ndash; Exists string length
 
 \[
 
   \inferrule{-\mid T n i} {\mathit{len}(k) = n}
 \]
 where \(k\) is a skolem of string or sequence type \(T\) and
 \(n\) is a non-negative integer. The argument \(i\) is an
 identifier for \(k\). These three arguments are the indices of
 \(k\), whose skolem identifier is
 WITNESS_STRING_LENGTH &lt;cvc5.<a href="SkolemId.html#WITNESS_STRING_LENGTH"><code>SkolemId.WITNESS_STRING_LENGTH</code></a>&gt;.</div>
</section>
</li>
<li>
<section class="detail" id="SETS_SINGLETON_INJ">
<h3>SETS_SINGLETON_INJ</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">SETS_SINGLETON_INJ</span></div>
<div class="block">Sets &ndash; Singleton injectivity
 
 \[
 
   \inferrule{\mathit{set.singleton}(t) = \mathit{set.singleton}(s)\mid -}{t=s}
 \]</div>
</section>
</li>
<li>
<section class="detail" id="SETS_EXT">
<h3>SETS_EXT</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">SETS_EXT</span></div>
<div class="block">Sets &ndash; Sets extensionality
 
 \[
 
   \inferrule{a \neq b\mid -}
   {\mathit{set.member}(k,a)\neq\mathit{set.member}(k,b)}
 \]
 where \(k\) is the \(\texttt{SETS_DEQ_DIFF}\) skolem for `(a, b)`.</div>
</section>
</li>
<li>
<section class="detail" id="SETS_FILTER_UP">
<h3>SETS_FILTER_UP</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">SETS_FILTER_UP</span></div>
<div class="block">Sets &ndash; Sets filter up
 
 \[
 
   \inferrule{\mathit{set.member}(x,a)\mid P}
   {\mathit{set.member}(x, \mathit{set.filter}(P, a)) = P(x)}
 \]</div>
</section>
</li>
<li>
<section class="detail" id="SETS_FILTER_DOWN">
<h3>SETS_FILTER_DOWN</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">SETS_FILTER_DOWN</span></div>
<div class="block">Sets &ndash; Sets filter down
 
 \[
 
   \inferrule{\mathit{set.member}(x,\mathit{set.filter}(P, a))\mid -}
   {\mathit{set.member}(x,a) \wedge P(x)}
 \]</div>
</section>
</li>
<li>
<section class="detail" id="CONCAT_EQ">
<h3>CONCAT_EQ</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">CONCAT_EQ</span></div>
<div class="block">Strings &ndash; Core rules &ndash; Concatenation equality
 
 \[
 
   \inferrule{(t_1 \cdot \ldots \cdot t_n \cdot t) = (t_1 \cdot \ldots \cdot t_n \cdot s)\mid \bot}{t = s}
 \]
 Alternatively for the reverse:
 
   \inferrule{(t \cdot t_1 \cdot \ldots \cdot t_n) = (s \cdot t_1 \cdot \ldots \cdot t_n)\mid \top}{t = s}
 
 Notice that \(t\) or \(s\) may be empty, in which case they are
 implicit in the concatenation above. For example, if the premise is
 \(x\cdot z = x\), then this rule, with argument \(\bot\), concludes
 \(z = \epsilon\).</div>
</section>
</li>
<li>
<section class="detail" id="CONCAT_UNIFY">
<h3>CONCAT_UNIFY</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">CONCAT_UNIFY</span></div>
<div class="block">Strings &ndash; Core rules &ndash; Concatenation unification
 
 \[
 
   \inferrule{(t_1 \cdot \ldots \cdot t_n) = (s_1 \cdot \ldots \cdot s_m),\, \mathit{len}(t_1) =
   \mathit{len}(s_1)\mid \bot}{t_1 = s_1}
 \]
 Alternatively for the reverse:
 
 \[
 
   \inferrule{(t_1 \cdot \ldots \cdot t_n) = (s_1 \cdot \ldots \cdot s_m),\, \mathit{len}(t_n) =
   \mathit{len}(s_m)\mid \top}{t_n = s_m}
 \]</div>
</section>
</li>
<li>
<section class="detail" id="CONCAT_SPLIT">
<h3>CONCAT_SPLIT</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">CONCAT_SPLIT</span></div>
<div class="block">Strings &ndash; Core rules &ndash; Concatenation split
 
 \[
 
   \inferruleSC{(t_1 \cdot \ldots \cdot t_n) = (s_1 \cdot \ldots \cdot s_m),\,
   \mathit{len}(t_1) \neq \mathit{len}(s_1)\mid \bot}{((t_1 = s_1\cdot r)
   \vee (s_1 = t_1\cdot r)) \wedge r \neq \epsilon \wedge \mathit{len}(r)&gt;0}
 \]
 where \(r\) is the purification skolem for
 \(\mathit{ite}(
 \mathit{len}(t_1) &gt;= \mathit{len}(s_1),
 \mathit{suf}(t_1,\mathit{len}(s_1)),
 \mathit{suf}(s_1,\mathit{len}(t_1)))\)
 and \(\epsilon\) is the empty string (or sequence).
 
 \[
 
   \inferruleSC{(t_1 \cdot \ldots \cdot t_n) = (s_1 \cdot \ldots \cdot s_m),\,
   \mathit{len}(t_n) \neq \mathit{len}(s_m)\mid \top}{((t_n = r \cdot s_m)
   \vee (s_m = r \cdot t_n)) \wedge r \neq \epsilon \wedge \mathit{len}(r)&gt;0}
 \]
 where \(r\) is the purification Skolem for
 \(\mathit{ite}(
 \mathit{len}(t_n) &gt;= \mathit{len}(s_m),
 \mathit{pre}(t_n,\mathit{len}(t_n) - \mathit{len}(s_m)),
 \mathit{pre}(s_m,\mathit{len}(s_m) - \mathit{len}(t_n)))\)
 and \(\epsilon\) is the empty string (or sequence).
 
 Above, \(\mathit{suf}(x,y)\) is shorthand for
 \(\mathit{substr}(x,y, \mathit{len}(x) - y)\) and
 \(\mathit{pre}(x,y)\) is shorthand for \(\mathit{substr}(x,0,y)\).</div>
</section>
</li>
<li>
<section class="detail" id="CONCAT_CSPLIT">
<h3>CONCAT_CSPLIT</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">CONCAT_CSPLIT</span></div>
<div class="block">Strings &ndash; Core rules &ndash; Concatenation split for constants
 
 \[
 
   \inferrule{(t_1\cdot \ldots \cdot t_n) = (c \cdot t_2 \ldots \cdot s_m),\,\mathit{len}(t_1) \neq 0\mid \bot}{(t_1 = c\cdot r)}
 \]
 where \(r\) is the purification skolem for \(\mathit{suf}(t_1,1)\).
 
 Alternatively for the reverse:
 
 \[
 
   \inferrule{(t_1\cdot \ldots \cdot t_n) = (s_1 \cdot \ldots s_{m-1} \cdot c),\,\mathit{len}(t_n) \neq 0\mid \top}{(t_n = r\cdot c)}
 \]
 where \(r\) is the purification skolem for
 \(\mathit{pre}(t_n,\mathit{len}(t_n) - 1)\).</div>
</section>
</li>
<li>
<section class="detail" id="CONCAT_LPROP">
<h3>CONCAT_LPROP</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">CONCAT_LPROP</span></div>
<div class="block">Strings &ndash; Core rules &ndash; Concatenation length propagation
 
 \[
 
   \inferrule{(t_1\cdot \ldots \cdot t_n) = (s_1 \cdot \ldots \cdot s_m),\,
   \mathit{len}(t_1) &gt; \mathit{len}(s_1)\mid \bot}{(t_1 = s_1\cdot r)}
 \]
 where \(r\) is the purification Skolem for
 \(\mathit{ite}(
 \mathit{len}(t_1) &gt;= \mathit{len}(s_1),
 \mathit{suf}(t_1,\mathit{len}(s_1)),
 \mathit{suf}(s_1,\mathit{len}(t_1)))\).
 
 Alternatively for the reverse:
 
 \[
 
   \inferrule{(t_1\cdot \ldots \cdot t_n) = (s_1 \cdot \ldots \cdot s_m)),\,
   \mathit{len}(t_n) &gt; \mathit{len}(s_m)\mid \top}{(t_n = r \cdot s_m)}
 \]
 where \(r\) is the purification Skolem for
 \(\mathit{ite}(
 \mathit{len}(t_n) &gt;= \mathit{len}(s_m),
 \mathit{pre}(t_n,\mathit{len}(t_n) - \mathit{len}(s_m)),
 \mathit{pre}(s_m,\mathit{len}(s_m) - \mathit{len}(t_n)))\)</div>
</section>
</li>
<li>
<section class="detail" id="CONCAT_CPROP">
<h3>CONCAT_CPROP</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">CONCAT_CPROP</span></div>
<div class="block">Strings &ndash; Core rules &ndash; Concatenation constant propagation
 
 \[
 
   \inferrule{(t_1 \cdot w_1 \cdot \ldots \cdot t_n) = (w_2 \cdot s_2 \cdot \ldots \cdot s_m),\,
   \mathit{len}(t_1) \neq 0\mid \bot}{(t_1 = t_3\cdot r)}
 \]
 where \(w_1,\,w_2\) are words, \(t_3\) is
 \(\mathit{pre}(w_2,p)\), \(p\) is
 \(\texttt{Word::overlap}(\mathit{suf}(w_2,1), w_1)\), and \(r\) is
 the purification skolem for
 \(\mathit{suf}(t_1,\mathit{len}(w_3))\).  Note that
 \(\mathit{suf}(w_2,p)\) is the largest suffix of
 \(\mathit{suf}(w_2,1)\) that can contain a prefix of \(w_1\); since
 \(t_1\) is non-empty, \(w_3\) must therefore be contained in
 \(t_1\).
 
 Alternatively for the reverse:
 
 \[
 
   \inferrule{(t_1 \cdot \ldots \cdot w_1 \cdot t_n) = (s_1 \cdot \ldots \cdot w_2),\,
   \mathit{len}(t_n) \neq 0\mid \top}{(t_n = r\cdot t_3)}
 \]
 where \(w_1,\,w_2\) are words, \(t_3\) is
 \(\mathit{substr}(w_2, \mathit{len}(w_2) - p, p)\), \(p\) is
 \(\texttt{Word::roverlap}(\mathit{pre}(w_2, \mathit{len}(w_2) - 1),
 w_1)\), and \(r\) is the purification skolem for
 \(\mathit{pre}(t_n,\mathit{len}(t_n) - \mathit{len}(w_3))\).  Note that
 \(\mathit{pre}(w_2, \mathit{len}(w_2) - p)\) is the largest prefix of
 \(\mathit{pre}(w_2, \mathit{len}(w_2) - 1)\) that can contain a suffix
 of \(w_1\); since \(t_n\) is non-empty, \(w_3\) must therefore
 be contained in \(t_n\).</div>
</section>
</li>
<li>
<section class="detail" id="STRING_DECOMPOSE">
<h3>STRING_DECOMPOSE</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">STRING_DECOMPOSE</span></div>
<div class="block">Strings &ndash; Core rules &ndash; String decomposition
 
 \[
 
   \inferrule{\mathit{len}(t) \geq n\mid \bot}{t = w_1\cdot w_2 \wedge
   \mathit{len}(w_1) = n}
 \]
 where \(w_1\) is the purification skolem for \(\mathit{pre}(t,n)\)
 and \(w_2\) is the purification skolem for \(\mathit{suf}(t,n)\).
 Or alternatively for the reverse:
 
 \[
 
   \inferrule{\mathit{len}(t) \geq n\mid \top}{t = w_1\cdot w_2 \wedge
   \mathit{len}(w_2) = n}
 \]
 where \(w_1\) is the purification skolem for \(\mathit{pre}(t,n)\) and
 \(w_2\) is the purification skolem for \(\mathit{suf}(t,n)\).</div>
</section>
</li>
<li>
<section class="detail" id="STRING_LENGTH_POS">
<h3>STRING_LENGTH_POS</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">STRING_LENGTH_POS</span></div>
<div class="block">Strings &ndash; Core rules &ndash; Length positive
 
 \[
 
   \inferrule{-\mid t}{(\mathit{len}(t) = 0\wedge t= \epsilon)\vee \mathit{len}(t)
   &gt; 0}
 \]</div>
</section>
</li>
<li>
<section class="detail" id="STRING_LENGTH_NON_EMPTY">
<h3>STRING_LENGTH_NON_EMPTY</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">STRING_LENGTH_NON_EMPTY</span></div>
<div class="block">Strings &ndash; Core rules &ndash; Length non-empty
 
 \[
 
   \inferrule{t\neq \epsilon\mid -}{\mathit{len}(t) \neq 0}
 \]</div>
</section>
</li>
<li>
<section class="detail" id="STRING_REDUCTION">
<h3>STRING_REDUCTION</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">STRING_REDUCTION</span></div>
<div class="block">Strings &ndash; Extended functions &ndash; Reduction
 
 \[
 
   \inferrule{-\mid t}{R\wedge t = w}
 \]
 where \(w\) is \(\texttt{StringsPreprocess::reduce}(t, R,
 \dots)\). For details, see
 :cvc5src:`theory/strings/theory_strings_preprocess.h`.
 In other words, \(R\) is the reduction predicate for extended
 term \(t\), and \(w\) is the purification skolem for \(t\).
 
 Notice that the free variables of \(R\) are \(w\) and the free
 variables of \(t\).</div>
</section>
</li>
<li>
<section class="detail" id="STRING_EAGER_REDUCTION">
<h3>STRING_EAGER_REDUCTION</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">STRING_EAGER_REDUCTION</span></div>
<div class="block">Strings &ndash; Extended functions &ndash; Eager reduction
 
 \[
 
   \inferrule{-\mid t}{R}
 \]
 where \(R\) is \(\texttt{TermRegistry::eagerReduce}(t)\).
 For details, see :cvc5src:`theory/strings/term_registry.h`.</div>
</section>
</li>
<li>
<section class="detail" id="RE_INTER">
<h3>RE_INTER</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">RE_INTER</span></div>
<div class="block">Strings &ndash; Regular expressions &ndash; Intersection
 
 \[
 
   \inferrule{t\in R_1,\,t\in R_2\mid -}{t\in \mathit{re.inter}(R_1,R_2)}
 \]</div>
</section>
</li>
<li>
<section class="detail" id="RE_CONCAT">
<h3>RE_CONCAT</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">RE_CONCAT</span></div>
<div class="block">Strings &ndash; Regular expressions &ndash; Concatenation
 
 \[
 
   \inferrule{t_1\in R_1,\,\ldots,\,t_n\in R_n\mid -}{\text{str.++}(t_1, \ldots, t_n)\in \text{re.++}(R_1, \ldots, R_n)}
 \]</div>
</section>
</li>
<li>
<section class="detail" id="RE_UNFOLD_POS">
<h3>RE_UNFOLD_POS</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">RE_UNFOLD_POS</span></div>
<div class="block">Strings &ndash; Regular expressions &ndash; Positive Unfold
 
 \[
 
   \inferrule{t\in R\mid -}{F}
 \]
 where \(F\) corresponds to the one-step unfolding of the premise.
 This is implemented by \(\texttt{RegExpOpr::reduceRegExpPos}(t\in R)\).</div>
</section>
</li>
<li>
<section class="detail" id="RE_UNFOLD_NEG">
<h3>RE_UNFOLD_NEG</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">RE_UNFOLD_NEG</span></div>
<div class="block">Strings &ndash; Regular expressions &ndash; Negative Unfold
 
 \[
 
   \inferrule{t \not \in \mathit{re}.\text{*}(R) \mid -}{t \neq \ \epsilon \ \wedge \forall L. L \leq 0 \vee \mathit{str.len}(t) &lt; L \vee \mathit{pre}(t, L) \not \in R \vee \mathit{suf}(t, L) \not \in \mathit{re}.\text{*}(R)}
 \]
 Or alternatively for regular expression concatenation:
 
 \[
 
   \inferrule{t \not \in \mathit{re}.\text{++}(R_1, \ldots, R_n)\mid -}{\forall L. L &lt; 0 \vee \mathit{str.len}(t) &lt; L \vee \mathit{pre}(t, L) \not \in R_1 \vee \mathit{suf}(t, L) \not \in \mathit{re}.\text{++}(R_2, \ldots, R_n)}
 \]
 Note that in either case the varaible \(L\) has type \(Int\) and
 name `"@var.str_index"`.</div>
</section>
</li>
<li>
<section class="detail" id="RE_UNFOLD_NEG_CONCAT_FIXED">
<h3>RE_UNFOLD_NEG_CONCAT_FIXED</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">RE_UNFOLD_NEG_CONCAT_FIXED</span></div>
<div class="block">Strings &ndash; Regular expressions &ndash; Unfold negative concatenation, fixed
 
 .. math.
 
   \inferrule{t\not\in \mathit{re}.\text{re.++}(r_1, \ldots, r_n) \mid \bot}{
  \mathit{pre}(t, L) \not \in r_1 \vee \mathit{suf}(t, L) \not \in \mathit{re}.\text{re.++}(r_2, \ldots, r_n)}
 
 where \(r_1\) has fixed length \(L\).
 
 or alternatively for the reverse:
 
 
 \[
 
   \inferrule{t \not \in \mathit{re}.\text{re.++}(r_1, \ldots, r_n) \mid \top}{
   \mathit{suf}(t, str.len(t) - L) \not \in r_n \vee
   \mathit{pre}(t, str.len(t) - L) \not \in \mathit{re}.\text{re.++}(r_1, \ldots, r_{n-1})}
 \]
 where \(r_n\) has fixed length \(L\).</div>
</section>
</li>
<li>
<section class="detail" id="STRING_CODE_INJ">
<h3>STRING_CODE_INJ</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">STRING_CODE_INJ</span></div>
<div class="block">Strings &ndash; Code points
 
 \[
 
   \inferrule{-\mid t,s}{\mathit{to\_code}(t) = -1 \vee \mathit{to\_code}(t) \neq
   \mathit{to\_code}(s) \vee t = s}
 \]</div>
</section>
</li>
<li>
<section class="detail" id="STRING_SEQ_UNIT_INJ">
<h3>STRING_SEQ_UNIT_INJ</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">STRING_SEQ_UNIT_INJ</span></div>
<div class="block">Strings &ndash; Sequence unit
 
 \[
 
   \inferrule{\mathit{unit}(x) = \mathit{unit}(y)\mid -}{x = y}
 \]
 Also applies to the case where \(\mathit{unit}(y)\) is a constant
 sequence of length one.</div>
</section>
</li>
<li>
<section class="detail" id="STRING_EXT">
<h3>STRING_EXT</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">STRING_EXT</span></div>
<div class="block">Strings &ndash; Extensionality
 
 \[
 
   \inferrule{s \neq t\mid -}
   {\mathit{seq.len}(s) \neq \mathit{seq.len}(t) \vee (\mathit{seq.nth}(s,k)\neq\mathit{set.nth}(t,k) \wedge 0 \leq k \wedge k &lt; \mathit{seq.len}(s))}
 \]
 where \(s,t\) are terms of sequence type, \(k\) is the
 \(\texttt{STRINGS_DEQ_DIFF}\) skolem for \(s,t\). Alternatively,
 if \(s,t\) are terms of string type, we use
 \(\mathit{seq.substr}(s,k,1)\) instead of \(\mathit{seq.nth}(s,k)\)
 and similarly for \(t\).</div>
</section>
</li>
<li>
<section class="detail" id="MACRO_STRING_INFERENCE">
<h3>MACRO_STRING_INFERENCE</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">MACRO_STRING_INFERENCE</span></div>
<div class="block">Strings &ndash; (Macro) String inference
 
 \[
 
   \inferrule{?\mid F,\mathit{id},\mathit{isRev},\mathit{exp}}{F}
 \]
 used to bookkeep an inference that has not yet been converted via
 \(\texttt{strings::InferProofCons::convert}\).</div>
</section>
</li>
<li>
<section class="detail" id="MACRO_ARITH_SCALE_SUM_UB">
<h3>MACRO_ARITH_SCALE_SUM_UB</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">MACRO_ARITH_SCALE_SUM_UB</span></div>
<div class="block">Arithmetic &ndash; Adding inequalities
 
 An arithmetic literal is a term of the form \(p \diamond c\) where
 \(\diamond \in \{ &lt;, \leq, =, \geq, &gt; \}\), \(p\) a
 polynomial and \(c\) a rational constant.
 
 \[
 
   \inferrule{l_1 \dots l_n \mid k_1 \dots k_n}{t_1 \diamond t_2}
 \]
 where \(k_i \in \mathbb{R}, k_i \neq 0\), \(\diamond\) is the
 fusion of the \(\diamond_i\) (flipping each if its \(k_i\) is
 negative) such that \(\diamond_i \in \{ &lt;, \leq \}\) (this implies that
 lower bounds have negative \(k_i\) and upper bounds have positive
 \(k_i\)), \(t_1\) is the sum of the scaled polynomials and
 \(t_2\) is the sum of the scaled constants:
 
 \[
 
   t_1 \colon= k_1 \cdot p_1 + \cdots + k_n \cdot p_n
 
   t_2 \colon= k_1 \cdot c_1 + \cdots + k_n \cdot c_n
 \]</div>
</section>
</li>
<li>
<section class="detail" id="ARITH_MULT_ABS_COMPARISON">
<h3>ARITH_MULT_ABS_COMPARISON</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">ARITH_MULT_ABS_COMPARISON</span></div>
<div class="block">Arithmetic &ndash; Non-linear multiply absolute value comparison
 
 \[
 
   \inferrule{F_1 \dots F_n \mid -}{F}
 \]
 where \(F\) is of the form
 \(\left| t_1 \cdot t_n \right| \diamond \left| s_1 \cdot s_n \right|\).
 If \(\diamond\) is \(=\), then each \(F_i\) is
 \(\left| t_i \right| = \left| s_i \right|\).
 
 If \(\diamond\) is \(&gt;\), then
 each \(F_i\) is either \(\left| t_i \right| &gt; \left| s_i \right|\) or
 \(\left| t_i \right| = \left| s_i \right| \land t_i \neq 0\),
 and \(F_1\) is of the former form.</div>
</section>
</li>
<li>
<section class="detail" id="ARITH_SUM_UB">
<h3>ARITH_SUM_UB</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">ARITH_SUM_UB</span></div>
<div class="block">Arithmetic &ndash; Sum upper bounds
 
 \[
 
   \inferrule{P_1 \dots P_n \mid -}{L \diamond R}
 \]
 where \(P_i\) has the form \(L_i \diamond_i R_i\) and
 \(\diamond_i \in \{&lt;, \leq, =\}\). Furthermore \(\diamond = &lt;\) if
 \(\diamond_i = &lt;\) for any \(i\) and \(\diamond = \leq\)
 otherwise, \(L = L_1 + \cdots + L_n\) and \(R = R_1 + \cdots + R_n\).</div>
</section>
</li>
<li>
<section class="detail" id="INT_TIGHT_UB">
<h3>INT_TIGHT_UB</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">INT_TIGHT_UB</span></div>
<div class="block">Arithmetic &ndash; Tighten strict integer upper bounds
 
 \[
 
   \inferrule{i &lt; c \mid -}{i \leq \lfloor c \rfloor}
 \]
 where \(i\) has integer type.</div>
</section>
</li>
<li>
<section class="detail" id="INT_TIGHT_LB">
<h3>INT_TIGHT_LB</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">INT_TIGHT_LB</span></div>
<div class="block">Arithmetic &ndash; Tighten strict integer lower bounds
 
 \[
 
   \inferrule{i &gt; c \mid -}{i \geq \lceil c \rceil}
 \]
 where \(i\) has integer type.</div>
</section>
</li>
<li>
<section class="detail" id="ARITH_TRICHOTOMY">
<h3>ARITH_TRICHOTOMY</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">ARITH_TRICHOTOMY</span></div>
<div class="block">Arithmetic &ndash; Trichotomy of the reals
 
 \[
 
   \inferrule{A, B \mid -}{C}
 \]
 where \(\neg A, \neg B, C\) are \(x &lt; c, x = c, x &gt; c\) in some order.
 Note that \(\neg\) here denotes arithmetic negation, i.e., flipping \(\geq\) to \(&lt;\) etc.</div>
</section>
</li>
<li>
<section class="detail" id="ARITH_REDUCTION">
<h3>ARITH_REDUCTION</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">ARITH_REDUCTION</span></div>
<div class="block">Arithmetic &ndash; Reduction
 
 \[
 
   \inferrule{- \mid t}{F}
 \]
 where \(t\) is an application of an extended arithmetic operator (e.g.
 division, modulus, cosine, sqrt, is_int, to_int) and \(F\) is the
 reduction predicate for \(t\). In other words, \(F\) is a
 predicate that is used to reduce reasoning about \(t\) to reasoning
 about the core operators of arithmetic.
 
 In detail, \(F\) is implemented by
 \(\texttt{arith::OperatorElim::getAxiomFor(t)}\), see
 :cvc5src:`theory/arith/operator_elim.h`.</div>
</section>
</li>
<li>
<section class="detail" id="ARITH_POLY_NORM">
<h3>ARITH_POLY_NORM</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">ARITH_POLY_NORM</span></div>
<div class="block">Arithmetic &ndash; Polynomial normalization
 
 \[
 
   \inferrule{- \mid t = s}{t = s}
 \]
 where \(\texttt{arith::PolyNorm::isArithPolyNorm(t, s)} = \top\). This
 method normalizes polynomials \(s\) and \(t\) over arithmetic.</div>
</section>
</li>
<li>
<section class="detail" id="ARITH_POLY_NORM_REL">
<h3>ARITH_POLY_NORM_REL</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">ARITH_POLY_NORM_REL</span></div>
<div class="block">Arithmetic &ndash; Polynomial normalization for relations
 
 .. math.
 
  \inferrule{c_x \cdot (x_1 - x_2) = c_y \cdot (y_1 - y_2) \mid (x_1 \diamond x_2) = (y_1 \diamond y_2)}
            {(x_1 \diamond x_2) = (y_1 \diamond y_2)}
 
 where \(\diamond \in \{&lt;, \leq, =, \geq, &gt;\}\). \(c_x\) and
 \(c_y\) are scaling factors. For \(&lt;, \leq, \geq, &gt;\), the scaling
 factors have the same sign.
 
 If \(c_x\) has type \(Real\) and \(x_1, x_2\) are of type
 \(Int\), then \((x_1 - x_2)\) is wrapped in an application of
 `to_real`, similarly for \((y_1 - y_2)\).</div>
</section>
</li>
<li>
<section class="detail" id="ARITH_MULT_SIGN">
<h3>ARITH_MULT_SIGN</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">ARITH_MULT_SIGN</span></div>
<div class="block">Arithmetic &ndash; Sign inference
 
 \[
 
   \inferrule{- \mid f_1 \dots f_k, m}{(f_1 \land \dots \land f_k) \rightarrow m \diamond 0}
 \]
 where \(f_1 \dots f_k\) are variables compared to zero (less, greater
 or not equal), \(m\) is a monomial from these variables and
 \(\diamond\) is the comparison (less or greater) that results from the
 signs of the variables. In particular, \(\diamond\) is :math`&lt;`
 if \(f_1 \dots f_k\) contains an odd number of :math`&lt;`. Otherwise
 \(\diamond\) is :math`&gt;`. All variables with even exponent in \(m\)
 are given as not equal to zero while all variables with odd exponent
 in \(m\) should be given as less or greater than zero.</div>
</section>
</li>
<li>
<section class="detail" id="ARITH_MULT_POS">
<h3>ARITH_MULT_POS</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">ARITH_MULT_POS</span></div>
<div class="block">Arithmetic &ndash; Multiplication with positive factor
 
 \[
 
   \inferrule{- \mid m, l \diamond r}{(m &gt; 0 \land l \diamond r) \rightarrow m \cdot l \diamond m \cdot r}
 \]
 where \(\diamond\) is a relation symbol.</div>
</section>
</li>
<li>
<section class="detail" id="ARITH_MULT_NEG">
<h3>ARITH_MULT_NEG</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">ARITH_MULT_NEG</span></div>
<div class="block">Arithmetic &ndash; Multiplication with negative factor
 
 \[
 
   \inferrule{- \mid m, l \diamond r}{(m &lt; 0 \land l \diamond r) \rightarrow m \cdot l \diamond_{inv} m \cdot r}
 \]
 where \(\diamond\) is a relation symbol and \(\diamond_{inv}\) the
 inverted relation symbol.</div>
</section>
</li>
<li>
<section class="detail" id="ARITH_MULT_TANGENT">
<h3>ARITH_MULT_TANGENT</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">ARITH_MULT_TANGENT</span></div>
<div class="block">Arithmetic &ndash; Multiplication tangent plane
 
 \[
 
   \inferruleSC{- \mid x, y, a, b, \sigma}{(t \leq tplane) = ((x \leq a \land y \geq b) \lor (x \geq a \land y \leq b))}{if $\sigma = \bot$}
 
   \inferruleSC{- \mid x, y, a, b, \sigma}{(t \geq tplane) = ((x \leq a \land y \leq b) \lor (x \geq a \land y \geq b))}{if $\sigma = \top$}
 \]
 where \(x,y\) are real terms (variables or extended terms),
 \(t = x \cdot y\), \(a,b\) are real
 constants, \(\sigma \in \{ \top, \bot\}\) and \(tplane := b \cdot x + a \cdot y - a \cdot b\) is the tangent plane of \(x \cdot y\) at \((a,b)\).</div>
</section>
</li>
<li>
<section class="detail" id="ARITH_TRANS_PI">
<h3>ARITH_TRANS_PI</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">ARITH_TRANS_PI</span></div>
<div class="block">Arithmetic &ndash; Transcendentals &ndash; Assert bounds on Pi
 
 \[
 
   \inferrule{- \mid l, u}{\texttt{real.pi} \geq l \land \texttt{real.pi}
   \leq u}
 \]
 where \(l,u\) are valid lower and upper bounds on \(\pi\).</div>
</section>
</li>
<li>
<section class="detail" id="ARITH_TRANS_EXP_NEG">
<h3>ARITH_TRANS_EXP_NEG</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">ARITH_TRANS_EXP_NEG</span></div>
<div class="block">Arithmetic &ndash; Transcendentals &ndash; Exp at negative values
 
 \[
 
   \inferrule{- \mid t}{(t &lt; 0.0) \leftrightarrow (\exp(t) &lt; 1.0)}
 \]</div>
</section>
</li>
<li>
<section class="detail" id="ARITH_TRANS_EXP_POSITIVITY">
<h3>ARITH_TRANS_EXP_POSITIVITY</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">ARITH_TRANS_EXP_POSITIVITY</span></div>
<div class="block">Arithmetic &ndash; Transcendentals &ndash; Exp is always positive
 
 \[
 
   \inferrule{- \mid t}{\exp(t) &gt; 0.0}
 \]</div>
</section>
</li>
<li>
<section class="detail" id="ARITH_TRANS_EXP_SUPER_LIN">
<h3>ARITH_TRANS_EXP_SUPER_LIN</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">ARITH_TRANS_EXP_SUPER_LIN</span></div>
<div class="block">Arithmetic &ndash; Transcendentals &ndash; Exp grows super-linearly for positive
 values
 
 \[
 
   \inferrule{- \mid t}{t \leq 0.0 \lor \exp(t) &gt; t+1.0}
 \]</div>
</section>
</li>
<li>
<section class="detail" id="ARITH_TRANS_EXP_ZERO">
<h3>ARITH_TRANS_EXP_ZERO</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">ARITH_TRANS_EXP_ZERO</span></div>
<div class="block">Arithmetic &ndash; Transcendentals &ndash; Exp at zero
 
 \[
 
   \inferrule{- \mid t}{(t=0.0) \leftrightarrow (\exp(t) = 1.0)}
 \]</div>
</section>
</li>
<li>
<section class="detail" id="ARITH_TRANS_EXP_APPROX_ABOVE_NEG">
<h3>ARITH_TRANS_EXP_APPROX_ABOVE_NEG</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">ARITH_TRANS_EXP_APPROX_ABOVE_NEG</span></div>
<div class="block">Arithmetic &ndash; Transcendentals &ndash; Exp is approximated from above for \
 negative values
 
 \[
 
   \inferrule{- \mid d,t,l,u}{(t \geq l \land t \leq u) \rightarrow exp(t)
   \leq \texttt{secant}(\exp, l, u, t)}
 \]
 where \(d\) is an even positive number, \(t\) an arithmetic term
 and \(l,u\) are lower and upper bounds on \(t\). Let \(p\) be
 the \(d\)'th taylor polynomial at zero (also called the Maclaurin
 series) of the exponential function. \(\texttt{secant}(\exp, l, u, t)\)
 denotes the secant of \(p\) from \((l, \exp(l))\) to \((u,
 \exp(u))\) evaluated at \(t\), calculated as follows:
 
 \[
 
   \frac{p(l) - p(u)}{l - u} \cdot (t - l) + p(l)
 \]
 The lemma states that if \(t\) is between \(l\) and \(u\), then
 \(\exp(t\) is below the secant of \(p\) from \(l\) to
 \(u\).</div>
</section>
</li>
<li>
<section class="detail" id="ARITH_TRANS_EXP_APPROX_ABOVE_POS">
<h3>ARITH_TRANS_EXP_APPROX_ABOVE_POS</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">ARITH_TRANS_EXP_APPROX_ABOVE_POS</span></div>
<div class="block">Arithmetic &ndash; Transcendentals &ndash; Exp is approximated from above for \
 positive values
 
 \[
 
   \inferrule{- \mid d,t,l,u}{(t \geq l \land t \leq u) \rightarrow exp(t)
   \leq \texttt{secant-pos}(\exp, l, u, t)}
 \]
 where \(d\) is an even positive number, \(t\) an arithmetic term
 and \(l,u\) are lower and upper bounds on \(t\). Let \(p^*\) be
 a modification of the \(d\)'th taylor polynomial at zero (also called
 the Maclaurin series) of the exponential function as follows where
 \(p(d-1)\) is the regular Maclaurin series of degree \(d-1\):
 
 \[
 
   p^* := p(d-1) \cdot (\frac{1 - t^n}{n!})^{-1}
 \]
 \(\texttt{secant-pos}(\exp, l, u, t)\) denotes the secant of \(p\)
 from \((l, \exp(l))\) to \((u, \exp(u))\) evaluated at \(t\),
 calculated as follows:
 
 \[
 
   \frac{p(l) - p(u)}{l - u} \cdot (t - l) + p(l)
 \]
 The lemma states that if \(t\) is between \(l\) and \(u\), then
 \(\exp(t\) is below the secant of \(p\) from \(l\) to
 \(u\).</div>
</section>
</li>
<li>
<section class="detail" id="ARITH_TRANS_EXP_APPROX_BELOW">
<h3>ARITH_TRANS_EXP_APPROX_BELOW</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">ARITH_TRANS_EXP_APPROX_BELOW</span></div>
<div class="block">Arithmetic &ndash; Transcendentals &ndash; Exp is approximated from below
 
 \[
 
   \inferrule{- \mid d,c,t}{t \geq c \rightarrow exp(t) \geq \texttt{maclaurin}(\exp, d, c)}
 \]
 where \(d\) is a non-negative number, \(t\) an arithmetic term and
 \(\texttt{maclaurin}(\exp, n+1, c)\) is the \((n+1)\)'th taylor
 polynomial at zero (also called the Maclaurin series) of the exponential
 function evaluated at \(c\) where \(n\) is \(2 \cdot d\).
 The Maclaurin series for the exponential function is the following:
 
 \[
 
   \exp(x) = \sum_{i=0}^{\infty} \frac{x^i}{i!}
 \]
 This rule furthermore requires that \(1 &gt; c^{n+1}/(n+1)!\)</div>
</section>
</li>
<li>
<section class="detail" id="ARITH_TRANS_SINE_BOUNDS">
<h3>ARITH_TRANS_SINE_BOUNDS</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">ARITH_TRANS_SINE_BOUNDS</span></div>
<div class="block">Arithmetic &ndash; Transcendentals &ndash; Sine is always between -1 and 1
 
 \[
 
   \inferrule{- \mid t}{\sin(t) \leq 1.0 \land \sin(t) \geq -1.0}
 \]</div>
</section>
</li>
<li>
<section class="detail" id="ARITH_TRANS_SINE_SHIFT">
<h3>ARITH_TRANS_SINE_SHIFT</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">ARITH_TRANS_SINE_SHIFT</span></div>
<div class="block">Arithmetic &ndash; Transcendentals &ndash; Sine is shifted to -pi...pi
 
 \[
 
   \inferrule{- \mid x}{-\pi \leq y \leq \pi \land \sin(y) = \sin(x)
   \land (\ite{-\pi \leq x \leq \pi}{x = y}{x = y + 2 \pi s})}
 \]
 where \(x\) is the argument to sine, \(y\) is a new real skolem
 that is \(x\) shifted into \(-\pi \dots \pi\) and \(s\) is a
 new integer skolem that is the number of phases \(y\) is shifted.
 In particular, \(y\) is the
 TRANSCENDENTAL_PURIFY_ARG &lt;cvc5.<a href="SkolemId.html#TRANSCENDENTAL_PURIFY_ARG"><code>SkolemId.TRANSCENDENTAL_PURIFY_ARG</code></a>&gt;
 skolem for \(\sin(x)\) and \(s\) is the
 TRANSCENDENTAL_SINE_PHASE_SHIFT &lt;cvc5.<a href="SkolemId.html#TRANSCENDENTAL_SINE_PHASE_SHIFT"><code>SkolemId.TRANSCENDENTAL_SINE_PHASE_SHIFT</code></a>&gt;
 skolem for \(x\).</div>
</section>
</li>
<li>
<section class="detail" id="ARITH_TRANS_SINE_SYMMETRY">
<h3>ARITH_TRANS_SINE_SYMMETRY</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">ARITH_TRANS_SINE_SYMMETRY</span></div>
<div class="block">Arithmetic &ndash; Transcendentals &ndash; Sine is symmetric with respect to \
 negation of the argument
 
 \[
 
   \inferrule{- \mid t}{\sin(t) + \sin(-t) = 0.0}
 \]</div>
</section>
</li>
<li>
<section class="detail" id="ARITH_TRANS_SINE_TANGENT_ZERO">
<h3>ARITH_TRANS_SINE_TANGENT_ZERO</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">ARITH_TRANS_SINE_TANGENT_ZERO</span></div>
<div class="block">Arithmetic &ndash; Transcendentals &ndash; Sine is bounded by the tangent at zero
 
 \[
 
   \inferrule{- \mid t}{(t &gt; 0.0 \rightarrow \sin(t) &lt; t) \land (t &lt; 0.0
   \rightarrow \sin(t) &gt; t)}
 \]</div>
</section>
</li>
<li>
<section class="detail" id="ARITH_TRANS_SINE_TANGENT_PI">
<h3>ARITH_TRANS_SINE_TANGENT_PI</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">ARITH_TRANS_SINE_TANGENT_PI</span></div>
<div class="block">Arithmetic &ndash; Transcendentals &ndash; Sine is bounded by the tangents at -pi and pi
 
 \[
 
   \inferrule{- \mid t}{(t &gt; -\pi \rightarrow \sin(t) &gt; -\pi - t) \land (t &lt;
   \pi \rightarrow \sin(t) &lt; \pi - t)}
 \]</div>
</section>
</li>
<li>
<section class="detail" id="ARITH_TRANS_SINE_APPROX_ABOVE_NEG">
<h3>ARITH_TRANS_SINE_APPROX_ABOVE_NEG</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">ARITH_TRANS_SINE_APPROX_ABOVE_NEG</span></div>
<div class="block">Arithmetic &ndash; Transcendentals &ndash; Sine is approximated from above for\
 negative values
 
 \[
 
   \inferrule{- \mid d,t,lb,ub,l,u}{(t \geq lb \land t \leq ub) \rightarrow
   \sin(t) \leq \texttt{secant}(\sin, l, u, t)}
 \]
 where \(d\) is an even positive number, \(t\) an arithmetic term,
 \(lb,ub\) are symbolic lower and upper bounds on \(t\) (possibly
 containing \(\pi\)) and \(l,u\) the evaluated lower and upper
 bounds on \(t\). Let \(p\) be the \(d\)'th taylor polynomial at
 zero (also called the Maclaurin series) of the sine function.
 \(\texttt{secant}(\sin, l, u, t)\) denotes the secant of \(p\) from
 \((l, \sin(l))\) to \((u, \sin(u))\) evaluated at \(t\),
 calculated as follows:
 
 \[
 
   \frac{p(l) - p(u)}{l - u} \cdot (t - l) + p(l)
 \]
 The lemma states that if \(t\) is between \(l\) and \(u\), then
 \(\sin(t)\) is below the secant of \(p\) from \(l\) to
 \(u\).</div>
</section>
</li>
<li>
<section class="detail" id="ARITH_TRANS_SINE_APPROX_ABOVE_POS">
<h3>ARITH_TRANS_SINE_APPROX_ABOVE_POS</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">ARITH_TRANS_SINE_APPROX_ABOVE_POS</span></div>
<div class="block">Arithmetic &ndash; Transcendentals &ndash; Sine is approximated from above for \
 positive values
 
 \[
 
   \inferrule{- \mid d,t,c,lb,ub}{(t \geq lb \land t \leq ub) \rightarrow
   \sin(t) \leq \texttt{upper}(\sin, c)}
 \]
 where \(d\) is an even positive number, \(t\) an arithmetic term,
 \(c\) an arithmetic constant and \(lb,ub\) are symbolic lower and
 upper bounds on \(t\) (possibly containing \(\pi\)). Let \(p\)
 be the \(d\)'th taylor polynomial at zero (also called the Maclaurin
 series) of the sine function. \(\texttt{upper}(\sin, c)\) denotes the
 upper bound on \(\sin(c)\) given by \(p\) and \(lb,up\) such
 that \(\sin(t)\) is the maximum of the sine function on
 \((lb,ub)\).</div>
</section>
</li>
<li>
<section class="detail" id="ARITH_TRANS_SINE_APPROX_BELOW_NEG">
<h3>ARITH_TRANS_SINE_APPROX_BELOW_NEG</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">ARITH_TRANS_SINE_APPROX_BELOW_NEG</span></div>
<div class="block">Arithmetic &ndash; Transcendentals &ndash; Sine is approximated from below for \
 negative values
 
 \[
 
   \inferrule{- \mid d,t,c,lb,ub}{(t \geq lb \land t \leq ub) \rightarrow
   \sin(t) \geq \texttt{lower}(\sin, c)}
 \]
 where \(d\) is an even positive number, \(t\) an arithmetic term,
 \(c\) an arithmetic constant and \(lb,ub\) are symbolic lower and
 upper bounds on \(t\) (possibly containing \(\pi\)). Let \(p\)
 be the \(d\)'th taylor polynomial at zero (also called the Maclaurin
 series) of the sine function. \(\texttt{lower}(\sin, c)\) denotes the
 lower bound on \(\sin(c)\) given by \(p\) and \(lb,up\) such
 that \(\sin(t)\) is the minimum of the sine function on
 \((lb,ub)\).</div>
</section>
</li>
<li>
<section class="detail" id="ARITH_TRANS_SINE_APPROX_BELOW_POS">
<h3>ARITH_TRANS_SINE_APPROX_BELOW_POS</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">ARITH_TRANS_SINE_APPROX_BELOW_POS</span></div>
<div class="block">Arithmetic &ndash; Transcendentals &ndash; Sine is approximated from below for \
 positive values
 
 \[
 
   \inferrule{- \mid d,t,lb,ub,l,u}{(t \geq lb \land t \leq ub) \rightarrow
   \sin(t) \geq \texttt{secant}(\sin, l, u, t)}
 \]
 where \(d\) is an even positive number, \(t\) an arithmetic term,
 \(lb,ub\) are symbolic lower and upper bounds on \(t\) (possibly
 containing \(\pi\)) and \(l,u\) the evaluated lower and upper
 bounds on \(t\). Let \(p\) be the \(d\)'th taylor polynomial at
 zero (also called the Maclaurin series) of the sine function.
 \(\texttt{secant}(\sin, l, u, t)\) denotes the secant of \(p\) from
 \((l, \sin(l))\) to \((u, \sin(u))\) evaluated at \(t\),
 calculated as follows:
 
 \[
 
   \frac{p(l) - p(u)}{l - u} \cdot (t - l) + p(l)
 \]
 The lemma states that if \(t\) is between \(l\) and \(u\), then
 \(\sin(t)\) is above the secant of \(p\) from \(l\) to
 \(u\).</div>
</section>
</li>
<li>
<section class="detail" id="LFSC_RULE">
<h3>LFSC_RULE</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">LFSC_RULE</span></div>
<div class="block">External &ndash; LFSC
 
 Place holder for LFSC rules.
 
 \[
 
   \inferrule{P_1, \dots, P_n\mid \texttt{id}, Q, A_1,\dots, A_m}{Q}
 \]
 Note that the premises and arguments are arbitrary. It's expected that
 \(\texttt{id}\) refer to a proof rule in the external LFSC calculus.</div>
</section>
</li>
<li>
<section class="detail" id="ALETHE_RULE">
<h3>ALETHE_RULE</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">ALETHE_RULE</span></div>
<div class="block">External &ndash; Alethe
 
 Place holder for Alethe rules.
 
 \[
 
   \inferrule{P_1, \dots, P_n\mid \texttt{id}, Q, Q', A_1,\dots, A_m}{Q}
 \]
 Note that the premises and arguments are arbitrary. It's expected that
 \(\texttt{id}\) refer to a proof rule in the external Alethe calculus,
 and that \(Q'\) be the representation of Q to be printed by the Alethe
 printer.</div>
</section>
</li>
<li>
<section class="detail" id="UNKNOWN">
<h3>UNKNOWN</h3>
<div class="member-signature"><span class="modifiers">public static final</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">UNKNOWN</span></div>
<div class="block">External &ndash; Alethe
 
 Place holder for Alethe rules.
 
 \[
 
   \inferrule{P_1, \dots, P_n\mid \texttt{id}, Q, Q', A_1,\dots, A_m}{Q}
 \]
 Note that the premises and arguments are arbitrary. It's expected that
 \(\texttt{id}\) refer to a proof rule in the external Alethe calculus,
 and that \(Q'\) be the representation of Q to be printed by the Alethe
 printer.</div>
</section>
</li>
</ul>
</section>
</li>
<!-- ============ METHOD DETAIL ========== -->
<li>
<section class="method-details" id="method-detail">
<h2>Method Details</h2>
<ul class="member-list">
<li>
<section class="detail" id="values()">
<h3>values</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a>[]</span>&nbsp;<span class="element-name">values</span>()</div>
<div class="block">Returns an array containing the constants of this enum class, in
the order they are declared.</div>
<dl class="notes">
<dt>Returns:</dt>
<dd>an array containing the constants of this enum class, in the order they are declared</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="valueOf(java.lang.String)">
<h3>valueOf</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">valueOf</span><wbr><span class="parameters">(<a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a>&nbsp;name)</span></div>
<div class="block">Returns the enum constant of this class with the specified name.
The string must match <i>exactly</i> an identifier used to declare an
enum constant in this class.  (Extraneous whitespace characters are 
not permitted.)</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>name</code> - the name of the enum constant to be returned.</dd>
<dt>Returns:</dt>
<dd>the enum constant with the specified name</dd>
<dt>Throws:</dt>
<dd><code><a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/IllegalArgumentException.html" title="class or interface in java.lang" class="external-link">IllegalArgumentException</a></code> - if this enum class has no constant with the specified name</dd>
<dd><code><a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/NullPointerException.html" title="class or interface in java.lang" class="external-link">NullPointerException</a></code> - if the argument is null</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="fromInt(int)">
<h3>fromInt</h3>
<div class="member-signature"><span class="modifiers">public static</span>&nbsp;<span class="return-type"><a href="ProofRule.html" title="enum class in io.github.cvc5">ProofRule</a></span>&nbsp;<span class="element-name">fromInt</span><wbr><span class="parameters">(int&nbsp;value)</span>
                         throws <span class="exceptions"><a href="CVC5ApiException.html" title="class in io.github.cvc5">CVC5ApiException</a></span></div>
<div class="block">Converts an integer value to the corresponding enum constant.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>value</code> - the integer representation of the enum constant.</dd>
<dt>Returns:</dt>
<dd>the corresponding enum constant for the given integer value.</dd>
<dt>Throws:</dt>
<dd><code><a href="CVC5ApiException.html" title="class in io.github.cvc5">CVC5ApiException</a></code> - if the value is outside the valid range,
                          or if no corresponding enum constant exists.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="getValue()">
<h3>getValue</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="element-name">getValue</span>()</div>
<div class="block">Get the integer value associated with this enum constant.</div>
<dl class="notes">
<dt>Returns:</dt>
<dd>the integer representation of the enum constant.</dd>
</dl>
</section>
</li>
</ul>
</section>
</li>
</ul>
</section>
<!-- ========= END OF CLASS DATA ========= -->
</main>
</div>
</div>
</body>
</html>



<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-ML12X2V35B"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-ML12X2V35B');
    </script>
    
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Kind &mdash; cvc5  documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../static/css/theme.css?v=9edc463e" />
      <link rel="stylesheet" type="text/css" href="../../../static/custom.css?v=b9602cbe" />

  
      <script src="../../../static/jquery.js?v=5d32c60e"></script>
      <script src="../../../static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../static/documentation_options.js?v=5929fcd5"></script>
      <script src="../../../static/doctools.js?v=9bcbadda"></script>
      <script src="../../../static/sphinx_highlight.js?v=dc90522c"></script>
      <script>window.MathJax = {"loader": {"load": ["[tex]/ams", "[tex]/bussproofs"]}, "tex": {"packages": {"[+]": ["ams", "bussproofs"]}, "macros": {"xor": "\\mathbin{xor}", "ite": ["#1 \\mathbin{?} #2 \\mathbin{:} #3", 3], "inferrule": ["\\begin{prooftree}\\AxiomC{$#1$}\\UnaryInfC{$#2$}\\end{prooftree}", 2], "inferruleSC": ["\\begin{prooftree}\\AxiomC{$#1$}\\RightLabel{ #3}\\UnaryInfC{$#2$}\\end{prooftree}", 3]}}}</script>
      <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../../../static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="next" title="Modes" href="modes.html" />
    <link rel="prev" title="InputParser" href="inputparser.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            cvc5
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../../installation/installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../binary/binary.html">Binary Documentation</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../../api.html">API Documentation</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../../cpp/cpp.html">C++ API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../c/c.html">C API</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../java/java.html">Java API</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../python.html">Python API</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="../pythonic/pythonic.html">Pythonic API</a></li>
<li class="toctree-l3 current"><a class="reference internal" href="python.html">Base Python API</a><ul class="current">
<li class="toctree-l4"><a class="reference internal" href="quickstart.html">Quickstart Guide</a></li>
<li class="toctree-l4"><a class="reference internal" href="command.html">Command</a></li>
<li class="toctree-l4"><a class="reference internal" href="datatype.html">Datatype</a></li>
<li class="toctree-l4"><a class="reference internal" href="datatypeconstructor.html">DatatypeConstructor</a></li>
<li class="toctree-l4"><a class="reference internal" href="datatypeconstructordecl.html">DatatypeConstructorDecl</a></li>
<li class="toctree-l4"><a class="reference internal" href="datatypedecl.html">DatatypeDecl</a></li>
<li class="toctree-l4"><a class="reference internal" href="datatypeselector.html">DatatypeSelector</a></li>
<li class="toctree-l4"><a class="reference internal" href="grammar.html">Grammar</a></li>
<li class="toctree-l4"><a class="reference internal" href="inputparser.html">InputParser</a></li>
<li class="toctree-l4 current"><a class="current reference internal" href="#">Kind</a><ul>
<li class="toctree-l5"><a class="reference internal" href="#cvc5.Kind"><code class="docutils literal notranslate"><span class="pre">Kind</span></code></a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="modes.html">Modes</a></li>
<li class="toctree-l4"><a class="reference internal" href="op.html">Op</a></li>
<li class="toctree-l4"><a class="reference internal" href="plugin.html">Plugin</a></li>
<li class="toctree-l4"><a class="reference internal" href="proof.html">Proof</a></li>
<li class="toctree-l4"><a class="reference internal" href="result.html">Result</a></li>
<li class="toctree-l4"><a class="reference internal" href="roundingmode.html">RoundingMode</a></li>
<li class="toctree-l4"><a class="reference internal" href="solver.html">Solver</a></li>
<li class="toctree-l4"><a class="reference internal" href="sort.html">Sort</a></li>
<li class="toctree-l4"><a class="reference internal" href="sortkind.html">SortKind</a></li>
<li class="toctree-l4"><a class="reference internal" href="statistics.html">Statistics</a></li>
<li class="toctree-l4"><a class="reference internal" href="symbolmanager.html">SymbolManager</a></li>
<li class="toctree-l4"><a class="reference internal" href="synthresult.html">SynthResult</a></li>
<li class="toctree-l4"><a class="reference internal" href="term.html">Term</a></li>
<li class="toctree-l4"><a class="reference internal" href="termmanager.html">TermManager</a></li>
<li class="toctree-l4"><a class="reference internal" href="unknownexplanation.html">UnknownExplanation</a></li>
<li class="toctree-l4"><a class="reference internal" href="python.html#classes">Classes</a></li>
<li class="toctree-l4"><a class="reference internal" href="python.html#enums">Enums</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../python.html#which-python-api-should-i-use">Which Python API should I use?</a></li>
<li class="toctree-l3"><a class="reference internal" href="../python.html#installation-from-pypi">Installation (from PyPi)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../python.html#installation-from-source">Installation (from source)</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../options.html">Options</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../output-tags.html">Output tags</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../proofs/proofs.html">Proof Production</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../resource-limits.html">Resource limits</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../skolem-ids.html">Skolem Identifiers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../statistics.html">Statistics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../examples/examples.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../theories/theories.html">Theory References</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../references.html">References</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../genindex.html">Index</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">cvc5</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../api.html">API Documentation</a></li>
          <li class="breadcrumb-item"><a href="../python.html">Python API</a></li>
          <li class="breadcrumb-item"><a href="python.html">Base Python API</a></li>
      <li class="breadcrumb-item active">Kind</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="kind">
<h1>Kind<a class="headerlink" href="#kind" title="Link to this heading"></a></h1>
<p>Every <a class="reference internal" href="term.html#cvc5.Term" title="cvc5.Term"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Term</span></code></a> has an associated kind, represented
as enum class <a class="reference internal" href="#cvc5.Kind" title="cvc5.Kind"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cvc5.Kind</span></code></a>.
This kind distinguishes if the Term is a value, constant, variable or operator,
and what kind of each.
For example, a bit-vector value has kind
<a class="reference internal" href="#cvc5.Kind.CONST_BITVECTOR" title="cvc5.Kind.CONST_BITVECTOR"><code class="xref py py-obj docutils literal notranslate"><span class="pre">CONST_BITVECTOR</span></code></a>,
a free constant symbol has kind
<a class="reference internal" href="#cvc5.Kind.CONSTANT" title="cvc5.Kind.CONSTANT"><code class="xref py py-obj docutils literal notranslate"><span class="pre">CONSTANT</span></code></a>,
an equality over terms of any sort has kind
<a class="reference internal" href="#cvc5.Kind.EQUAL" title="cvc5.Kind.EQUAL"><code class="xref py py-obj docutils literal notranslate"><span class="pre">EQUAL</span></code></a>, and a universally
quantified formula has kind <a class="reference internal" href="#cvc5.Kind.FORALL" title="cvc5.Kind.FORALL"><code class="xref py py-obj docutils literal notranslate"><span class="pre">FORALL</span></code></a>.</p>
<p>The kinds below directly correspond to the enum values of the C++
<a class="reference internal" href="../../cpp/enums/kind.html#_CPPv4N4cvc54KindE" title="cvc5::Kind"><code class="xref cpp cpp-enum docutils literal notranslate"><span class="pre">Kind</span></code></a> enum.</p>
<hr class="docutils" />
<dl class="py class">
<dt class="sig sig-object py" id="cvc5.Kind">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">cvc5.</span></span><span class="sig-name descname"><span class="pre">Kind</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">values</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cvc5.Kind" title="Link to this definition"></a></dt>
<dd><p>The Kind enum</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.ABS">
<span class="sig-name descname"><span class="pre">ABS</span></span><a class="headerlink" href="#cvc5.Kind.ABS" title="Link to this definition"></a></dt>
<dd><p>Absolute value.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">1</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of Sort Int or Real</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.ADD">
<span class="sig-name descname"><span class="pre">ADD</span></span><a class="headerlink" href="#cvc5.Kind.ADD" title="Link to this definition"></a></dt>
<dd><p>Arithmetic addition.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">&gt;</span> <span class="pre">1</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1..n:</span></code> Terms of Sort Int or Real (sorts must match)</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.AND">
<span class="sig-name descname"><span class="pre">AND</span></span><a class="headerlink" href="#cvc5.Kind.AND" title="Link to this definition"></a></dt>
<dd><p>Logical conjunction.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">&gt;</span> <span class="pre">1</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1..n:</span></code> Terms of Sort Bool</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.APPLY_CONSTRUCTOR">
<span class="sig-name descname"><span class="pre">APPLY_CONSTRUCTOR</span></span><a class="headerlink" href="#cvc5.Kind.APPLY_CONSTRUCTOR" title="Link to this definition"></a></dt>
<dd><p>Datatype constructor application.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">&gt;</span> <span class="pre">0</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> DatatypeConstructor Term (see <a class="reference internal" href="datatypeconstructor.html#cvc5.DatatypeConstructor.getTerm" title="cvc5.DatatypeConstructor.getTerm"><code class="xref py py-meth docutils literal notranslate"><span class="pre">DatatypeConstructor.getTerm()</span></code></a>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">2..n:</span></code> Terms of the Sorts of the selectors of the constructor (the arguments to the constructor)</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.APPLY_SELECTOR">
<span class="sig-name descname"><span class="pre">APPLY_SELECTOR</span></span><a class="headerlink" href="#cvc5.Kind.APPLY_SELECTOR" title="Link to this definition"></a></dt>
<dd><p>Datatype selector application.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">2</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> DatatypeSelector Term (see <a class="reference internal" href="datatypeselector.html#cvc5.DatatypeSelector.getTerm" title="cvc5.DatatypeSelector.getTerm"><code class="xref py py-meth docutils literal notranslate"><span class="pre">DatatypeSelector.getTerm()</span></code></a>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">2:</span></code> Term of the codomain Sort of the selector</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Undefined if misapplied.</p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.APPLY_TESTER">
<span class="sig-name descname"><span class="pre">APPLY_TESTER</span></span><a class="headerlink" href="#cvc5.Kind.APPLY_TESTER" title="Link to this definition"></a></dt>
<dd><p>Datatype tester application.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">2</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Datatype tester Term (see <a class="reference internal" href="datatypeconstructor.html#cvc5.DatatypeConstructor.getTesterTerm" title="cvc5.DatatypeConstructor.getTesterTerm"><code class="xref py py-meth docutils literal notranslate"><span class="pre">DatatypeConstructor.getTesterTerm()</span></code></a>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">2:</span></code> Term of Datatype Sort (DatatypeConstructor must belong to this Datatype Sort)</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.APPLY_UF">
<span class="sig-name descname"><span class="pre">APPLY_UF</span></span><a class="headerlink" href="#cvc5.Kind.APPLY_UF" title="Link to this definition"></a></dt>
<dd><p>Application of an uninterpreted function.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">&gt;</span> <span class="pre">1</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Function Term</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">2..n:</span></code> Function argument instantiation Terms of any first-class Sort</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.APPLY_UPDATER">
<span class="sig-name descname"><span class="pre">APPLY_UPDATER</span></span><a class="headerlink" href="#cvc5.Kind.APPLY_UPDATER" title="Link to this definition"></a></dt>
<dd><p>Datatype update application.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">3</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Datatype updater Term (see <a class="reference internal" href="datatypeselector.html#cvc5.DatatypeSelector.getUpdaterTerm" title="cvc5.DatatypeSelector.getUpdaterTerm"><code class="xref py py-meth docutils literal notranslate"><span class="pre">DatatypeSelector.getUpdaterTerm()</span></code></a>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">2:</span></code> Term of Datatype Sort (DatatypeSelector of the updater must belong to a constructor of this Datatype Sort)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">3:</span></code> Term of the codomain Sort of the selector (the Term to update the field of the datatype term with)</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Does not change the datatype argument if misapplied.</p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.ARCCOSECANT">
<span class="sig-name descname"><span class="pre">ARCCOSECANT</span></span><a class="headerlink" href="#cvc5.Kind.ARCCOSECANT" title="Link to this definition"></a></dt>
<dd><p>Arc cosecant function.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">1</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of Sort Real</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.ARCCOSINE">
<span class="sig-name descname"><span class="pre">ARCCOSINE</span></span><a class="headerlink" href="#cvc5.Kind.ARCCOSINE" title="Link to this definition"></a></dt>
<dd><p>Arc cosine function.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">1</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of Sort Real</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.ARCCOTANGENT">
<span class="sig-name descname"><span class="pre">ARCCOTANGENT</span></span><a class="headerlink" href="#cvc5.Kind.ARCCOTANGENT" title="Link to this definition"></a></dt>
<dd><p>Arc cotangent function.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">1</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of Sort Real</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.ARCSECANT">
<span class="sig-name descname"><span class="pre">ARCSECANT</span></span><a class="headerlink" href="#cvc5.Kind.ARCSECANT" title="Link to this definition"></a></dt>
<dd><p>Arc secant function.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">1</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of Sort Real</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.ARCSINE">
<span class="sig-name descname"><span class="pre">ARCSINE</span></span><a class="headerlink" href="#cvc5.Kind.ARCSINE" title="Link to this definition"></a></dt>
<dd><p>Arc sine function.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">1</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of Sort Real</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.ARCTANGENT">
<span class="sig-name descname"><span class="pre">ARCTANGENT</span></span><a class="headerlink" href="#cvc5.Kind.ARCTANGENT" title="Link to this definition"></a></dt>
<dd><p>Arc tangent function.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">1</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of Sort Real</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.BAG_ALL">
<span class="sig-name descname"><span class="pre">BAG_ALL</span></span><a class="headerlink" href="#cvc5.Kind.BAG_ALL" title="Link to this definition"></a></dt>
<dd><p>Bag all.</p>
<p>This operator checks whether all elements of a bag satisfy a predicate.
(bag.all <span class="math notranslate nohighlight">\(p \; A\)</span>) takes a predicate <span class="math notranslate nohighlight">\(p\)</span> of Sort
<span class="math notranslate nohighlight">\((\rightarrow T \; Bool)\)</span> as a first argument, and a bag <span class="math notranslate nohighlight">\(A\)</span>
of Sort (Bag <span class="math notranslate nohighlight">\(T\)</span>) as a second argument, and returns true iff all
elements of <span class="math notranslate nohighlight">\(A\)</span> satisfy predicate <span class="math notranslate nohighlight">\(p\)</span>.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">2</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of function Sort <span class="math notranslate nohighlight">\((\rightarrow T \; Bool)\)</span></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">2:</span></code> Term of bag Sort (Bag <span class="math notranslate nohighlight">\(T\)</span>)</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
</ul>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This kind is experimental and may be changed or removed in
future versions.</p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.BAG_CARD">
<span class="sig-name descname"><span class="pre">BAG_CARD</span></span><a class="headerlink" href="#cvc5.Kind.BAG_CARD" title="Link to this definition"></a></dt>
<dd><p>Bag cardinality.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">1</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of bag Sort</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This kind is experimental and may be changed or removed in future
versions.</p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.BAG_CHOOSE">
<span class="sig-name descname"><span class="pre">BAG_CHOOSE</span></span><a class="headerlink" href="#cvc5.Kind.BAG_CHOOSE" title="Link to this definition"></a></dt>
<dd><p>Bag choose.</p>
<p>Select an element from a given bag.</p>
<p>For a bag <span class="math notranslate nohighlight">\(A = \{(x,n)\}\)</span> where <span class="math notranslate nohighlight">\(n\)</span> is the multiplicity, then
the term (choose <span class="math notranslate nohighlight">\(A\)</span>) is equivalent to the term <span class="math notranslate nohighlight">\(x\)</span>. For an
empty bag, then it is an arbitrary value. For a bag that contains distinct
elements, it will deterministically return an element in <span class="math notranslate nohighlight">\(A\)</span>.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">1</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of bag Sort</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This kind is experimental and may be changed or removed in future
versions.</p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.BAG_COUNT">
<span class="sig-name descname"><span class="pre">BAG_COUNT</span></span><a class="headerlink" href="#cvc5.Kind.BAG_COUNT" title="Link to this definition"></a></dt>
<dd><p>Bag element multiplicity.</p>
<ul class="simple">
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const Term&amp;, const Term&amp;)</p></li>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.BAG_DIFFERENCE_REMOVE">
<span class="sig-name descname"><span class="pre">BAG_DIFFERENCE_REMOVE</span></span><a class="headerlink" href="#cvc5.Kind.BAG_DIFFERENCE_REMOVE" title="Link to this definition"></a></dt>
<dd><p>Bag difference remove.</p>
<p>Removes shared elements in the two bags.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">2</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1..2:</span></code> Terms of bag Sort</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.BAG_DIFFERENCE_SUBTRACT">
<span class="sig-name descname"><span class="pre">BAG_DIFFERENCE_SUBTRACT</span></span><a class="headerlink" href="#cvc5.Kind.BAG_DIFFERENCE_SUBTRACT" title="Link to this definition"></a></dt>
<dd><p>Bag difference subtract.</p>
<p>Subtracts multiplicities of the second from the first.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">2</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1..2:</span></code> Terms of bag Sort</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.BAG_EMPTY">
<span class="sig-name descname"><span class="pre">BAG_EMPTY</span></span><a class="headerlink" href="#cvc5.Kind.BAG_EMPTY" title="Link to this definition"></a></dt>
<dd><p>Empty bag.</p>
<ul class="simple">
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkEmptyBag(const Sort&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.BAG_FILTER">
<span class="sig-name descname"><span class="pre">BAG_FILTER</span></span><a class="headerlink" href="#cvc5.Kind.BAG_FILTER" title="Link to this definition"></a></dt>
<dd><p>Bag filter.</p>
<p>This operator filters the elements of a bag.
(bag.filter <span class="math notranslate nohighlight">\(p \; B\)</span>) takes a predicate <span class="math notranslate nohighlight">\(p\)</span> of Sort
<span class="math notranslate nohighlight">\((\rightarrow T \; Bool)\)</span> as a first argument, and a bag <span class="math notranslate nohighlight">\(B\)</span>
of Sort (Bag <span class="math notranslate nohighlight">\(T\)</span>) as a second argument, and returns a subbag of Sort
(Bag <span class="math notranslate nohighlight">\(T\)</span>) that includes all elements of <span class="math notranslate nohighlight">\(B\)</span> that satisfy
<span class="math notranslate nohighlight">\(p\)</span> with the same multiplicity.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">2</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of function Sort <span class="math notranslate nohighlight">\((\rightarrow T \; Bool)\)</span></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">2:</span></code> Term of bag Sort (Bag <span class="math notranslate nohighlight">\(T\)</span>)</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
</ul>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This kind is experimental and may be changed or removed in future
versions.</p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.BAG_FOLD">
<span class="sig-name descname"><span class="pre">BAG_FOLD</span></span><a class="headerlink" href="#cvc5.Kind.BAG_FOLD" title="Link to this definition"></a></dt>
<dd><p>Bag fold.</p>
<p>This operator combines elements of a bag into a single value.
(bag.fold <span class="math notranslate nohighlight">\(f \; t \; B\)</span>) folds the elements of bag <span class="math notranslate nohighlight">\(B\)</span>
starting with Term <span class="math notranslate nohighlight">\(t\)</span> and using the combining function <span class="math notranslate nohighlight">\(f\)</span>.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">2</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of function Sort <span class="math notranslate nohighlight">\((\rightarrow S_1 \; S_2 \; S_2)\)</span></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">2:</span></code> Term of Sort <span class="math notranslate nohighlight">\(S_2\)</span> (the initial value)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">3:</span></code> Term of bag Sort (Bag <span class="math notranslate nohighlight">\(S_1\)</span>)</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
</ul>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This kind is experimental and may be changed or removed in future
versions.</p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.BAG_INTER_MIN">
<span class="sig-name descname"><span class="pre">BAG_INTER_MIN</span></span><a class="headerlink" href="#cvc5.Kind.BAG_INTER_MIN" title="Link to this definition"></a></dt>
<dd><p>Bag intersection (min).</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">2</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1..2:</span></code> Terms of bag Sort</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.BAG_MAKE">
<span class="sig-name descname"><span class="pre">BAG_MAKE</span></span><a class="headerlink" href="#cvc5.Kind.BAG_MAKE" title="Link to this definition"></a></dt>
<dd><p>Bag make.</p>
<p>Construct a bag with the given element and given multiplicity.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">2</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of any Sort (the bag element)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">2:</span></code> Term of Sort Int (the multiplicity of the element)</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.BAG_MAP">
<span class="sig-name descname"><span class="pre">BAG_MAP</span></span><a class="headerlink" href="#cvc5.Kind.BAG_MAP" title="Link to this definition"></a></dt>
<dd><p>Bag map.</p>
<p>This operator applies the first argument, a function of
Sort <span class="math notranslate nohighlight">\((\rightarrow S_1 \; S_2)\)</span>, to every element of the second
argument, a set of Sort (Bag <span class="math notranslate nohighlight">\(S_1\)</span>), and returns a set of Sort
(Bag <span class="math notranslate nohighlight">\(S_2\)</span>).</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">2</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of function Sort <span class="math notranslate nohighlight">\((\rightarrow S_1 \; S_2)\)</span></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">2:</span></code> Term of bag Sort (Bag <span class="math notranslate nohighlight">\(S_1\)</span>)</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This kind is experimental and may be changed or removed in future
versions.</p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.BAG_MEMBER">
<span class="sig-name descname"><span class="pre">BAG_MEMBER</span></span><a class="headerlink" href="#cvc5.Kind.BAG_MEMBER" title="Link to this definition"></a></dt>
<dd><p>Bag membership predicate.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">2</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of any Sort (must match the element Sort of the given bag Term)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">2:</span></code> Terms of bag Sort</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.BAG_PARTITION">
<span class="sig-name descname"><span class="pre">BAG_PARTITION</span></span><a class="headerlink" href="#cvc5.Kind.BAG_PARTITION" title="Link to this definition"></a></dt>
<dd><p>Bag partition.</p>
<p>This operator partitions of a bag of elements into disjoint bags.
(bag.partition <span class="math notranslate nohighlight">\(r \; B\)</span>) partitions the elements of bag <span class="math notranslate nohighlight">\(B\)</span>
of type <span class="math notranslate nohighlight">\((Bag \; E)\)</span> based on the equivalence relations <span class="math notranslate nohighlight">\(r\)</span> of
type <span class="math notranslate nohighlight">\((\rightarrow \; E \; E \; Bool)\)</span>.
It returns a bag of bags of type <span class="math notranslate nohighlight">\((Bag \; (Bag \; E))\)</span>.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">2</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of function Sort <span class="math notranslate nohighlight">\((\rightarrow \; E \; E \; Bool)\)</span></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">2:</span></code> Term of bag Sort (Bag <span class="math notranslate nohighlight">\(E\)</span>)</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
</ul>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This kind is experimental and may be changed or removed in future
versions.</p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.BAG_SETOF">
<span class="sig-name descname"><span class="pre">BAG_SETOF</span></span><a class="headerlink" href="#cvc5.Kind.BAG_SETOF" title="Link to this definition"></a></dt>
<dd><p>Bag setof.</p>
<p>Eliminate duplicates in a given bag. The returned bag contains exactly the
same elements in the given bag, but with multiplicity one.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">1</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of bag Sort</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This kind is experimental and may be changed or removed in future
versions.</p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.BAG_SOME">
<span class="sig-name descname"><span class="pre">BAG_SOME</span></span><a class="headerlink" href="#cvc5.Kind.BAG_SOME" title="Link to this definition"></a></dt>
<dd><p>Bag some.</p>
<p>This operator checks whether at least one element of a bag satisfies a predicate.
(bag.some <span class="math notranslate nohighlight">\(p \; A\)</span>) takes a predicate <span class="math notranslate nohighlight">\(p\)</span> of Sort
<span class="math notranslate nohighlight">\((\rightarrow T \; Bool)\)</span> as a first argument, and a bag <span class="math notranslate nohighlight">\(A\)</span>
of Sort (Bag <span class="math notranslate nohighlight">\(T\)</span>) as a second argument, and returns true iff at least
one element of <span class="math notranslate nohighlight">\(A\)</span> satisfies predicate <span class="math notranslate nohighlight">\(p\)</span>.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">2</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of function Sort <span class="math notranslate nohighlight">\((\rightarrow T \; Bool)\)</span></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">2:</span></code> Term of bag Sort (Bag <span class="math notranslate nohighlight">\(T\)</span>)</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
</ul>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This kind is experimental and may be changed or removed in
future versions.</p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.BAG_SUBBAG">
<span class="sig-name descname"><span class="pre">BAG_SUBBAG</span></span><a class="headerlink" href="#cvc5.Kind.BAG_SUBBAG" title="Link to this definition"></a></dt>
<dd><p>Bag inclusion predicate.</p>
<p>Determine if multiplicities of the first bag are less than or equal to
multiplicities of the second bag.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">2</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1..2:</span></code> Terms of bag Sort</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.BAG_UNION_DISJOINT">
<span class="sig-name descname"><span class="pre">BAG_UNION_DISJOINT</span></span><a class="headerlink" href="#cvc5.Kind.BAG_UNION_DISJOINT" title="Link to this definition"></a></dt>
<dd><p>Bag disjoint union (sum).</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">2</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1..2:</span></code> Terms of bag Sort</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.BAG_UNION_MAX">
<span class="sig-name descname"><span class="pre">BAG_UNION_MAX</span></span><a class="headerlink" href="#cvc5.Kind.BAG_UNION_MAX" title="Link to this definition"></a></dt>
<dd><p>Bag max union.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">2</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1..2:</span></code> Terms of bag Sort</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.BITVECTOR_ADD">
<span class="sig-name descname"><span class="pre">BITVECTOR_ADD</span></span><a class="headerlink" href="#cvc5.Kind.BITVECTOR_ADD" title="Link to this definition"></a></dt>
<dd><p>Addition of two or more bit-vectors.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">&gt;</span> <span class="pre">1</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1..n:</span></code> Terms of bit-vector Sort (sorts must match)</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.BITVECTOR_AND">
<span class="sig-name descname"><span class="pre">BITVECTOR_AND</span></span><a class="headerlink" href="#cvc5.Kind.BITVECTOR_AND" title="Link to this definition"></a></dt>
<dd><p>Bit-wise and.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">&gt;</span> <span class="pre">1</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1..n:</span></code> Terms of bit-vector Sort (sorts must match)</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.BITVECTOR_ASHR">
<span class="sig-name descname"><span class="pre">BITVECTOR_ASHR</span></span><a class="headerlink" href="#cvc5.Kind.BITVECTOR_ASHR" title="Link to this definition"></a></dt>
<dd><p>Bit-vector arithmetic shift right.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">2</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1..2:</span></code> Terms of bit-vector Sort (sorts must match)</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.BITVECTOR_BIT">
<span class="sig-name descname"><span class="pre">BITVECTOR_BIT</span></span><a class="headerlink" href="#cvc5.Kind.BITVECTOR_BIT" title="Link to this definition"></a></dt>
<dd><p>Retrieves the bit at the given index from a bit-vector as a Bool term.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">1</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of bit-vector Sort</p></li>
</ul>
</li>
<li><p>Indices: <code class="docutils literal notranslate"><span class="pre">1</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> The bit index</p></li>
</ul>
</li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>May be returned as the result of an API call, but terms of this kind
may not be created explicitly via the API and may not appear in
assertions.</p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.BITVECTOR_COMP">
<span class="sig-name descname"><span class="pre">BITVECTOR_COMP</span></span><a class="headerlink" href="#cvc5.Kind.BITVECTOR_COMP" title="Link to this definition"></a></dt>
<dd><p>Equality comparison (returns bit-vector of size <code class="docutils literal notranslate"><span class="pre">1</span></code>).</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">2</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1..2:</span></code> Terms of bit-vector Sort (sorts must match)</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.BITVECTOR_CONCAT">
<span class="sig-name descname"><span class="pre">BITVECTOR_CONCAT</span></span><a class="headerlink" href="#cvc5.Kind.BITVECTOR_CONCAT" title="Link to this definition"></a></dt>
<dd><p>Concatenation of two or more bit-vectors.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">&gt;</span> <span class="pre">1</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1..n:</span></code> Terms of bit-vector Sort (sorts must match)</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.BITVECTOR_EXTRACT">
<span class="sig-name descname"><span class="pre">BITVECTOR_EXTRACT</span></span><a class="headerlink" href="#cvc5.Kind.BITVECTOR_EXTRACT" title="Link to this definition"></a></dt>
<dd><p>Bit-vector extract.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">1</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of bit-vector Sort</p></li>
</ul>
</li>
<li><p>Indices: <code class="docutils literal notranslate"><span class="pre">2</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> The upper bit index.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">2:</span></code> The lower bit index.</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.BITVECTOR_FROM_BOOLS">
<span class="sig-name descname"><span class="pre">BITVECTOR_FROM_BOOLS</span></span><a class="headerlink" href="#cvc5.Kind.BITVECTOR_FROM_BOOLS" title="Link to this definition"></a></dt>
<dd><p>Converts a list of Bool terms to a bit-vector.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">&gt;</span> <span class="pre">0</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1..n:</span></code> Terms of Sort Bool</p></li>
</ul>
</li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>May be returned as the result of an API call, but terms of this kind
may not be created explicitly via the API and may not appear in
assertions.</p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.BITVECTOR_ITE">
<span class="sig-name descname"><span class="pre">BITVECTOR_ITE</span></span><a class="headerlink" href="#cvc5.Kind.BITVECTOR_ITE" title="Link to this definition"></a></dt>
<dd><p>Bit-vector if-then-else.</p>
<p>Same semantics as regular ITE, but condition is bit-vector of size <code class="docutils literal notranslate"><span class="pre">1</span></code>.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">3</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of bit-vector Sort of size <cite>1</cite></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">1..3:</span></code> Terms of bit-vector sort (sorts must match)</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.BITVECTOR_LSHR">
<span class="sig-name descname"><span class="pre">BITVECTOR_LSHR</span></span><a class="headerlink" href="#cvc5.Kind.BITVECTOR_LSHR" title="Link to this definition"></a></dt>
<dd><p>Bit-vector logical shift right.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">2</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1..2:</span></code> Terms of bit-vector Sort (sorts must match)</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.BITVECTOR_MULT">
<span class="sig-name descname"><span class="pre">BITVECTOR_MULT</span></span><a class="headerlink" href="#cvc5.Kind.BITVECTOR_MULT" title="Link to this definition"></a></dt>
<dd><p>Multiplication of two or more bit-vectors.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">&gt;</span> <span class="pre">1</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1..n:</span></code> Terms of bit-vector Sort (sorts must match)</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.BITVECTOR_NAND">
<span class="sig-name descname"><span class="pre">BITVECTOR_NAND</span></span><a class="headerlink" href="#cvc5.Kind.BITVECTOR_NAND" title="Link to this definition"></a></dt>
<dd><p>Bit-wise nand.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">2</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1..2:</span></code> Terms of bit-vector Sort (sorts must match)</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.BITVECTOR_NEG">
<span class="sig-name descname"><span class="pre">BITVECTOR_NEG</span></span><a class="headerlink" href="#cvc5.Kind.BITVECTOR_NEG" title="Link to this definition"></a></dt>
<dd><p>Negation of a bit-vector (two’s complement).</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">1</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of bit-vector Sort</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.BITVECTOR_NEGO">
<span class="sig-name descname"><span class="pre">BITVECTOR_NEGO</span></span><a class="headerlink" href="#cvc5.Kind.BITVECTOR_NEGO" title="Link to this definition"></a></dt>
<dd><p>Bit-vector negation overflow detection.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">1</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of bit-vector Sort</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.BITVECTOR_NOR">
<span class="sig-name descname"><span class="pre">BITVECTOR_NOR</span></span><a class="headerlink" href="#cvc5.Kind.BITVECTOR_NOR" title="Link to this definition"></a></dt>
<dd><p>Bit-wise nor.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">2</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1..2:</span></code> Terms of bit-vector Sort (sorts must match)</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.BITVECTOR_NOT">
<span class="sig-name descname"><span class="pre">BITVECTOR_NOT</span></span><a class="headerlink" href="#cvc5.Kind.BITVECTOR_NOT" title="Link to this definition"></a></dt>
<dd><p>Bit-wise negation.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">1</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of bit-vector Sort</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.BITVECTOR_OR">
<span class="sig-name descname"><span class="pre">BITVECTOR_OR</span></span><a class="headerlink" href="#cvc5.Kind.BITVECTOR_OR" title="Link to this definition"></a></dt>
<dd><p>Bit-wise or.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">&gt;</span> <span class="pre">1</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1..n:</span></code> Terms of bit-vector Sort (sorts must match)</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.BITVECTOR_REDAND">
<span class="sig-name descname"><span class="pre">BITVECTOR_REDAND</span></span><a class="headerlink" href="#cvc5.Kind.BITVECTOR_REDAND" title="Link to this definition"></a></dt>
<dd><p>Bit-vector redand.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">1</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of bit-vector Sort</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.BITVECTOR_REDOR">
<span class="sig-name descname"><span class="pre">BITVECTOR_REDOR</span></span><a class="headerlink" href="#cvc5.Kind.BITVECTOR_REDOR" title="Link to this definition"></a></dt>
<dd><p>Bit-vector redor.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">1</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of bit-vector Sort</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.BITVECTOR_REPEAT">
<span class="sig-name descname"><span class="pre">BITVECTOR_REPEAT</span></span><a class="headerlink" href="#cvc5.Kind.BITVECTOR_REPEAT" title="Link to this definition"></a></dt>
<dd><p>Bit-vector repeat.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">1</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of bit-vector Sort</p></li>
</ul>
</li>
<li><p>Indices: <code class="docutils literal notranslate"><span class="pre">1</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> The number of times to repeat the given term.</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.BITVECTOR_ROTATE_LEFT">
<span class="sig-name descname"><span class="pre">BITVECTOR_ROTATE_LEFT</span></span><a class="headerlink" href="#cvc5.Kind.BITVECTOR_ROTATE_LEFT" title="Link to this definition"></a></dt>
<dd><p>Bit-vector rotate left.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">1</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of bit-vector Sort</p></li>
</ul>
</li>
<li><p>Indices: <code class="docutils literal notranslate"><span class="pre">1</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> The number of bits to rotate the given term left.</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.BITVECTOR_ROTATE_RIGHT">
<span class="sig-name descname"><span class="pre">BITVECTOR_ROTATE_RIGHT</span></span><a class="headerlink" href="#cvc5.Kind.BITVECTOR_ROTATE_RIGHT" title="Link to this definition"></a></dt>
<dd><p>Bit-vector rotate right.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">1</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of bit-vector Sort</p></li>
</ul>
</li>
<li><p>Indices: <code class="docutils literal notranslate"><span class="pre">1</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> The number of bits to rotate the given term right.</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.BITVECTOR_SADDO">
<span class="sig-name descname"><span class="pre">BITVECTOR_SADDO</span></span><a class="headerlink" href="#cvc5.Kind.BITVECTOR_SADDO" title="Link to this definition"></a></dt>
<dd><p>Bit-vector signed addition overflow detection.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">2</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1..2:</span></code> Terms of bit-vector Sort (sorts must match)</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.BITVECTOR_SBV_TO_INT">
<span class="sig-name descname"><span class="pre">BITVECTOR_SBV_TO_INT</span></span><a class="headerlink" href="#cvc5.Kind.BITVECTOR_SBV_TO_INT" title="Link to this definition"></a></dt>
<dd><p>Bit-vector conversion, signed bit-vector to integer.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">1</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of bit-vector Sort</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.BITVECTOR_SDIV">
<span class="sig-name descname"><span class="pre">BITVECTOR_SDIV</span></span><a class="headerlink" href="#cvc5.Kind.BITVECTOR_SDIV" title="Link to this definition"></a></dt>
<dd><p>Signed bit-vector division.</p>
<p>Two’s complement signed division of two bit-vectors. If the divisor is
zero and the dividend is positive, the result is all ones. If the divisor
is zero and the dividend is negative, the result is one.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">2</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1..2:</span></code> Terms of bit-vector Sort (sorts must match)</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.BITVECTOR_SDIVO">
<span class="sig-name descname"><span class="pre">BITVECTOR_SDIVO</span></span><a class="headerlink" href="#cvc5.Kind.BITVECTOR_SDIVO" title="Link to this definition"></a></dt>
<dd><p>Bit-vector signed division overflow detection.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">2</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1..2:</span></code> Terms of bit-vector Sort (sorts must match)</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.BITVECTOR_SGE">
<span class="sig-name descname"><span class="pre">BITVECTOR_SGE</span></span><a class="headerlink" href="#cvc5.Kind.BITVECTOR_SGE" title="Link to this definition"></a></dt>
<dd><p>Bit-vector signed greater than or equal.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">2</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1..2:</span></code> Terms of bit-vector Sort (sorts must match)</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.BITVECTOR_SGT">
<span class="sig-name descname"><span class="pre">BITVECTOR_SGT</span></span><a class="headerlink" href="#cvc5.Kind.BITVECTOR_SGT" title="Link to this definition"></a></dt>
<dd><p>Bit-vector signed greater than.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">2</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1..2:</span></code> Terms of bit-vector Sort (sorts must match)</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.BITVECTOR_SHL">
<span class="sig-name descname"><span class="pre">BITVECTOR_SHL</span></span><a class="headerlink" href="#cvc5.Kind.BITVECTOR_SHL" title="Link to this definition"></a></dt>
<dd><p>Bit-vector shift left.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">2</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1..2:</span></code> Terms of bit-vector Sort (sorts must match)</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.BITVECTOR_SIGN_EXTEND">
<span class="sig-name descname"><span class="pre">BITVECTOR_SIGN_EXTEND</span></span><a class="headerlink" href="#cvc5.Kind.BITVECTOR_SIGN_EXTEND" title="Link to this definition"></a></dt>
<dd><p>Bit-vector sign extension.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">1</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of bit-vector Sort</p></li>
</ul>
</li>
<li><p>Indices: <code class="docutils literal notranslate"><span class="pre">1</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> The number of bits (of the value of the sign bit) to extend the given term with.</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.BITVECTOR_SLE">
<span class="sig-name descname"><span class="pre">BITVECTOR_SLE</span></span><a class="headerlink" href="#cvc5.Kind.BITVECTOR_SLE" title="Link to this definition"></a></dt>
<dd><p>Bit-vector signed less than or equal.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">2</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1..2:</span></code> Terms of bit-vector Sort (sorts must match)</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.BITVECTOR_SLT">
<span class="sig-name descname"><span class="pre">BITVECTOR_SLT</span></span><a class="headerlink" href="#cvc5.Kind.BITVECTOR_SLT" title="Link to this definition"></a></dt>
<dd><p>Bit-vector signed less than.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">2</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1..2:</span></code> Terms of bit-vector Sort (sorts must match)</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.BITVECTOR_SLTBV">
<span class="sig-name descname"><span class="pre">BITVECTOR_SLTBV</span></span><a class="headerlink" href="#cvc5.Kind.BITVECTOR_SLTBV" title="Link to this definition"></a></dt>
<dd><p>Bit-vector signed less than returning a bit-vector of size <code class="docutils literal notranslate"><span class="pre">1</span></code>.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">2</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1..2:</span></code> Terms of bit-vector Sort (sorts must match)</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.BITVECTOR_SMOD">
<span class="sig-name descname"><span class="pre">BITVECTOR_SMOD</span></span><a class="headerlink" href="#cvc5.Kind.BITVECTOR_SMOD" title="Link to this definition"></a></dt>
<dd><p>Signed bit-vector remainder (sign follows divisor).</p>
<p>Two’s complement signed remainder where the sign follows the divisor. If
the modulus is zero, the result is the dividend.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">2</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1..2:</span></code> Terms of bit-vector Sort (sorts must match)</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.BITVECTOR_SMULO">
<span class="sig-name descname"><span class="pre">BITVECTOR_SMULO</span></span><a class="headerlink" href="#cvc5.Kind.BITVECTOR_SMULO" title="Link to this definition"></a></dt>
<dd><p>Bit-vector signed multiplication overflow detection.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">2</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1..2:</span></code> Terms of bit-vector Sort (sorts must match)</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.BITVECTOR_SREM">
<span class="sig-name descname"><span class="pre">BITVECTOR_SREM</span></span><a class="headerlink" href="#cvc5.Kind.BITVECTOR_SREM" title="Link to this definition"></a></dt>
<dd><p>Signed bit-vector remainder (sign follows dividend).</p>
<p>Two’s complement signed remainder of two bit-vectors where the sign
follows the dividend. If the modulus is zero, the result is the dividend.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">2</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1..2:</span></code> Terms of bit-vector Sort (sorts must match)</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.BITVECTOR_SSUBO">
<span class="sig-name descname"><span class="pre">BITVECTOR_SSUBO</span></span><a class="headerlink" href="#cvc5.Kind.BITVECTOR_SSUBO" title="Link to this definition"></a></dt>
<dd><p>Bit-vector signed subtraction overflow detection.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">2</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1..2:</span></code> Terms of bit-vector Sort (sorts must match)</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.BITVECTOR_SUB">
<span class="sig-name descname"><span class="pre">BITVECTOR_SUB</span></span><a class="headerlink" href="#cvc5.Kind.BITVECTOR_SUB" title="Link to this definition"></a></dt>
<dd><p>Subtraction of two bit-vectors.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">&gt;</span> <span class="pre">1</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1..n:</span></code> Terms of bit-vector Sort (sorts must match)</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.BITVECTOR_TO_NAT">
<span class="sig-name descname"><span class="pre">BITVECTOR_TO_NAT</span></span><a class="headerlink" href="#cvc5.Kind.BITVECTOR_TO_NAT" title="Link to this definition"></a></dt>
<dd><p>Bit-vector conversion to (non-negative) integer.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">1</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of bit-vector Sort</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This kind is deprecated and replaced by
<cite>BITVECTOR_UBV_TO_INT</cite>. It will be removed in a future
release.</p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.BITVECTOR_UADDO">
<span class="sig-name descname"><span class="pre">BITVECTOR_UADDO</span></span><a class="headerlink" href="#cvc5.Kind.BITVECTOR_UADDO" title="Link to this definition"></a></dt>
<dd><p>Bit-vector unsigned addition overflow detection.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">2</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1..2:</span></code> Terms of bit-vector Sort (sorts must match)</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.BITVECTOR_UBV_TO_INT">
<span class="sig-name descname"><span class="pre">BITVECTOR_UBV_TO_INT</span></span><a class="headerlink" href="#cvc5.Kind.BITVECTOR_UBV_TO_INT" title="Link to this definition"></a></dt>
<dd><p>Bit-vector conversion, unsigned bit-vector to integer.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">1</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of bit-vector Sort</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.BITVECTOR_UDIV">
<span class="sig-name descname"><span class="pre">BITVECTOR_UDIV</span></span><a class="headerlink" href="#cvc5.Kind.BITVECTOR_UDIV" title="Link to this definition"></a></dt>
<dd><p>Unsigned bit-vector division.</p>
<p>Truncates towards <code class="docutils literal notranslate"><span class="pre">0</span></code>. If the divisor is zero, the result is all ones.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">2</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1..2:</span></code> Terms of bit-vector Sort (sorts must match)</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.BITVECTOR_UGE">
<span class="sig-name descname"><span class="pre">BITVECTOR_UGE</span></span><a class="headerlink" href="#cvc5.Kind.BITVECTOR_UGE" title="Link to this definition"></a></dt>
<dd><p>Bit-vector unsigned greater than or equal.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">2</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1..2:</span></code> Terms of bit-vector Sort (sorts must match)</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.BITVECTOR_UGT">
<span class="sig-name descname"><span class="pre">BITVECTOR_UGT</span></span><a class="headerlink" href="#cvc5.Kind.BITVECTOR_UGT" title="Link to this definition"></a></dt>
<dd><p>Bit-vector unsigned greater than.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">2</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1..2:</span></code> Terms of bit-vector Sort (sorts must match)</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.BITVECTOR_ULE">
<span class="sig-name descname"><span class="pre">BITVECTOR_ULE</span></span><a class="headerlink" href="#cvc5.Kind.BITVECTOR_ULE" title="Link to this definition"></a></dt>
<dd><p>Bit-vector unsigned less than or equal.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">2</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1..2:</span></code> Terms of bit-vector Sort (sorts must match)</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.BITVECTOR_ULT">
<span class="sig-name descname"><span class="pre">BITVECTOR_ULT</span></span><a class="headerlink" href="#cvc5.Kind.BITVECTOR_ULT" title="Link to this definition"></a></dt>
<dd><p>Bit-vector unsigned less than.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">2</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1..2:</span></code> Terms of bit-vector Sort (sorts must match)</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.BITVECTOR_ULTBV">
<span class="sig-name descname"><span class="pre">BITVECTOR_ULTBV</span></span><a class="headerlink" href="#cvc5.Kind.BITVECTOR_ULTBV" title="Link to this definition"></a></dt>
<dd><p>Bit-vector unsigned less than returning a bit-vector of size 1.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">2</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1..2:</span></code> Terms of bit-vector Sort (sorts must match)</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.BITVECTOR_UMULO">
<span class="sig-name descname"><span class="pre">BITVECTOR_UMULO</span></span><a class="headerlink" href="#cvc5.Kind.BITVECTOR_UMULO" title="Link to this definition"></a></dt>
<dd><p>Bit-vector unsigned multiplication overflow detection.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">2</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1..2:</span></code> Terms of bit-vector Sort (sorts must match)</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.BITVECTOR_UREM">
<span class="sig-name descname"><span class="pre">BITVECTOR_UREM</span></span><a class="headerlink" href="#cvc5.Kind.BITVECTOR_UREM" title="Link to this definition"></a></dt>
<dd><p>Unsigned bit-vector remainder.</p>
<p>Remainder from unsigned bit-vector division. If the modulus is zero, the
result is the dividend.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">2</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1..2:</span></code> Terms of bit-vector Sort (sorts must match)</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.BITVECTOR_USUBO">
<span class="sig-name descname"><span class="pre">BITVECTOR_USUBO</span></span><a class="headerlink" href="#cvc5.Kind.BITVECTOR_USUBO" title="Link to this definition"></a></dt>
<dd><p>Bit-vector unsigned subtraction overflow detection.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">2</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1..2:</span></code> Terms of bit-vector Sort (sorts must match)</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.BITVECTOR_XNOR">
<span class="sig-name descname"><span class="pre">BITVECTOR_XNOR</span></span><a class="headerlink" href="#cvc5.Kind.BITVECTOR_XNOR" title="Link to this definition"></a></dt>
<dd><p>Bit-wise xnor, left associative.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">2</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1..2:</span></code> Terms of bit-vector Sort (sorts must match)</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.BITVECTOR_XOR">
<span class="sig-name descname"><span class="pre">BITVECTOR_XOR</span></span><a class="headerlink" href="#cvc5.Kind.BITVECTOR_XOR" title="Link to this definition"></a></dt>
<dd><p>Bit-wise xor.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">&gt;</span> <span class="pre">1</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1..n:</span></code> Terms of bit-vector Sort (sorts must match)</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.BITVECTOR_ZERO_EXTEND">
<span class="sig-name descname"><span class="pre">BITVECTOR_ZERO_EXTEND</span></span><a class="headerlink" href="#cvc5.Kind.BITVECTOR_ZERO_EXTEND" title="Link to this definition"></a></dt>
<dd><p>Bit-vector zero extension.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">1</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of bit-vector Sort</p></li>
</ul>
</li>
<li><p>Indices: <code class="docutils literal notranslate"><span class="pre">1</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> The number of zeroes to extend the given term with.</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.CARDINALITY_CONSTRAINT">
<span class="sig-name descname"><span class="pre">CARDINALITY_CONSTRAINT</span></span><a class="headerlink" href="#cvc5.Kind.CARDINALITY_CONSTRAINT" title="Link to this definition"></a></dt>
<dd><p>Cardinality constraint on uninterpreted sort.</p>
<p>Interpreted as a predicate that is true when the cardinality of
uinterpreted Sort <span class="math notranslate nohighlight">\(S\)</span> is less than or equal to an upper bound.</p>
<ul class="simple">
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkCardinalityConstraint(const Sort&amp;, uint32_t)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.CONSTANT">
<span class="sig-name descname"><span class="pre">CONSTANT</span></span><a class="headerlink" href="#cvc5.Kind.CONSTANT" title="Link to this definition"></a></dt>
<dd><p>Free constant symbol.</p>
<ul class="simple">
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkConst(const Sort&amp;, const std::optional&lt;std::string&gt;&amp;)</p></li>
</ul>
</li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Not permitted in bindings (e.g., <a class="reference internal" href="#cvc5.Kind.FORALL" title="cvc5.Kind.FORALL"><code class="xref py py-obj docutils literal notranslate"><span class="pre">FORALL</span></code></a>,
<a class="reference internal" href="#cvc5.Kind.EXISTS" title="cvc5.Kind.EXISTS"><code class="xref py py-obj docutils literal notranslate"><span class="pre">EXISTS</span></code></a>).</p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.CONST_ARRAY">
<span class="sig-name descname"><span class="pre">CONST_ARRAY</span></span><a class="headerlink" href="#cvc5.Kind.CONST_ARRAY" title="Link to this definition"></a></dt>
<dd><p>Constant array.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">2</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of array Sort</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">2:</span></code> Term of array element Sort (value)</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.CONST_BITVECTOR">
<span class="sig-name descname"><span class="pre">CONST_BITVECTOR</span></span><a class="headerlink" href="#cvc5.Kind.CONST_BITVECTOR" title="Link to this definition"></a></dt>
<dd><p>Fixed-size bit-vector constant.</p>
<ul class="simple">
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkBitVector(uint32_t, uint64_t)</p></li>
<li><p>TermManager::mkBitVector(uint32_t, const std::string&amp;, uint32_t)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.CONST_BOOLEAN">
<span class="sig-name descname"><span class="pre">CONST_BOOLEAN</span></span><a class="headerlink" href="#cvc5.Kind.CONST_BOOLEAN" title="Link to this definition"></a></dt>
<dd><p>Boolean constant.</p>
<ul class="simple">
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTrue()</p></li>
<li><p>TermManager::mkFalse()</p></li>
<li><p>TermManager::mkBoolean(bool)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.CONST_FINITE_FIELD">
<span class="sig-name descname"><span class="pre">CONST_FINITE_FIELD</span></span><a class="headerlink" href="#cvc5.Kind.CONST_FINITE_FIELD" title="Link to this definition"></a></dt>
<dd><p>Finite field constant.</p>
<ul class="simple">
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkFiniteFieldElem(const std::string&amp;, const Sort&amp;, uint32_t base)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.CONST_FLOATINGPOINT">
<span class="sig-name descname"><span class="pre">CONST_FLOATINGPOINT</span></span><a class="headerlink" href="#cvc5.Kind.CONST_FLOATINGPOINT" title="Link to this definition"></a></dt>
<dd><p>Floating-point constant, created from IEEE-754 bit-vector representation
of the floating-point value.</p>
<ul class="simple">
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkFloatingPoint(uint32_t, uint32_t, Term)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.CONST_INTEGER">
<span class="sig-name descname"><span class="pre">CONST_INTEGER</span></span><a class="headerlink" href="#cvc5.Kind.CONST_INTEGER" title="Link to this definition"></a></dt>
<dd><p>Arbitrary-precision integer constant.</p>
<ul class="simple">
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkInteger(const std::string&amp;)</p></li>
<li><p>TermManager::mkInteger(int64_t)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.CONST_RATIONAL">
<span class="sig-name descname"><span class="pre">CONST_RATIONAL</span></span><a class="headerlink" href="#cvc5.Kind.CONST_RATIONAL" title="Link to this definition"></a></dt>
<dd><p>Arbitrary-precision rational constant.</p>
<ul class="simple">
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkReal(const std::string&amp;)</p></li>
<li><p>TermManager::mkReal(int64_t)</p></li>
<li><p>TermManager::mkReal(int64_t, int64_t)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.CONST_ROUNDINGMODE">
<span class="sig-name descname"><span class="pre">CONST_ROUNDINGMODE</span></span><a class="headerlink" href="#cvc5.Kind.CONST_ROUNDINGMODE" title="Link to this definition"></a></dt>
<dd><p>RoundingMode constant.</p>
<ul class="simple">
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkRoundingMode(RoundingMode)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.CONST_SEQUENCE">
<span class="sig-name descname"><span class="pre">CONST_SEQUENCE</span></span><a class="headerlink" href="#cvc5.Kind.CONST_SEQUENCE" title="Link to this definition"></a></dt>
<dd><p>Constant sequence.</p>
<p>A constant sequence is a term that is equivalent to:</p>
<div class="highlight-smtlib notranslate"><div class="highlight"><pre><span></span>(<span class="o">seq.++</span> (<span class="o">seq.unit</span> <span class="n">c1</span>) <span class="n">...</span> (<span class="o">seq.unit</span> <span class="n">cn</span>))
</pre></div>
</div>
<p>where <span class="math notranslate nohighlight">\(n \leq 0\)</span> and <span class="math notranslate nohighlight">\(c_1, ..., c_n\)</span> are constants of some
sort. The elements can be extracted with <a class="reference internal" href="term.html#cvc5.Term.getSequenceValue" title="cvc5.Term.getSequenceValue"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Term.getSequenceValue()</span></code></a>.</p>
<ul class="simple">
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkEmptySequence(const Sort&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.CONST_STRING">
<span class="sig-name descname"><span class="pre">CONST_STRING</span></span><a class="headerlink" href="#cvc5.Kind.CONST_STRING" title="Link to this definition"></a></dt>
<dd><p>Constant string.</p>
<ul class="simple">
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkString(const std::string&amp;, bool)</p></li>
<li><p>TermManager::mkString(const std::u32string&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.COSECANT">
<span class="sig-name descname"><span class="pre">COSECANT</span></span><a class="headerlink" href="#cvc5.Kind.COSECANT" title="Link to this definition"></a></dt>
<dd><p>Cosecant function.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">1</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of Sort Real</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.COSINE">
<span class="sig-name descname"><span class="pre">COSINE</span></span><a class="headerlink" href="#cvc5.Kind.COSINE" title="Link to this definition"></a></dt>
<dd><p>Cosine function.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">1</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of Sort Real</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.COTANGENT">
<span class="sig-name descname"><span class="pre">COTANGENT</span></span><a class="headerlink" href="#cvc5.Kind.COTANGENT" title="Link to this definition"></a></dt>
<dd><p>Cotangent function.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">1</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of Sort Real</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.DISTINCT">
<span class="sig-name descname"><span class="pre">DISTINCT</span></span><a class="headerlink" href="#cvc5.Kind.DISTINCT" title="Link to this definition"></a></dt>
<dd><p>Disequality.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">&gt;</span> <span class="pre">1</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1..n:</span></code> Terms of the same Sort</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.DIVISIBLE">
<span class="sig-name descname"><span class="pre">DIVISIBLE</span></span><a class="headerlink" href="#cvc5.Kind.DIVISIBLE" title="Link to this definition"></a></dt>
<dd><p>Operator for the divisibility-by-<span class="math notranslate nohighlight">\(k\)</span> predicate.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">1</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of Sort Int</p></li>
</ul>
</li>
<li><p>Indices: <code class="docutils literal notranslate"><span class="pre">1</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> The integer <span class="math notranslate nohighlight">\(k\)</span> to divide by.</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.DIVISION">
<span class="sig-name descname"><span class="pre">DIVISION</span></span><a class="headerlink" href="#cvc5.Kind.DIVISION" title="Link to this definition"></a></dt>
<dd><p>Real division, division by 0 undefined, left associative.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">&gt;</span> <span class="pre">1</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1..n:</span></code> Terms of Sort Real</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.DIVISION_TOTAL">
<span class="sig-name descname"><span class="pre">DIVISION_TOTAL</span></span><a class="headerlink" href="#cvc5.Kind.DIVISION_TOTAL" title="Link to this definition"></a></dt>
<dd><p>Real division, division by 0 defined to be 0, left associative.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">&gt;</span> <span class="pre">1</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1..n:</span></code> Terms of Sort Real</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This kind is experimental and may be changed or removed in future
versions.</p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.EQUAL">
<span class="sig-name descname"><span class="pre">EQUAL</span></span><a class="headerlink" href="#cvc5.Kind.EQUAL" title="Link to this definition"></a></dt>
<dd><p>Equality, chainable.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">&gt;</span> <span class="pre">1</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1..n:</span></code> Terms of the same Sort</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.EQ_RANGE">
<span class="sig-name descname"><span class="pre">EQ_RANGE</span></span><a class="headerlink" href="#cvc5.Kind.EQ_RANGE" title="Link to this definition"></a></dt>
<dd><p>Equality over arrays <span class="math notranslate nohighlight">\(a\)</span> and <span class="math notranslate nohighlight">\(b\)</span> over a given range
<span class="math notranslate nohighlight">\([i,j]\)</span>, i.e.,</p>
<div class="math notranslate nohighlight">
\[\forall k . i \leq k \leq j \Rightarrow a[k] = b[k]\]</div>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">4</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of array Sort (first array)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">2:</span></code> Term of array Sort (second array)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">3:</span></code> Term of array index Sort (lower bound of range, inclusive)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">4:</span></code> Term of array index Sort (upper bound of range, inclusive)</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This kind is experimental and may be changed or removed in future
versions.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>We currently support the creation of array equalities over index Sorts
bit-vector, floating-point, Int and Real. Requires to enable option
<a class="reference internal" href="../../../options.html#lbl-option-arrays-exp"><span class="std std-ref">arrays-exp</span></a>.</p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.EXISTS">
<span class="sig-name descname"><span class="pre">EXISTS</span></span><a class="headerlink" href="#cvc5.Kind.EXISTS" title="Link to this definition"></a></dt>
<dd><p>Existentially quantified formula.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">3</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of Kind <a class="reference internal" href="#cvc5.Kind.VARIABLE_LIST" title="cvc5.Kind.VARIABLE_LIST"><code class="xref py py-obj docutils literal notranslate"><span class="pre">VARIABLE_LIST</span></code></a></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">2:</span></code> Term of Sort Bool (the quantifier body)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">3:</span></code> (optional) Term of Kind <a class="reference internal" href="#cvc5.Kind.INST_PATTERN" title="cvc5.Kind.INST_PATTERN"><code class="xref py py-obj docutils literal notranslate"><span class="pre">INST_PATTERN</span></code></a></p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.EXPONENTIAL">
<span class="sig-name descname"><span class="pre">EXPONENTIAL</span></span><a class="headerlink" href="#cvc5.Kind.EXPONENTIAL" title="Link to this definition"></a></dt>
<dd><p>Exponential function.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">1</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of Sort Real</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.FINITE_FIELD_ADD">
<span class="sig-name descname"><span class="pre">FINITE_FIELD_ADD</span></span><a class="headerlink" href="#cvc5.Kind.FINITE_FIELD_ADD" title="Link to this definition"></a></dt>
<dd><p>Addition of two or more finite field elements.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">&gt;</span> <span class="pre">1</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1..n:</span></code> Terms of finite field Sort (sorts must match)</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.FINITE_FIELD_BITSUM">
<span class="sig-name descname"><span class="pre">FINITE_FIELD_BITSUM</span></span><a class="headerlink" href="#cvc5.Kind.FINITE_FIELD_BITSUM" title="Link to this definition"></a></dt>
<dd><p>Bitsum of two or more finite field elements: x + 2y + 4z + …</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">&gt;</span> <span class="pre">1</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1..n:</span></code> Terms of finite field Sort (sorts must match)</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.FINITE_FIELD_MULT">
<span class="sig-name descname"><span class="pre">FINITE_FIELD_MULT</span></span><a class="headerlink" href="#cvc5.Kind.FINITE_FIELD_MULT" title="Link to this definition"></a></dt>
<dd><p>Multiplication of two or more finite field elements.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">&gt;</span> <span class="pre">1</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1..n:</span></code> Terms of finite field Sort (sorts must match)</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.FINITE_FIELD_NEG">
<span class="sig-name descname"><span class="pre">FINITE_FIELD_NEG</span></span><a class="headerlink" href="#cvc5.Kind.FINITE_FIELD_NEG" title="Link to this definition"></a></dt>
<dd><p>Negation of a finite field element (additive inverse).</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">1</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of finite field Sort</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.FLOATINGPOINT_ABS">
<span class="sig-name descname"><span class="pre">FLOATINGPOINT_ABS</span></span><a class="headerlink" href="#cvc5.Kind.FLOATINGPOINT_ABS" title="Link to this definition"></a></dt>
<dd><p>Floating-point absolute value.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">1</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of floating-point Sort</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.FLOATINGPOINT_ADD">
<span class="sig-name descname"><span class="pre">FLOATINGPOINT_ADD</span></span><a class="headerlink" href="#cvc5.Kind.FLOATINGPOINT_ADD" title="Link to this definition"></a></dt>
<dd><p>Floating-point addition.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">3</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of Sort RoundingMode</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">2..3:</span></code> Terms of floating-point Sort (sorts must match)</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.FLOATINGPOINT_DIV">
<span class="sig-name descname"><span class="pre">FLOATINGPOINT_DIV</span></span><a class="headerlink" href="#cvc5.Kind.FLOATINGPOINT_DIV" title="Link to this definition"></a></dt>
<dd><p>Floating-point division.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">3</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of Sort RoundingMode</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">2..3:</span></code> Terms of floating-point Sort (sorts must match)</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.FLOATINGPOINT_EQ">
<span class="sig-name descname"><span class="pre">FLOATINGPOINT_EQ</span></span><a class="headerlink" href="#cvc5.Kind.FLOATINGPOINT_EQ" title="Link to this definition"></a></dt>
<dd><p>Floating-point equality.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">2</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1..2:</span></code> Terms of floating-point Sort (sorts must match)</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.FLOATINGPOINT_FMA">
<span class="sig-name descname"><span class="pre">FLOATINGPOINT_FMA</span></span><a class="headerlink" href="#cvc5.Kind.FLOATINGPOINT_FMA" title="Link to this definition"></a></dt>
<dd><p>Floating-point fused multiply and add.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">4</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of Sort RoundingMode</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">2..4:</span></code> Terms of floating-point Sort (sorts must match)</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.FLOATINGPOINT_FP">
<span class="sig-name descname"><span class="pre">FLOATINGPOINT_FP</span></span><a class="headerlink" href="#cvc5.Kind.FLOATINGPOINT_FP" title="Link to this definition"></a></dt>
<dd><p>Create floating-point literal from bit-vector triple.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">3</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of bit-vector Sort of size <cite>1</cite> (sign bit)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">2:</span></code> Term of bit-vector Sort of exponent size (exponent)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">3:</span></code> Term of bit-vector Sort of significand size - 1 (significand without hidden bit)</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.FLOATINGPOINT_GEQ">
<span class="sig-name descname"><span class="pre">FLOATINGPOINT_GEQ</span></span><a class="headerlink" href="#cvc5.Kind.FLOATINGPOINT_GEQ" title="Link to this definition"></a></dt>
<dd><p>Floating-point greater than or equal.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">2</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1..2:</span></code> Terms of floating-point Sort (sorts must match)</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.FLOATINGPOINT_GT">
<span class="sig-name descname"><span class="pre">FLOATINGPOINT_GT</span></span><a class="headerlink" href="#cvc5.Kind.FLOATINGPOINT_GT" title="Link to this definition"></a></dt>
<dd><p>Floating-point greater than.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">2</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1..2:</span></code> Terms of floating-point Sort (sorts must match)</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.FLOATINGPOINT_IS_INF">
<span class="sig-name descname"><span class="pre">FLOATINGPOINT_IS_INF</span></span><a class="headerlink" href="#cvc5.Kind.FLOATINGPOINT_IS_INF" title="Link to this definition"></a></dt>
<dd><p>Floating-point is infinite tester.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">1</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of floating-point Sort</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.FLOATINGPOINT_IS_NAN">
<span class="sig-name descname"><span class="pre">FLOATINGPOINT_IS_NAN</span></span><a class="headerlink" href="#cvc5.Kind.FLOATINGPOINT_IS_NAN" title="Link to this definition"></a></dt>
<dd><p>Floating-point is NaN tester.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">1</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of floating-point Sort</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.FLOATINGPOINT_IS_NEG">
<span class="sig-name descname"><span class="pre">FLOATINGPOINT_IS_NEG</span></span><a class="headerlink" href="#cvc5.Kind.FLOATINGPOINT_IS_NEG" title="Link to this definition"></a></dt>
<dd><p>Floating-point is negative tester.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">1</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of floating-point Sort</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.FLOATINGPOINT_IS_NORMAL">
<span class="sig-name descname"><span class="pre">FLOATINGPOINT_IS_NORMAL</span></span><a class="headerlink" href="#cvc5.Kind.FLOATINGPOINT_IS_NORMAL" title="Link to this definition"></a></dt>
<dd><p>Floating-point is normal tester.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">1</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of floating-point Sort</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.FLOATINGPOINT_IS_POS">
<span class="sig-name descname"><span class="pre">FLOATINGPOINT_IS_POS</span></span><a class="headerlink" href="#cvc5.Kind.FLOATINGPOINT_IS_POS" title="Link to this definition"></a></dt>
<dd><p>Floating-point is positive tester.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">1</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of floating-point Sort</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.FLOATINGPOINT_IS_SUBNORMAL">
<span class="sig-name descname"><span class="pre">FLOATINGPOINT_IS_SUBNORMAL</span></span><a class="headerlink" href="#cvc5.Kind.FLOATINGPOINT_IS_SUBNORMAL" title="Link to this definition"></a></dt>
<dd><p>Floating-point is sub-normal tester.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">1</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of floating-point Sort</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.FLOATINGPOINT_IS_ZERO">
<span class="sig-name descname"><span class="pre">FLOATINGPOINT_IS_ZERO</span></span><a class="headerlink" href="#cvc5.Kind.FLOATINGPOINT_IS_ZERO" title="Link to this definition"></a></dt>
<dd><p>Floating-point is zero tester.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">1</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of floating-point Sort</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.FLOATINGPOINT_LEQ">
<span class="sig-name descname"><span class="pre">FLOATINGPOINT_LEQ</span></span><a class="headerlink" href="#cvc5.Kind.FLOATINGPOINT_LEQ" title="Link to this definition"></a></dt>
<dd><p>Floating-point less than or equal.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">2</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1..2:</span></code> Terms of floating-point Sort (sorts must match)</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.FLOATINGPOINT_LT">
<span class="sig-name descname"><span class="pre">FLOATINGPOINT_LT</span></span><a class="headerlink" href="#cvc5.Kind.FLOATINGPOINT_LT" title="Link to this definition"></a></dt>
<dd><p>Floating-point less than.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">2</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1..2:</span></code> Terms of floating-point Sort (sorts must match)</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.FLOATINGPOINT_MAX">
<span class="sig-name descname"><span class="pre">FLOATINGPOINT_MAX</span></span><a class="headerlink" href="#cvc5.Kind.FLOATINGPOINT_MAX" title="Link to this definition"></a></dt>
<dd><p>Floating-point maximum.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">2</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1..2:</span></code> Terms of floating-point Sort (sorts must match)</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.FLOATINGPOINT_MIN">
<span class="sig-name descname"><span class="pre">FLOATINGPOINT_MIN</span></span><a class="headerlink" href="#cvc5.Kind.FLOATINGPOINT_MIN" title="Link to this definition"></a></dt>
<dd><p>Floating-point minimum.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">2</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of Sort RoundingMode</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">2:</span></code> Term of floating-point Sort</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.FLOATINGPOINT_MULT">
<span class="sig-name descname"><span class="pre">FLOATINGPOINT_MULT</span></span><a class="headerlink" href="#cvc5.Kind.FLOATINGPOINT_MULT" title="Link to this definition"></a></dt>
<dd><p>Floating-point multiply.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">3</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of Sort RoundingMode</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">2..3:</span></code> Terms of floating-point Sort (sorts must match)</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.FLOATINGPOINT_NEG">
<span class="sig-name descname"><span class="pre">FLOATINGPOINT_NEG</span></span><a class="headerlink" href="#cvc5.Kind.FLOATINGPOINT_NEG" title="Link to this definition"></a></dt>
<dd><p>Floating-point negation.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">1</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of floating-point Sort</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.FLOATINGPOINT_REM">
<span class="sig-name descname"><span class="pre">FLOATINGPOINT_REM</span></span><a class="headerlink" href="#cvc5.Kind.FLOATINGPOINT_REM" title="Link to this definition"></a></dt>
<dd><p>Floating-point remainder.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">2</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1..2:</span></code> Terms of floating-point Sort (sorts must match)</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.FLOATINGPOINT_RTI">
<span class="sig-name descname"><span class="pre">FLOATINGPOINT_RTI</span></span><a class="headerlink" href="#cvc5.Kind.FLOATINGPOINT_RTI" title="Link to this definition"></a></dt>
<dd><p>Floating-point round to integral.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">2</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1..2:</span></code> Terms of floating-point Sort (sorts must match)</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.FLOATINGPOINT_SQRT">
<span class="sig-name descname"><span class="pre">FLOATINGPOINT_SQRT</span></span><a class="headerlink" href="#cvc5.Kind.FLOATINGPOINT_SQRT" title="Link to this definition"></a></dt>
<dd><p>Floating-point square root.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">2</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of Sort RoundingMode</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">2:</span></code> Term of floating-point Sort</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.FLOATINGPOINT_SUB">
<span class="sig-name descname"><span class="pre">FLOATINGPOINT_SUB</span></span><a class="headerlink" href="#cvc5.Kind.FLOATINGPOINT_SUB" title="Link to this definition"></a></dt>
<dd><p>Floating-point sutraction.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">3</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of Sort RoundingMode</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">2..3:</span></code> Terms of floating-point Sort (sorts must match)</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.FLOATINGPOINT_TO_FP_FROM_FP">
<span class="sig-name descname"><span class="pre">FLOATINGPOINT_TO_FP_FROM_FP</span></span><a class="headerlink" href="#cvc5.Kind.FLOATINGPOINT_TO_FP_FROM_FP" title="Link to this definition"></a></dt>
<dd><p>Conversion to floating-point from floating-point.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">2</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of Sort RoundingMode</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">2:</span></code> Term of floating-point Sort</p></li>
</ul>
</li>
<li><p>Indices: <code class="docutils literal notranslate"><span class="pre">2</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> The exponent size</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">2:</span></code> The significand size</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.FLOATINGPOINT_TO_FP_FROM_IEEE_BV">
<span class="sig-name descname"><span class="pre">FLOATINGPOINT_TO_FP_FROM_IEEE_BV</span></span><a class="headerlink" href="#cvc5.Kind.FLOATINGPOINT_TO_FP_FROM_IEEE_BV" title="Link to this definition"></a></dt>
<dd><p>Conversion to floating-point from IEEE-754 bit-vector.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">1</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of bit-vector Sort</p></li>
</ul>
</li>
<li><p>Indices: <code class="docutils literal notranslate"><span class="pre">2</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> The exponent size</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">2:</span></code> The significand size</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.FLOATINGPOINT_TO_FP_FROM_REAL">
<span class="sig-name descname"><span class="pre">FLOATINGPOINT_TO_FP_FROM_REAL</span></span><a class="headerlink" href="#cvc5.Kind.FLOATINGPOINT_TO_FP_FROM_REAL" title="Link to this definition"></a></dt>
<dd><p>Conversion to floating-point from Real.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">2</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of Sort RoundingMode</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">2:</span></code> Term of Sort Real</p></li>
</ul>
</li>
<li><p>Indices: <code class="docutils literal notranslate"><span class="pre">2</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> The exponent size</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">2:</span></code> The significand size</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.FLOATINGPOINT_TO_FP_FROM_SBV">
<span class="sig-name descname"><span class="pre">FLOATINGPOINT_TO_FP_FROM_SBV</span></span><a class="headerlink" href="#cvc5.Kind.FLOATINGPOINT_TO_FP_FROM_SBV" title="Link to this definition"></a></dt>
<dd><p>Conversion to floating-point from signed bit-vector.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">2</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of Sort RoundingMode</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">2:</span></code> Term of bit-vector Sort</p></li>
</ul>
</li>
<li><p>Indices: <code class="docutils literal notranslate"><span class="pre">2</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> The exponent size</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">2:</span></code> The significand size</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.FLOATINGPOINT_TO_FP_FROM_UBV">
<span class="sig-name descname"><span class="pre">FLOATINGPOINT_TO_FP_FROM_UBV</span></span><a class="headerlink" href="#cvc5.Kind.FLOATINGPOINT_TO_FP_FROM_UBV" title="Link to this definition"></a></dt>
<dd><p>Conversion to floating-point from unsigned bit-vector.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">2</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of Sort RoundingMode</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">2:</span></code> Term of bit-vector Sort</p></li>
</ul>
</li>
<li><p>Indices: <code class="docutils literal notranslate"><span class="pre">2</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> The exponent size</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">2:</span></code> The significand size</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.FLOATINGPOINT_TO_REAL">
<span class="sig-name descname"><span class="pre">FLOATINGPOINT_TO_REAL</span></span><a class="headerlink" href="#cvc5.Kind.FLOATINGPOINT_TO_REAL" title="Link to this definition"></a></dt>
<dd><p>Conversion to Real from floating-point.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">1</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of Sort Real</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.FLOATINGPOINT_TO_SBV">
<span class="sig-name descname"><span class="pre">FLOATINGPOINT_TO_SBV</span></span><a class="headerlink" href="#cvc5.Kind.FLOATINGPOINT_TO_SBV" title="Link to this definition"></a></dt>
<dd><p>Conversion to signed bit-vector from floating-point.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">2</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of Sort RoundingMode</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">2:</span></code> Term of floating-point Sort</p></li>
</ul>
</li>
<li><p>Indices: <code class="docutils literal notranslate"><span class="pre">1</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> The size of the bit-vector to convert to.</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.FLOATINGPOINT_TO_UBV">
<span class="sig-name descname"><span class="pre">FLOATINGPOINT_TO_UBV</span></span><a class="headerlink" href="#cvc5.Kind.FLOATINGPOINT_TO_UBV" title="Link to this definition"></a></dt>
<dd><p>Conversion to unsigned bit-vector from floating-point.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">2</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of Sort RoundingMode</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">2:</span></code> Term of floating-point Sort</p></li>
</ul>
</li>
<li><p>Indices: <code class="docutils literal notranslate"><span class="pre">1</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> The size of the bit-vector to convert to.</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.FORALL">
<span class="sig-name descname"><span class="pre">FORALL</span></span><a class="headerlink" href="#cvc5.Kind.FORALL" title="Link to this definition"></a></dt>
<dd><p>Universally quantified formula.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">3</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of Kind <a class="reference internal" href="#cvc5.Kind.VARIABLE_LIST" title="cvc5.Kind.VARIABLE_LIST"><code class="xref py py-obj docutils literal notranslate"><span class="pre">VARIABLE_LIST</span></code></a></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">2:</span></code> Term of Sort Bool (the quantifier body)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">3:</span></code> (optional) Term of Kind <a class="reference internal" href="#cvc5.Kind.INST_PATTERN" title="cvc5.Kind.INST_PATTERN"><code class="xref py py-obj docutils literal notranslate"><span class="pre">INST_PATTERN</span></code></a></p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.GEQ">
<span class="sig-name descname"><span class="pre">GEQ</span></span><a class="headerlink" href="#cvc5.Kind.GEQ" title="Link to this definition"></a></dt>
<dd><p>Greater than or equal, chainable.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">&gt;</span> <span class="pre">1</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1..n:</span></code> Terms of Sort Int or Real (sorts must match)</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.GT">
<span class="sig-name descname"><span class="pre">GT</span></span><a class="headerlink" href="#cvc5.Kind.GT" title="Link to this definition"></a></dt>
<dd><p>Greater than, chainable.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">&gt;</span> <span class="pre">1</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1..n:</span></code> Terms of Sort Int or Real (sorts must match)</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.HO_APPLY">
<span class="sig-name descname"><span class="pre">HO_APPLY</span></span><a class="headerlink" href="#cvc5.Kind.HO_APPLY" title="Link to this definition"></a></dt>
<dd><p>Higher-order applicative encoding of function application, left
associative.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">=</span> <span class="pre">2</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Function Term</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">2:</span></code> Argument Term of the domain Sort of the function</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.IAND">
<span class="sig-name descname"><span class="pre">IAND</span></span><a class="headerlink" href="#cvc5.Kind.IAND" title="Link to this definition"></a></dt>
<dd><p>Integer and.</p>
<p>Operator for bit-wise <code class="docutils literal notranslate"><span class="pre">AND</span></code> over integers, parameterized by a (positive)
bit-width <span class="math notranslate nohighlight">\(k\)</span>.</p>
<div class="highlight-smtlib notranslate"><div class="highlight"><pre><span></span>((<span class="na">_</span> <span class="o">iand</span> <span class="n">k</span>) <span class="n">i_1</span> <span class="n">i_2</span>)
</pre></div>
</div>
<p>is equivalent to</p>
<div class="highlight-smtlib notranslate"><div class="highlight"><pre><span></span>(<span class="o">ubv_to_int</span> (<span class="o">bvand</span> ((<span class="na">_</span> <span class="o">int_to_bv</span> <span class="n">k</span>) <span class="n">i_1</span>) ((<span class="na">_</span> <span class="o">int_to_bv</span> <span class="n">k</span>) <span class="n">i_2</span>)))
</pre></div>
</div>
<p>for all integers <code class="docutils literal notranslate"><span class="pre">i_1</span></code>, <code class="docutils literal notranslate"><span class="pre">i_2</span></code>.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">2</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1..2:</span></code> Terms of Sort Int</p></li>
</ul>
</li>
<li><p>Indices: <code class="docutils literal notranslate"><span class="pre">1</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Bit-width <span class="math notranslate nohighlight">\(k\)</span></p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.IMPLIES">
<span class="sig-name descname"><span class="pre">IMPLIES</span></span><a class="headerlink" href="#cvc5.Kind.IMPLIES" title="Link to this definition"></a></dt>
<dd><p>Logical implication.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">&gt;</span> <span class="pre">1</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1..n:</span></code> Terms of Sort Bool</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.INST_ADD_TO_POOL">
<span class="sig-name descname"><span class="pre">INST_ADD_TO_POOL</span></span><a class="headerlink" href="#cvc5.Kind.INST_ADD_TO_POOL" title="Link to this definition"></a></dt>
<dd><p>A instantantiation-add-to-pool annotation.</p>
<p>An instantantiation-add-to-pool annotation indicates that when a quantified
formula is instantiated, the instantiated version of a term should be
added to the given pool.</p>
<p>For example, consider a quantified formula:</p>
<div class="highlight-lisp notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="nv">FORALL</span><span class="w"> </span><span class="p">(</span><span class="nv">VARIABLE_LIST</span><span class="w"> </span><span class="nv">x</span><span class="p">)</span><span class="w"> </span><span class="nv">F</span>
<span class="w">        </span><span class="p">(</span><span class="nv">INST_PATTERN_LIST</span><span class="w"> </span><span class="p">(</span><span class="nv">INST_ADD_TO_POOL</span><span class="w"> </span><span class="p">(</span><span class="nv">ADD</span><span class="w"> </span><span class="nv">x</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="nv">p</span><span class="p">)))</span>
</pre></div>
</div>
<p>where assume that <span class="math notranslate nohighlight">\(x\)</span> has type Int. When this quantified formula is
instantiated with, e.g., the term <span class="math notranslate nohighlight">\(t\)</span>, the term <code class="docutils literal notranslate"><span class="pre">(ADD</span> <span class="pre">t</span> <span class="pre">1)</span></code> is
added to pool <span class="math notranslate nohighlight">\(p\)</span>.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">2</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> The Term whose free variables are bound by the quantified formula.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">2:</span></code> The pool to add to, whose Sort should be a set of elements that match the Sort of the first argument.</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This kind is experimental and may be changed or removed in future
versions.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Should only be used as a child of <a class="reference internal" href="#cvc5.Kind.INST_PATTERN_LIST" title="cvc5.Kind.INST_PATTERN_LIST"><code class="xref py py-obj docutils literal notranslate"><span class="pre">INST_PATTERN_LIST</span></code></a>.</p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.INST_ATTRIBUTE">
<span class="sig-name descname"><span class="pre">INST_ATTRIBUTE</span></span><a class="headerlink" href="#cvc5.Kind.INST_ATTRIBUTE" title="Link to this definition"></a></dt>
<dd><p>Instantiation attribute.</p>
<p>Specifies a custom property for a quantified formula given by a
term that is ascribed a user attribute.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">&gt;</span> <span class="pre">0</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of Kind <a class="reference internal" href="#cvc5.Kind.CONST_STRING" title="cvc5.Kind.CONST_STRING"><code class="xref py py-obj docutils literal notranslate"><span class="pre">CONST_STRING</span></code></a> (the keyword of the attribute)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">2...n:</span></code> Terms representing the values of the attribute</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Should only be used as a child of <a class="reference internal" href="#cvc5.Kind.INST_PATTERN_LIST" title="cvc5.Kind.INST_PATTERN_LIST"><code class="xref py py-obj docutils literal notranslate"><span class="pre">INST_PATTERN_LIST</span></code></a>.</p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.INST_NO_PATTERN">
<span class="sig-name descname"><span class="pre">INST_NO_PATTERN</span></span><a class="headerlink" href="#cvc5.Kind.INST_NO_PATTERN" title="Link to this definition"></a></dt>
<dd><p>Instantiation no-pattern.</p>
<p>Specifies a (list of) terms that should not be used as a pattern for
quantifier instantiation.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">&gt;</span> <span class="pre">0</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1..n:</span></code> Terms of any Sort</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Should only be used as a child of <a class="reference internal" href="#cvc5.Kind.INST_PATTERN_LIST" title="cvc5.Kind.INST_PATTERN_LIST"><code class="xref py py-obj docutils literal notranslate"><span class="pre">INST_PATTERN_LIST</span></code></a>.</p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.INST_PATTERN">
<span class="sig-name descname"><span class="pre">INST_PATTERN</span></span><a class="headerlink" href="#cvc5.Kind.INST_PATTERN" title="Link to this definition"></a></dt>
<dd><p>Instantiation pattern.</p>
<p>Specifies a (list of) terms to be used as a pattern for quantifier
instantiation.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">&gt;</span> <span class="pre">0</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1..n:</span></code> Terms of any Sort</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Should only be used as a child of <a class="reference internal" href="#cvc5.Kind.INST_PATTERN_LIST" title="cvc5.Kind.INST_PATTERN_LIST"><code class="xref py py-obj docutils literal notranslate"><span class="pre">INST_PATTERN_LIST</span></code></a>.</p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.INST_PATTERN_LIST">
<span class="sig-name descname"><span class="pre">INST_PATTERN_LIST</span></span><a class="headerlink" href="#cvc5.Kind.INST_PATTERN_LIST" title="Link to this definition"></a></dt>
<dd><p>A list of instantiation patterns, attributes or annotations.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">&gt;</span> <span class="pre">1</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1..n:</span></code> Terms of Kind <a class="reference internal" href="#cvc5.Kind.INST_PATTERN" title="cvc5.Kind.INST_PATTERN"><code class="xref py py-obj docutils literal notranslate"><span class="pre">INST_PATTERN</span></code></a>, <a class="reference internal" href="#cvc5.Kind.INST_NO_PATTERN" title="cvc5.Kind.INST_NO_PATTERN"><code class="xref py py-obj docutils literal notranslate"><span class="pre">INST_NO_PATTERN</span></code></a>, <a class="reference internal" href="#cvc5.Kind.INST_POOL" title="cvc5.Kind.INST_POOL"><code class="xref py py-obj docutils literal notranslate"><span class="pre">INST_POOL</span></code></a>, <a class="reference internal" href="#cvc5.Kind.INST_ADD_TO_POOL" title="cvc5.Kind.INST_ADD_TO_POOL"><code class="xref py py-obj docutils literal notranslate"><span class="pre">INST_ADD_TO_POOL</span></code></a>, <a class="reference internal" href="#cvc5.Kind.SKOLEM_ADD_TO_POOL" title="cvc5.Kind.SKOLEM_ADD_TO_POOL"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SKOLEM_ADD_TO_POOL</span></code></a>, <a class="reference internal" href="#cvc5.Kind.INST_ATTRIBUTE" title="cvc5.Kind.INST_ATTRIBUTE"><code class="xref py py-obj docutils literal notranslate"><span class="pre">INST_ATTRIBUTE</span></code></a></p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.INST_POOL">
<span class="sig-name descname"><span class="pre">INST_POOL</span></span><a class="headerlink" href="#cvc5.Kind.INST_POOL" title="Link to this definition"></a></dt>
<dd><p>Instantiation pool annotation.</p>
<p>Specifies an annotation for pool based instantiation.</p>
<dl class="simple">
<dt>In detail, pool symbols can be declared via the method</dt><dd><ul class="simple">
<li><p><a class="reference internal" href="solver.html#cvc5.Solver.declarePool" title="cvc5.Solver.declarePool"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Solver.declarePool()</span></code></a></p></li>
</ul>
</dd>
</dl>
<p>A pool symbol represents a set of terms of a given sort. An instantiation
pool annotation should either:
(1) have child sets matching the types of the quantified formula,
(2) have a child set of tuple type whose component types match the types
of the quantified formula.</p>
<p>For an example of (1), for a quantified formula:</p>
<div class="highlight-lisp notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="nv">FORALL</span><span class="w"> </span><span class="p">(</span><span class="nv">VARIABLE_LIST</span><span class="w"> </span><span class="nv">x</span><span class="w"> </span><span class="nv">y</span><span class="p">)</span><span class="w"> </span><span class="nv">F</span><span class="w"> </span><span class="p">(</span><span class="nv">INST_PATTERN_LIST</span><span class="w"> </span><span class="p">(</span><span class="nv">INST_POOL</span><span class="w"> </span><span class="nv">p</span><span class="w"> </span><span class="nv">q</span><span class="p">)))</span>
</pre></div>
</div>
<p>if <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(y\)</span> have Sorts <span class="math notranslate nohighlight">\(S_1\)</span> and <span class="math notranslate nohighlight">\(S_2\)</span>, then
pool symbols <span class="math notranslate nohighlight">\(p\)</span> and <span class="math notranslate nohighlight">\(q\)</span> should have Sorts (Set <span class="math notranslate nohighlight">\(S_1\)</span>)
and (Set <span class="math notranslate nohighlight">\(S_2\)</span>), respectively. This annotation specifies that the
quantified formula above should be instantiated with the product of all
terms that occur in the sets <span class="math notranslate nohighlight">\(p\)</span> and <span class="math notranslate nohighlight">\(q\)</span>.</p>
<p>Alternatively, as an example of (2), for a quantified formula:</p>
<div class="highlight-lisp notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="nv">FORALL</span><span class="w"> </span><span class="p">(</span><span class="nv">VARIABLE_LIST</span><span class="w"> </span><span class="nv">x</span><span class="w"> </span><span class="nv">y</span><span class="p">)</span><span class="w"> </span><span class="nv">F</span><span class="w"> </span><span class="p">(</span><span class="nv">INST_PATTERN_LIST</span><span class="w"> </span><span class="p">(</span><span class="nv">INST_POOL</span><span class="w"> </span><span class="nv">s</span><span class="p">)))</span>
</pre></div>
</div>
<p><span class="math notranslate nohighlight">\(s\)</span> should have Sort (Set (Tuple <span class="math notranslate nohighlight">\(S_1\)</span> <span class="math notranslate nohighlight">\(S_2\)</span>)). This
annotation specifies that the quantified formula above should be
instantiated with the pairs of values in <span class="math notranslate nohighlight">\(s\)</span>.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">&gt;</span> <span class="pre">0</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1..n:</span></code> Terms that comprise the pools, which are one-to-one with the variables of the quantified formula to be instantiated</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This kind is experimental and may be changed or removed in future
versions.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Should only be used as a child of <a class="reference internal" href="#cvc5.Kind.INST_PATTERN_LIST" title="cvc5.Kind.INST_PATTERN_LIST"><code class="xref py py-obj docutils literal notranslate"><span class="pre">INST_PATTERN_LIST</span></code></a>.</p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.INTERNAL_KIND">
<span class="sig-name descname"><span class="pre">INTERNAL_KIND</span></span><a class="headerlink" href="#cvc5.Kind.INTERNAL_KIND" title="Link to this definition"></a></dt>
<dd><p>Internal kind.</p>
<p>This kind serves as an abstraction for internal kinds that are not exposed
via the API but may appear in terms returned by API functions, e.g.,
when querying the simplified form of a term.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Should never be created via the API.</p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.INTS_DIVISION">
<span class="sig-name descname"><span class="pre">INTS_DIVISION</span></span><a class="headerlink" href="#cvc5.Kind.INTS_DIVISION" title="Link to this definition"></a></dt>
<dd><p>Integer division, division by 0 undefined, left associative.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">&gt;</span> <span class="pre">1</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1..n:</span></code> Terms of Sort Int</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.INTS_DIVISION_TOTAL">
<span class="sig-name descname"><span class="pre">INTS_DIVISION_TOTAL</span></span><a class="headerlink" href="#cvc5.Kind.INTS_DIVISION_TOTAL" title="Link to this definition"></a></dt>
<dd><p>Integer division, division by 0 defined to be 0, left associative.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">&gt;</span> <span class="pre">1</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1..n:</span></code> Terms of Sort Int</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This kind is experimental and may be changed or removed in future
versions.</p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.INTS_MODULUS">
<span class="sig-name descname"><span class="pre">INTS_MODULUS</span></span><a class="headerlink" href="#cvc5.Kind.INTS_MODULUS" title="Link to this definition"></a></dt>
<dd><p>Integer modulus, modulus by 0 undefined.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">2</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of Sort Int</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">2:</span></code> Term of Sort Int</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.INTS_MODULUS_TOTAL">
<span class="sig-name descname"><span class="pre">INTS_MODULUS_TOTAL</span></span><a class="headerlink" href="#cvc5.Kind.INTS_MODULUS_TOTAL" title="Link to this definition"></a></dt>
<dd><p>Integer modulus, t modulus by 0 defined to be t.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">2</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of Sort Int</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">2:</span></code> Term of Sort Int</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This kind is experimental and may be changed or removed in future
versions.</p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.INT_TO_BITVECTOR">
<span class="sig-name descname"><span class="pre">INT_TO_BITVECTOR</span></span><a class="headerlink" href="#cvc5.Kind.INT_TO_BITVECTOR" title="Link to this definition"></a></dt>
<dd><p>Conversion from Int to bit-vector.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">1</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of Sort Int</p></li>
</ul>
</li>
<li><p>Indices: <code class="docutils literal notranslate"><span class="pre">1</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> The size of the bit-vector to convert to.</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.IS_INTEGER">
<span class="sig-name descname"><span class="pre">IS_INTEGER</span></span><a class="headerlink" href="#cvc5.Kind.IS_INTEGER" title="Link to this definition"></a></dt>
<dd><p>Is-integer predicate.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">1</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of Sort Int or Real</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.ITE">
<span class="sig-name descname"><span class="pre">ITE</span></span><a class="headerlink" href="#cvc5.Kind.ITE" title="Link to this definition"></a></dt>
<dd><p>If-then-else.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">3</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of Sort Bool</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">2:</span></code> The ‘then’ term, Term of any Sort</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">3:</span></code> The ‘else’ term, Term of the same sort as second argument</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.LAMBDA">
<span class="sig-name descname"><span class="pre">LAMBDA</span></span><a class="headerlink" href="#cvc5.Kind.LAMBDA" title="Link to this definition"></a></dt>
<dd><p>Lambda expression.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">2</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of kind <a class="reference internal" href="#cvc5.Kind.VARIABLE_LIST" title="cvc5.Kind.VARIABLE_LIST"><code class="xref py py-obj docutils literal notranslate"><span class="pre">VARIABLE_LIST</span></code></a></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">2:</span></code> Term of any Sort (the body of the lambda)</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.LAST_KIND">
<span class="sig-name descname"><span class="pre">LAST_KIND</span></span><a class="headerlink" href="#cvc5.Kind.LAST_KIND" title="Link to this definition"></a></dt>
<dd><p>Marks the upper-bound of this enumeration.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.LEQ">
<span class="sig-name descname"><span class="pre">LEQ</span></span><a class="headerlink" href="#cvc5.Kind.LEQ" title="Link to this definition"></a></dt>
<dd><p>Less than or equal, chainable.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">&gt;</span> <span class="pre">1</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1..n:</span></code> Terms of Sort Int or Real (sorts must match)</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.LOG2">
<span class="sig-name descname"><span class="pre">LOG2</span></span><a class="headerlink" href="#cvc5.Kind.LOG2" title="Link to this definition"></a></dt>
<dd><p>Log of base two.</p>
<p>Operator for the inverse of raising <code class="docutils literal notranslate"><span class="pre">2</span></code> to a non-negative integer power.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">1</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of Sort Int</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.LT">
<span class="sig-name descname"><span class="pre">LT</span></span><a class="headerlink" href="#cvc5.Kind.LT" title="Link to this definition"></a></dt>
<dd><p>Less than, chainable.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">&gt;</span> <span class="pre">1</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1..n:</span></code> Terms of Sort Int or Real (sorts must match)</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.MATCH">
<span class="sig-name descname"><span class="pre">MATCH</span></span><a class="headerlink" href="#cvc5.Kind.MATCH" title="Link to this definition"></a></dt>
<dd><p>Match expression.</p>
<p>This kind is primarily used in the parser to support the
SMT-LIBv2 <code class="docutils literal notranslate"><span class="pre">match</span></code> expression.</p>
<p>For example, the SMT-LIBv2 syntax for the following match term</p>
<div class="highlight-smtlib notranslate"><div class="highlight"><pre><span></span>(<span class="k">match</span> <span class="n">l</span> (((<span class="n">cons</span> <span class="n">h</span> <span class="n">t</span>) <span class="n">h</span>) (<span class="n">nil</span> <span class="m">0</span>)))
</pre></div>
</div>
<p>is represented by the AST</p>
<div class="highlight-lisp notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="nv">MATCH</span><span class="w"> </span><span class="nv">l</span>
<span class="w">    </span><span class="p">(</span><span class="nv">MATCH_BIND_CASE</span><span class="w"> </span><span class="p">(</span><span class="nv">VARIABLE_LIST</span><span class="w"> </span><span class="nv">h</span><span class="w"> </span><span class="no">t</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="nv">h</span><span class="w"> </span><span class="no">t</span><span class="p">)</span><span class="w"> </span><span class="nv">h</span><span class="p">)</span>
<span class="w">    </span><span class="p">(</span><span class="nv">MATCH_CASE</span><span class="w"> </span><span class="no">nil</span><span class="w"> </span><span class="mi">0</span><span class="p">))</span>
</pre></div>
</div>
<p>Terms of kind <a class="reference internal" href="#cvc5.Kind.MATCH_CASE" title="cvc5.Kind.MATCH_CASE"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MATCH_CASE</span></code></a> are constant case expressions,
which are used for nullary constructors. Kind
<a class="reference internal" href="#cvc5.Kind.MATCH_BIND_CASE" title="cvc5.Kind.MATCH_BIND_CASE"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MATCH_BIND_CASE</span></code></a> is used for constructors with selectors
and variable match patterns. If not all constructors are covered, at least
one catch-all variable pattern must be included.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">&gt;</span> <span class="pre">1</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1..n:</span></code> Terms of kind <a class="reference internal" href="#cvc5.Kind.MATCH_CASE" title="cvc5.Kind.MATCH_CASE"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MATCH_CASE</span></code></a> and <a class="reference internal" href="#cvc5.Kind.MATCH_BIND_CASE" title="cvc5.Kind.MATCH_BIND_CASE"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MATCH_BIND_CASE</span></code></a></p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.MATCH_BIND_CASE">
<span class="sig-name descname"><span class="pre">MATCH_BIND_CASE</span></span><a class="headerlink" href="#cvc5.Kind.MATCH_BIND_CASE" title="Link to this definition"></a></dt>
<dd><p>Match case with binders, for constructors with selectors and variable
patterns.</p>
<p>A (non-constant) case expression to be used within a match expression.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">3</span></code></p>
<ul>
<li><p>For variable patterns:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of kind <a class="reference internal" href="#cvc5.Kind.VARIABLE_LIST" title="cvc5.Kind.VARIABLE_LIST"><code class="xref py py-obj docutils literal notranslate"><span class="pre">VARIABLE_LIST</span></code></a> (containing the free variable of the case)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">2:</span></code> Term of kind <a class="reference internal" href="#cvc5.Kind.VARIABLE" title="cvc5.Kind.VARIABLE"><code class="xref py py-obj docutils literal notranslate"><span class="pre">VARIABLE</span></code></a> (the pattern expression, the free variable of the case)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">3:</span></code> Term of any Sort (the term the pattern evaluates to)</p></li>
</ul>
</li>
<li><p>For constructors with selectors:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of kind <a class="reference internal" href="#cvc5.Kind.VARIABLE_LIST" title="cvc5.Kind.VARIABLE_LIST"><code class="xref py py-obj docutils literal notranslate"><span class="pre">VARIABLE_LIST</span></code></a> (containing the free variable of the case)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">2:</span></code> Term of kind <a class="reference internal" href="#cvc5.Kind.APPLY_CONSTRUCTOR" title="cvc5.Kind.APPLY_CONSTRUCTOR"><code class="xref py py-obj docutils literal notranslate"><span class="pre">APPLY_CONSTRUCTOR</span></code></a> (the pattern expression, applying the set of variables to the constructor)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">3:</span></code> Term of any Sort (the term the match term evaluates to)</p></li>
</ul>
</li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.MATCH_CASE">
<span class="sig-name descname"><span class="pre">MATCH_CASE</span></span><a class="headerlink" href="#cvc5.Kind.MATCH_CASE" title="Link to this definition"></a></dt>
<dd><p>Match case for nullary constructors.</p>
<p>A (constant) case expression to be used within a match expression.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">2</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of kind <a class="reference internal" href="#cvc5.Kind.APPLY_CONSTRUCTOR" title="cvc5.Kind.APPLY_CONSTRUCTOR"><code class="xref py py-obj docutils literal notranslate"><span class="pre">APPLY_CONSTRUCTOR</span></code></a> (the pattern to match against)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">2:</span></code> Term of any Sort (the term the match term evaluates to)</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.MULT">
<span class="sig-name descname"><span class="pre">MULT</span></span><a class="headerlink" href="#cvc5.Kind.MULT" title="Link to this definition"></a></dt>
<dd><p>Arithmetic multiplication.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">&gt;</span> <span class="pre">1</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1..n:</span></code> Terms of Sort Int or Real (sorts must match)</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.NEG">
<span class="sig-name descname"><span class="pre">NEG</span></span><a class="headerlink" href="#cvc5.Kind.NEG" title="Link to this definition"></a></dt>
<dd><p>Arithmetic negation.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">1</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of Sort Int or Real</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.NOT">
<span class="sig-name descname"><span class="pre">NOT</span></span><a class="headerlink" href="#cvc5.Kind.NOT" title="Link to this definition"></a></dt>
<dd><p>Logical negation.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">1</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of Sort Bool</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.NULLABLE_LIFT">
<span class="sig-name descname"><span class="pre">NULLABLE_LIFT</span></span><a class="headerlink" href="#cvc5.Kind.NULLABLE_LIFT" title="Link to this definition"></a></dt>
<dd><p>Lifting operator for nullable terms.
This operator lifts a built-in operator or a user-defined function
to nullable terms.
For built-in kinds use mkNullableLift.
For user-defined functions use mkTerm.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">&gt;</span> <span class="pre">1</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">1..n:</span></code> Terms of nullable sort</p></li>
<li><p>Create Term of this Kind with:
- TermManager::mkNullableLift(Kind, const std::vector&lt;Term&gt;&amp;)
- TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.NULL_TERM">
<span class="sig-name descname"><span class="pre">NULL_TERM</span></span><a class="headerlink" href="#cvc5.Kind.NULL_TERM" title="Link to this definition"></a></dt>
<dd><p>Null kind.</p>
<p>The kind of a null term (<code class="xref py py-meth docutils literal notranslate"><span class="pre">Term.Term()</span></code>).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>May not be explicitly created via API functions other than
<code class="xref py py-meth docutils literal notranslate"><span class="pre">Term.Term()</span></code>.</p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.OR">
<span class="sig-name descname"><span class="pre">OR</span></span><a class="headerlink" href="#cvc5.Kind.OR" title="Link to this definition"></a></dt>
<dd><p>Logical disjunction.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">&gt;</span> <span class="pre">1</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1..n:</span></code> Terms of Sort Bool</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.PI">
<span class="sig-name descname"><span class="pre">PI</span></span><a class="headerlink" href="#cvc5.Kind.PI" title="Link to this definition"></a></dt>
<dd><p>Pi constant.</p>
<ul class="simple">
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkPi()</p></li>
</ul>
</li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><a class="reference internal" href="#cvc5.Kind.PI" title="cvc5.Kind.PI"><code class="xref py py-obj docutils literal notranslate"><span class="pre">PI</span></code></a> is considered a special symbol of Sort Real, but
is not a Real value, i.e., <a class="reference internal" href="term.html#cvc5.Term.isRealValue" title="cvc5.Term.isRealValue"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Term.isRealValue()</span></code></a> will return
<code class="docutils literal notranslate"><span class="pre">false</span></code>.</p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.PIAND">
<span class="sig-name descname"><span class="pre">PIAND</span></span><a class="headerlink" href="#cvc5.Kind.PIAND" title="Link to this definition"></a></dt>
<dd><p>parametric Integer and.</p>
<p>Operator for parametric bit-wise <code class="docutils literal notranslate"><span class="pre">AND</span></code> over integers, parameterized by a
bit-width <span class="math notranslate nohighlight">\(k\)</span>.
This is similar to the iand indexed operator but allows the bit-width be symbolic.
If k &gt; 0:</p>
<div class="highlight-smtlib notranslate"><div class="highlight"><pre><span></span>(<span class="n">piand</span> <span class="n">k</span> <span class="n">i_1</span> <span class="n">i_2</span>)
</pre></div>
</div>
<p>is equivalent to</p>
<div class="highlight-smtlib notranslate"><div class="highlight"><pre><span></span>((<span class="na">_</span> <span class="o">ubv_to_int</span> <span class="n">k</span>) <span class="n">x</span>)
</pre></div>
</div>
<p>such that x is the bitwise and of bit-vectors b1 and b2, such that
b1 is the bit-vector of width k representing (mod i_1 2^k) and
b2 is the bit-vector of width k representing (mod i_2 2^k),
for all integers <code class="docutils literal notranslate"><span class="pre">k</span></code>, <code class="docutils literal notranslate"><span class="pre">i_1</span></code>, <code class="docutils literal notranslate"><span class="pre">i_2</span></code>.</p>
<p>If k &lt;= 0 then</p>
<div class="highlight-smtlib notranslate"><div class="highlight"><pre><span></span>(<span class="n">piand</span> <span class="n">k</span> <span class="n">i_1</span> <span class="n">i_2</span>)
</pre></div>
</div>
<p>is equivalent to</p>
<div class="highlight-smtlib notranslate"><div class="highlight"><pre><span></span><span class="m">0</span>
</pre></div>
</div>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">3</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1..3:</span></code> Terms of Sort Int</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.POW">
<span class="sig-name descname"><span class="pre">POW</span></span><a class="headerlink" href="#cvc5.Kind.POW" title="Link to this definition"></a></dt>
<dd><p>Arithmetic power.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">2</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1..2:</span></code> Term of Sort Int or Real (sorts must match)</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.POW2">
<span class="sig-name descname"><span class="pre">POW2</span></span><a class="headerlink" href="#cvc5.Kind.POW2" title="Link to this definition"></a></dt>
<dd><p>Power of two.</p>
<p>Operator for raising <code class="docutils literal notranslate"><span class="pre">2</span></code> to a non-negative integer power.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">1</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of Sort Int</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.REGEXP_ALL">
<span class="sig-name descname"><span class="pre">REGEXP_ALL</span></span><a class="headerlink" href="#cvc5.Kind.REGEXP_ALL" title="Link to this definition"></a></dt>
<dd><p>Regular expression all.</p>
<ul class="simple">
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkRegexpAll()</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.REGEXP_ALLCHAR">
<span class="sig-name descname"><span class="pre">REGEXP_ALLCHAR</span></span><a class="headerlink" href="#cvc5.Kind.REGEXP_ALLCHAR" title="Link to this definition"></a></dt>
<dd><p>Regular expression all characters.</p>
<ul class="simple">
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkRegexpAllchar()</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.REGEXP_COMPLEMENT">
<span class="sig-name descname"><span class="pre">REGEXP_COMPLEMENT</span></span><a class="headerlink" href="#cvc5.Kind.REGEXP_COMPLEMENT" title="Link to this definition"></a></dt>
<dd><p>Regular expression complement.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">1</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of Sort RegLan</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.REGEXP_CONCAT">
<span class="sig-name descname"><span class="pre">REGEXP_CONCAT</span></span><a class="headerlink" href="#cvc5.Kind.REGEXP_CONCAT" title="Link to this definition"></a></dt>
<dd><p>Regular expression concatenation.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">2</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1..2:</span></code> Terms of Sort RegLan</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.REGEXP_DIFF">
<span class="sig-name descname"><span class="pre">REGEXP_DIFF</span></span><a class="headerlink" href="#cvc5.Kind.REGEXP_DIFF" title="Link to this definition"></a></dt>
<dd><p>Regular expression difference.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">2</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1..2:</span></code> Terms of Sort RegLan</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.REGEXP_INTER">
<span class="sig-name descname"><span class="pre">REGEXP_INTER</span></span><a class="headerlink" href="#cvc5.Kind.REGEXP_INTER" title="Link to this definition"></a></dt>
<dd><p>Regular expression intersection.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">2</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1..2:</span></code> Terms of Sort RegLan</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.REGEXP_LOOP">
<span class="sig-name descname"><span class="pre">REGEXP_LOOP</span></span><a class="headerlink" href="#cvc5.Kind.REGEXP_LOOP" title="Link to this definition"></a></dt>
<dd><p>Regular expression loop.</p>
<p>Regular expression loop from lower bound to upper bound number of
repetitions.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">1</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of Sort RegLan</p></li>
</ul>
</li>
<li><p>Indices: <code class="docutils literal notranslate"><span class="pre">1</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> The lower bound</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">2:</span></code> The upper bound</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.REGEXP_NONE">
<span class="sig-name descname"><span class="pre">REGEXP_NONE</span></span><a class="headerlink" href="#cvc5.Kind.REGEXP_NONE" title="Link to this definition"></a></dt>
<dd><p>Regular expression none.</p>
<ul class="simple">
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkRegexpNone()</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.REGEXP_OPT">
<span class="sig-name descname"><span class="pre">REGEXP_OPT</span></span><a class="headerlink" href="#cvc5.Kind.REGEXP_OPT" title="Link to this definition"></a></dt>
<dd><p>Regular expression ?.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">1</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of Sort RegLan</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.REGEXP_PLUS">
<span class="sig-name descname"><span class="pre">REGEXP_PLUS</span></span><a class="headerlink" href="#cvc5.Kind.REGEXP_PLUS" title="Link to this definition"></a></dt>
<dd><p>Regular expression +.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">1</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of Sort RegLan</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.REGEXP_RANGE">
<span class="sig-name descname"><span class="pre">REGEXP_RANGE</span></span><a class="headerlink" href="#cvc5.Kind.REGEXP_RANGE" title="Link to this definition"></a></dt>
<dd><p>Regular expression range.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">2</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of Sort String (lower bound character for the range)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">2:</span></code> Term of Sort String (upper bound character for the range)</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.REGEXP_REPEAT">
<span class="sig-name descname"><span class="pre">REGEXP_REPEAT</span></span><a class="headerlink" href="#cvc5.Kind.REGEXP_REPEAT" title="Link to this definition"></a></dt>
<dd><p>Operator for regular expression repeat.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">1</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of Sort RegLan</p></li>
</ul>
</li>
<li><p>Indices: <code class="docutils literal notranslate"><span class="pre">1</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> The number of repetitions</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.REGEXP_STAR">
<span class="sig-name descname"><span class="pre">REGEXP_STAR</span></span><a class="headerlink" href="#cvc5.Kind.REGEXP_STAR" title="Link to this definition"></a></dt>
<dd><p>Regular expression *.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">1</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of Sort RegLan</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.REGEXP_UNION">
<span class="sig-name descname"><span class="pre">REGEXP_UNION</span></span><a class="headerlink" href="#cvc5.Kind.REGEXP_UNION" title="Link to this definition"></a></dt>
<dd><p>Regular expression union.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">2</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1..2:</span></code> Terms of Sort RegLan</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.RELATION_AGGREGATE">
<span class="sig-name descname"><span class="pre">RELATION_AGGREGATE</span></span><a class="headerlink" href="#cvc5.Kind.RELATION_AGGREGATE" title="Link to this definition"></a></dt>
<dd><p>Relation aggregate operator has the form
<span class="math notranslate nohighlight">\(((\_ \; rel.aggr \; n_1 ... n_k) \; f \; i \; A)\)</span>
where <span class="math notranslate nohighlight">\(n_1, ..., n_k\)</span> are natural numbers,
<span class="math notranslate nohighlight">\(f\)</span> is a function of type
<span class="math notranslate nohighlight">\((\rightarrow (Tuple \;  T_1 \; ... \; T_j)\; T \; T)\)</span>,
<span class="math notranslate nohighlight">\(i\)</span> has the type <span class="math notranslate nohighlight">\(T\)</span>,
and <span class="math notranslate nohighlight">\(A\)</span> has type <span class="math notranslate nohighlight">\((Relation \;  T_1 \; ... \; T_j)\)</span>.
The returned type is <span class="math notranslate nohighlight">\((Set \; T)\)</span>.</p>
<p>This operator aggregates elements in A that have the same tuple projection
with indices n_1, …, n_k using the combining function <span class="math notranslate nohighlight">\(f\)</span>,
and initial value <span class="math notranslate nohighlight">\(i\)</span>.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">3</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of sort <span class="math notranslate nohighlight">\((\rightarrow (Tuple \;  T_1 \; ... \; T_j)\; T \; T)\)</span></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">2:</span></code> Term of Sort <span class="math notranslate nohighlight">\(T\)</span></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">3:</span></code> Term of relation sort <span class="math notranslate nohighlight">\(Relation T_1 ... T_j\)</span></p></li>
</ul>
</li>
<li><p>Indices: <code class="docutils literal notranslate"><span class="pre">n</span></code>
- <code class="docutils literal notranslate"><span class="pre">1..n:</span></code> Indices of the projection</p></li>
<li><p>Create Term of this Kind with:
- TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>Create Op of this kind with:
- TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This kind is experimental and may be changed or removed in future
versions.</p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.RELATION_GROUP">
<span class="sig-name descname"><span class="pre">RELATION_GROUP</span></span><a class="headerlink" href="#cvc5.Kind.RELATION_GROUP" title="Link to this definition"></a></dt>
<dd><p>Relation group</p>
<p><span class="math notranslate nohighlight">\(((\_ \; rel.group \; n_1 \; \dots \; n_k) \; A)\)</span> partitions tuples
of relation <span class="math notranslate nohighlight">\(A\)</span> such that tuples that have the same projection
with indices <span class="math notranslate nohighlight">\(n_1 \; \dots \; n_k\)</span> are in the same part.
It returns a set of relations of type <span class="math notranslate nohighlight">\((Set \; T)\)</span> where
<span class="math notranslate nohighlight">\(T\)</span> is the type of <span class="math notranslate nohighlight">\(A\)</span>.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">1</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of relation sort</p></li>
</ul>
</li>
<li><p>Indices: <code class="docutils literal notranslate"><span class="pre">n</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1..n:</span></code>  Indices of the projection</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
</ul>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This kind is experimental and may be changed or removed in future
versions.</p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.RELATION_IDEN">
<span class="sig-name descname"><span class="pre">RELATION_IDEN</span></span><a class="headerlink" href="#cvc5.Kind.RELATION_IDEN" title="Link to this definition"></a></dt>
<dd><p>Relation identity.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">1</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of relation Sort</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This kind is experimental and may be changed or removed in future
versions.</p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.RELATION_JOIN">
<span class="sig-name descname"><span class="pre">RELATION_JOIN</span></span><a class="headerlink" href="#cvc5.Kind.RELATION_JOIN" title="Link to this definition"></a></dt>
<dd><p>Relation join.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">2</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1..2:</span></code> Terms of relation Sort</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.RELATION_JOIN_IMAGE">
<span class="sig-name descname"><span class="pre">RELATION_JOIN_IMAGE</span></span><a class="headerlink" href="#cvc5.Kind.RELATION_JOIN_IMAGE" title="Link to this definition"></a></dt>
<dd><p>Relation join image.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">2</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1..2:</span></code> Terms of relation Sort</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This kind is experimental and may be changed or removed in future
versions.</p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.RELATION_PRODUCT">
<span class="sig-name descname"><span class="pre">RELATION_PRODUCT</span></span><a class="headerlink" href="#cvc5.Kind.RELATION_PRODUCT" title="Link to this definition"></a></dt>
<dd><p>Relation cartesian product.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">2</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1..2:</span></code> Terms of relation Sort</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.RELATION_PROJECT">
<span class="sig-name descname"><span class="pre">RELATION_PROJECT</span></span><a class="headerlink" href="#cvc5.Kind.RELATION_PROJECT" title="Link to this definition"></a></dt>
<dd><p>Relation projection operator extends tuple projection operator to sets.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">1</span></code>
- <code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of relation Sort</p></li>
<li><p>Indices: <code class="docutils literal notranslate"><span class="pre">n</span></code>
- <code class="docutils literal notranslate"><span class="pre">1..n:</span></code> Indices of the projection</p></li>
<li><p>Create Term of this Kind with:
- TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>Create Op of this kind with:
- TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This kind is experimental and may be changed or removed in future
versions.</p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.RELATION_TABLE_JOIN">
<span class="sig-name descname"><span class="pre">RELATION_TABLE_JOIN</span></span><a class="headerlink" href="#cvc5.Kind.RELATION_TABLE_JOIN" title="Link to this definition"></a></dt>
<dd><dl class="simple">
<dt>Table join operator for relations has the form</dt><dd><p><span class="math notranslate nohighlight">\(((\_ \; rel.table\_join \; m_1 \; n_1 \; \dots \; m_k \; n_k) \; A \; B)\)</span>
where <span class="math notranslate nohighlight">\(m_1 \; n_1 \; \dots \; m_k \; n_k\)</span> are natural numbers,
and <span class="math notranslate nohighlight">\(A, B\)</span> are relations.
This operator filters the product of two sets based on the equality of
projected tuples using indices <span class="math notranslate nohighlight">\(m_1, \dots, m_k\)</span> in relation <span class="math notranslate nohighlight">\(A\)</span>,
and indices <span class="math notranslate nohighlight">\(n_1, \dots, n_k\)</span> in relation <span class="math notranslate nohighlight">\(B\)</span>.</p>
</dd>
</dl>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">2</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of relation Sort</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">2:</span></code> Term of relation Sort</p></li>
</ul>
</li>
<li><p>Indices: <code class="docutils literal notranslate"><span class="pre">n</span></code>
- <code class="docutils literal notranslate"><span class="pre">1..n:</span></code>  Indices of the projection</p></li>
<li><p>Create Term of this Kind with:
- TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>Create Op of this kind with:
- TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.RELATION_TCLOSURE">
<span class="sig-name descname"><span class="pre">RELATION_TCLOSURE</span></span><a class="headerlink" href="#cvc5.Kind.RELATION_TCLOSURE" title="Link to this definition"></a></dt>
<dd><p>Relation transitive closure.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">1</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of relation Sort</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.RELATION_TRANSPOSE">
<span class="sig-name descname"><span class="pre">RELATION_TRANSPOSE</span></span><a class="headerlink" href="#cvc5.Kind.RELATION_TRANSPOSE" title="Link to this definition"></a></dt>
<dd><p>Relation transpose.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">1</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of relation Sort</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.SECANT">
<span class="sig-name descname"><span class="pre">SECANT</span></span><a class="headerlink" href="#cvc5.Kind.SECANT" title="Link to this definition"></a></dt>
<dd><p>Secant function.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">1</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of Sort Real</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.SELECT">
<span class="sig-name descname"><span class="pre">SELECT</span></span><a class="headerlink" href="#cvc5.Kind.SELECT" title="Link to this definition"></a></dt>
<dd><p>Array select.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">2</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of array Sort</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">2:</span></code> Term of array index Sort</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.SEP_EMP">
<span class="sig-name descname"><span class="pre">SEP_EMP</span></span><a class="headerlink" href="#cvc5.Kind.SEP_EMP" title="Link to this definition"></a></dt>
<dd><p>Separation logic empty heap.</p>
<ul class="simple">
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkSepEmp()</p></li>
</ul>
</li>
</ul>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This kind is experimental and may be changed or removed in future
versions.</p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.SEP_NIL">
<span class="sig-name descname"><span class="pre">SEP_NIL</span></span><a class="headerlink" href="#cvc5.Kind.SEP_NIL" title="Link to this definition"></a></dt>
<dd><p>Separation logic nil.</p>
<ul class="simple">
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkSepNil(const Sort&amp;)</p></li>
</ul>
</li>
</ul>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This kind is experimental and may be changed or removed in future
versions.</p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.SEP_PTO">
<span class="sig-name descname"><span class="pre">SEP_PTO</span></span><a class="headerlink" href="#cvc5.Kind.SEP_PTO" title="Link to this definition"></a></dt>
<dd><p>Separation logic points-to relation.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">2</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term denoting the location of the points-to constraint</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">2:</span></code> Term denoting the data of the points-to constraint</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This kind is experimental and may be changed or removed in future
versions.</p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.SEP_STAR">
<span class="sig-name descname"><span class="pre">SEP_STAR</span></span><a class="headerlink" href="#cvc5.Kind.SEP_STAR" title="Link to this definition"></a></dt>
<dd><p>Separation logic star.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">&gt;</span> <span class="pre">1</span></code></p>
<ul>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">1..n:</span></code> Terms of sort Bool (the child constraints that hold in</dt><dd><p>disjoint (separated) heaps)</p>
</dd>
</dl>
</li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This kind is experimental and may be changed or removed in future
versions.</p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.SEP_WAND">
<span class="sig-name descname"><span class="pre">SEP_WAND</span></span><a class="headerlink" href="#cvc5.Kind.SEP_WAND" title="Link to this definition"></a></dt>
<dd><p>Separation logic magic wand.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">2</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Terms of Sort Bool (the antecendant of the magic wand constraint)</p></li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">2:</span></code> Terms of Sort Bool (conclusion of the magic wand constraint,</dt><dd><p>which is asserted to hold in all heaps that are disjoint
extensions of the antecedent)</p>
</dd>
</dl>
</li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This kind is experimental and may be changed or removed in future
versions.</p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.SEQ_AT">
<span class="sig-name descname"><span class="pre">SEQ_AT</span></span><a class="headerlink" href="#cvc5.Kind.SEQ_AT" title="Link to this definition"></a></dt>
<dd><p>Sequence element at.</p>
<p>Returns the element at index <span class="math notranslate nohighlight">\(i\)</span> from a sequence <span class="math notranslate nohighlight">\(s\)</span>. If the index
is negative or the index is greater or equal to the length of the
sequence, the result is the empty sequence. Otherwise the result is a
sequence of length <code class="docutils literal notranslate"><span class="pre">1</span></code>.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">2</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of sequence Sort</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">2:</span></code> Term of Sort Int (index <span class="math notranslate nohighlight">\(i\)</span>)</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.SEQ_CONCAT">
<span class="sig-name descname"><span class="pre">SEQ_CONCAT</span></span><a class="headerlink" href="#cvc5.Kind.SEQ_CONCAT" title="Link to this definition"></a></dt>
<dd><p>Sequence concat.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">&gt;</span> <span class="pre">1</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1..n:</span></code> Terms of sequence Sort</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.SEQ_CONTAINS">
<span class="sig-name descname"><span class="pre">SEQ_CONTAINS</span></span><a class="headerlink" href="#cvc5.Kind.SEQ_CONTAINS" title="Link to this definition"></a></dt>
<dd><p>Sequence contains.</p>
<p>Checks whether a sequence <span class="math notranslate nohighlight">\(s_1\)</span> contains another sequence
<span class="math notranslate nohighlight">\(s_2\)</span>. If <span class="math notranslate nohighlight">\(s_2\)</span> is empty, the result is always <code class="docutils literal notranslate"><span class="pre">true</span></code>.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">2</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of sequence Sort (<span class="math notranslate nohighlight">\(s_1\)</span>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">2:</span></code> Term of sequence Sort (<span class="math notranslate nohighlight">\(s_2\)</span>)</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.SEQ_EXTRACT">
<span class="sig-name descname"><span class="pre">SEQ_EXTRACT</span></span><a class="headerlink" href="#cvc5.Kind.SEQ_EXTRACT" title="Link to this definition"></a></dt>
<dd><p>Sequence extract.</p>
<p>Extracts a subsequence, starting at index <span class="math notranslate nohighlight">\(i\)</span> and of length <span class="math notranslate nohighlight">\(l\)</span>,
from a sequence <span class="math notranslate nohighlight">\(s\)</span>.  If the start index is negative, the start index
is greater than the length of the sequence, or the length is negative, the
result is the empty sequence.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">3</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of sequence Sort</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">2:</span></code> Term of Sort Int (index <span class="math notranslate nohighlight">\(i\)</span>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">3:</span></code> Term of Sort Int (length <span class="math notranslate nohighlight">\(l\)</span>)</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.SEQ_INDEXOF">
<span class="sig-name descname"><span class="pre">SEQ_INDEXOF</span></span><a class="headerlink" href="#cvc5.Kind.SEQ_INDEXOF" title="Link to this definition"></a></dt>
<dd><p>Sequence index-of.</p>
<p>Returns the index of a subsequence <span class="math notranslate nohighlight">\(s_2\)</span> in a sequence <span class="math notranslate nohighlight">\(s_1\)</span>
starting at index <span class="math notranslate nohighlight">\(i\)</span>. If the index is negative or greater than the
length of sequence <span class="math notranslate nohighlight">\(s_1\)</span> or the subsequence <span class="math notranslate nohighlight">\(s_2\)</span> does not
appear in sequence <span class="math notranslate nohighlight">\(s_1\)</span> after index <span class="math notranslate nohighlight">\(i\)</span>, the result is -1.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">3</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of sequence Sort (<span class="math notranslate nohighlight">\(s_1\)</span>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">2:</span></code> Term of sequence Sort (<span class="math notranslate nohighlight">\(s_2\)</span>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">3:</span></code> Term of Sort Int (<span class="math notranslate nohighlight">\(i\)</span>)</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.SEQ_LENGTH">
<span class="sig-name descname"><span class="pre">SEQ_LENGTH</span></span><a class="headerlink" href="#cvc5.Kind.SEQ_LENGTH" title="Link to this definition"></a></dt>
<dd><p>Sequence length.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">1</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of sequence Sort</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.SEQ_NTH">
<span class="sig-name descname"><span class="pre">SEQ_NTH</span></span><a class="headerlink" href="#cvc5.Kind.SEQ_NTH" title="Link to this definition"></a></dt>
<dd><p>Sequence nth.</p>
<p>Corresponds to the nth element of a sequence.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">2</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of sequence Sort</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">2:</span></code> Term of Sort Int (<span class="math notranslate nohighlight">\(n\)</span>)</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.SEQ_PREFIX">
<span class="sig-name descname"><span class="pre">SEQ_PREFIX</span></span><a class="headerlink" href="#cvc5.Kind.SEQ_PREFIX" title="Link to this definition"></a></dt>
<dd><p>Sequence prefix-of.</p>
<p>Checks whether a sequence <span class="math notranslate nohighlight">\(s_1\)</span> is a prefix of sequence <span class="math notranslate nohighlight">\(s_2\)</span>.
If sequence <span class="math notranslate nohighlight">\(s_1\)</span> is empty, this operator returns <code class="docutils literal notranslate"><span class="pre">true</span></code>.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">1</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of sequence Sort (<span class="math notranslate nohighlight">\(s_1\)</span>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">2:</span></code> Term of sequence Sort (<span class="math notranslate nohighlight">\(s_2\)</span>)</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.SEQ_REPLACE">
<span class="sig-name descname"><span class="pre">SEQ_REPLACE</span></span><a class="headerlink" href="#cvc5.Kind.SEQ_REPLACE" title="Link to this definition"></a></dt>
<dd><p>Sequence replace.</p>
<p>Replaces the first occurrence of a sequence <span class="math notranslate nohighlight">\(s_2\)</span> in a
sequence <span class="math notranslate nohighlight">\(s_1\)</span> with sequence <span class="math notranslate nohighlight">\(s_3\)</span>. If <span class="math notranslate nohighlight">\(s_2\)</span> does not
appear in <span class="math notranslate nohighlight">\(s_1\)</span>, <span class="math notranslate nohighlight">\(s_1\)</span> is returned unmodified.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">3</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of sequence Sort (<span class="math notranslate nohighlight">\(s_1\)</span>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">2:</span></code> Term of sequence Sort (<span class="math notranslate nohighlight">\(s_2\)</span>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">3:</span></code> Term of sequence Sort (<span class="math notranslate nohighlight">\(s_3\)</span>)</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.SEQ_REPLACE_ALL">
<span class="sig-name descname"><span class="pre">SEQ_REPLACE_ALL</span></span><a class="headerlink" href="#cvc5.Kind.SEQ_REPLACE_ALL" title="Link to this definition"></a></dt>
<dd><p>Sequence replace all.</p>
<p>Replaces all occurrences of a sequence <span class="math notranslate nohighlight">\(s_2\)</span> in a sequence
<span class="math notranslate nohighlight">\(s_1\)</span> with sequence <span class="math notranslate nohighlight">\(s_3\)</span>. If <span class="math notranslate nohighlight">\(s_2\)</span> does not appear in
<span class="math notranslate nohighlight">\(s_1\)</span>, sequence <span class="math notranslate nohighlight">\(s_1\)</span> is returned unmodified.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">3</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of sequence Sort (<span class="math notranslate nohighlight">\(s_1\)</span>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">2:</span></code> Term of sequence Sort (<span class="math notranslate nohighlight">\(s_2\)</span>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">3:</span></code> Term of sequence Sort (<span class="math notranslate nohighlight">\(s_3\)</span>)</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.SEQ_REV">
<span class="sig-name descname"><span class="pre">SEQ_REV</span></span><a class="headerlink" href="#cvc5.Kind.SEQ_REV" title="Link to this definition"></a></dt>
<dd><p>Sequence reverse.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">1</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of sequence Sort</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.SEQ_SUFFIX">
<span class="sig-name descname"><span class="pre">SEQ_SUFFIX</span></span><a class="headerlink" href="#cvc5.Kind.SEQ_SUFFIX" title="Link to this definition"></a></dt>
<dd><p>Sequence suffix-of.</p>
<p>Checks whether a sequence <span class="math notranslate nohighlight">\(s_1\)</span> is a suffix of sequence <span class="math notranslate nohighlight">\(s_2\)</span>.
If sequence <span class="math notranslate nohighlight">\(s_1\)</span> is empty, this operator returns <code class="docutils literal notranslate"><span class="pre">true</span></code>.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">1</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of sequence Sort (<span class="math notranslate nohighlight">\(s_1\)</span>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">2:</span></code> Term of sequence Sort (<span class="math notranslate nohighlight">\(s_2\)</span>)</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.SEQ_UNIT">
<span class="sig-name descname"><span class="pre">SEQ_UNIT</span></span><a class="headerlink" href="#cvc5.Kind.SEQ_UNIT" title="Link to this definition"></a></dt>
<dd><p>Sequence unit.</p>
<p>Corresponds to a sequence of length one with the given term.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">1</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of any Sort (the element term)</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.SEQ_UPDATE">
<span class="sig-name descname"><span class="pre">SEQ_UPDATE</span></span><a class="headerlink" href="#cvc5.Kind.SEQ_UPDATE" title="Link to this definition"></a></dt>
<dd><p>Sequence update.</p>
<p>Updates a sequence <span class="math notranslate nohighlight">\(s\)</span> by replacing its context starting at an index
with string <span class="math notranslate nohighlight">\(t\)</span>. If the start index is negative, the start index is
greater than the length of the sequence, the result is <span class="math notranslate nohighlight">\(s\)</span>.
Otherwise, the length of the original sequence is preserved.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">3</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of sequence Sort</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">2:</span></code> Term of Sort Int (index <span class="math notranslate nohighlight">\(i\)</span>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">3:</span></code> Term of sequence Sort (replacement sequence <span class="math notranslate nohighlight">\(t\)</span>)</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.SET_ALL">
<span class="sig-name descname"><span class="pre">SET_ALL</span></span><a class="headerlink" href="#cvc5.Kind.SET_ALL" title="Link to this definition"></a></dt>
<dd><p>Set all.</p>
<p>This operator checks whether all elements of a set satisfy a predicate.
(set.all <span class="math notranslate nohighlight">\(p \; A\)</span>) takes a predicate <span class="math notranslate nohighlight">\(p\)</span> of Sort
<span class="math notranslate nohighlight">\((\rightarrow T \; Bool)\)</span> as a first argument, and a set <span class="math notranslate nohighlight">\(A\)</span>
of Sort (Set <span class="math notranslate nohighlight">\(T\)</span>) as a second argument, and returns true iff all
elements of <span class="math notranslate nohighlight">\(A\)</span> satisfy predicate <span class="math notranslate nohighlight">\(p\)</span>.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">2</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of function Sort <span class="math notranslate nohighlight">\((\rightarrow T \; Bool)\)</span></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">2:</span></code> Term of set Sort (Set <span class="math notranslate nohighlight">\(T\)</span>)</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
</ul>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This kind is experimental and may be changed or removed in
future versions.</p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.SET_CARD">
<span class="sig-name descname"><span class="pre">SET_CARD</span></span><a class="headerlink" href="#cvc5.Kind.SET_CARD" title="Link to this definition"></a></dt>
<dd><p>Set cardinality.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">1</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of set Sort</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.SET_CHOOSE">
<span class="sig-name descname"><span class="pre">SET_CHOOSE</span></span><a class="headerlink" href="#cvc5.Kind.SET_CHOOSE" title="Link to this definition"></a></dt>
<dd><p>Set choose.</p>
<p>Select an element from a given set. For a set <span class="math notranslate nohighlight">\(A = \{x\}\)</span>, the term
(set.choose <span class="math notranslate nohighlight">\(A\)</span>) is equivalent to the term <span class="math notranslate nohighlight">\(x_1\)</span>. For an empty
set, it is an arbitrary value. For a set with cardinality &gt; 1, it will
deterministically return an element in <span class="math notranslate nohighlight">\(A\)</span>.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">1</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of set Sort</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This kind is experimental and may be changed or removed in future
versions.</p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.SET_COMPLEMENT">
<span class="sig-name descname"><span class="pre">SET_COMPLEMENT</span></span><a class="headerlink" href="#cvc5.Kind.SET_COMPLEMENT" title="Link to this definition"></a></dt>
<dd><p>Set complement with respect to finite universe.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">1</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of set Sort</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.SET_COMPREHENSION">
<span class="sig-name descname"><span class="pre">SET_COMPREHENSION</span></span><a class="headerlink" href="#cvc5.Kind.SET_COMPREHENSION" title="Link to this definition"></a></dt>
<dd><p>Set comprehension</p>
<p>A set comprehension is specified by a variable list <span class="math notranslate nohighlight">\(x_1 ... x_n\)</span>,
a predicate <span class="math notranslate nohighlight">\(P[x_1...x_n]\)</span>, and a term <span class="math notranslate nohighlight">\(t[x_1...x_n]\)</span>. A
comprehension <span class="math notranslate nohighlight">\(C\)</span> with the above form has members given by the
following semantics:</p>
<div class="math notranslate nohighlight">
\[\forall y. ( \exists x_1...x_n. P[x_1...x_n] \wedge t[x_1...x_n] = y )
\Leftrightarrow (set.member \; y \; C)\]</div>
<p>where <span class="math notranslate nohighlight">\(y\)</span> ranges over the element Sort of the (set) Sort of the
comprehension. If <span class="math notranslate nohighlight">\(t[x_1..x_n]\)</span> is not provided, it is equivalent
to <span class="math notranslate nohighlight">\(y\)</span> in the above formula.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">3</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of Kind <a class="reference internal" href="#cvc5.Kind.VARIABLE_LIST" title="cvc5.Kind.VARIABLE_LIST"><code class="xref py py-obj docutils literal notranslate"><span class="pre">VARIABLE_LIST</span></code></a></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">2:</span></code> Term of sort Bool (the predicate of the comprehension)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">3:</span></code> (optional) Term denoting the generator for the comprehension</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This kind is experimental and may be changed or removed in future
versions.</p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.SET_EMPTY">
<span class="sig-name descname"><span class="pre">SET_EMPTY</span></span><a class="headerlink" href="#cvc5.Kind.SET_EMPTY" title="Link to this definition"></a></dt>
<dd><p>Empty set.</p>
<ul class="simple">
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkEmptySet(const Sort&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.SET_FILTER">
<span class="sig-name descname"><span class="pre">SET_FILTER</span></span><a class="headerlink" href="#cvc5.Kind.SET_FILTER" title="Link to this definition"></a></dt>
<dd><p>Set filter.</p>
<p>This operator filters the elements of a set.
(set.filter <span class="math notranslate nohighlight">\(p \; A\)</span>) takes a predicate <span class="math notranslate nohighlight">\(p\)</span> of Sort
<span class="math notranslate nohighlight">\((\rightarrow T \; Bool)\)</span> as a first argument, and a set <span class="math notranslate nohighlight">\(A\)</span>
of Sort (Set <span class="math notranslate nohighlight">\(T\)</span>) as a second argument, and returns a subset of Sort
(Set <span class="math notranslate nohighlight">\(T\)</span>) that includes all elements of <span class="math notranslate nohighlight">\(A\)</span> that satisfy
<span class="math notranslate nohighlight">\(p\)</span>.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">2</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of function Sort <span class="math notranslate nohighlight">\((\rightarrow T \; Bool)\)</span></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">2:</span></code> Term of bag Sort (Set <span class="math notranslate nohighlight">\(T\)</span>)</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
</ul>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This kind is experimental and may be changed or removed in future
versions.</p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.SET_FOLD">
<span class="sig-name descname"><span class="pre">SET_FOLD</span></span><a class="headerlink" href="#cvc5.Kind.SET_FOLD" title="Link to this definition"></a></dt>
<dd><p>Set fold.</p>
<p>This operator combines elements of a set into a single value.
(set.fold <span class="math notranslate nohighlight">\(f \; t \; A\)</span>) folds the elements of set <span class="math notranslate nohighlight">\(A\)</span>
starting with Term <span class="math notranslate nohighlight">\(t\)</span> and using the combining function <span class="math notranslate nohighlight">\(f\)</span>.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">2</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of function Sort <span class="math notranslate nohighlight">\((\rightarrow S_1 \; S_2 \; S_2)\)</span></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">2:</span></code> Term of Sort <span class="math notranslate nohighlight">\(S_2\)</span> (the initial value)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">3:</span></code> Term of bag Sort (Set <span class="math notranslate nohighlight">\(S_1\)</span>)</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
</ul>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This kind is experimental and may be changed or removed in future
versions.</p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.SET_INSERT">
<span class="sig-name descname"><span class="pre">SET_INSERT</span></span><a class="headerlink" href="#cvc5.Kind.SET_INSERT" title="Link to this definition"></a></dt>
<dd><p>The set obtained by inserting elements;</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">&gt;</span> <span class="pre">0</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1..n-1:</span></code> Terms of any Sort (must match the element sort of the given set Term)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">n:</span></code> Term of set Sort</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.SET_INTER">
<span class="sig-name descname"><span class="pre">SET_INTER</span></span><a class="headerlink" href="#cvc5.Kind.SET_INTER" title="Link to this definition"></a></dt>
<dd><p>Set intersection.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">2</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1..2:</span></code> Terms of set Sort</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.SET_IS_EMPTY">
<span class="sig-name descname"><span class="pre">SET_IS_EMPTY</span></span><a class="headerlink" href="#cvc5.Kind.SET_IS_EMPTY" title="Link to this definition"></a></dt>
<dd><p>Set is empty tester.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">1</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of set Sort</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This kind is experimental and may be changed or removed in future
versions.</p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.SET_IS_SINGLETON">
<span class="sig-name descname"><span class="pre">SET_IS_SINGLETON</span></span><a class="headerlink" href="#cvc5.Kind.SET_IS_SINGLETON" title="Link to this definition"></a></dt>
<dd><p>Set is singleton tester.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">1</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of set Sort</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This kind is experimental and may be changed or removed in future
versions.</p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.SET_MAP">
<span class="sig-name descname"><span class="pre">SET_MAP</span></span><a class="headerlink" href="#cvc5.Kind.SET_MAP" title="Link to this definition"></a></dt>
<dd><p>Set map.</p>
<p>This operator applies the first argument, a function of
Sort <span class="math notranslate nohighlight">\((\rightarrow S_1 \; S_2)\)</span>, to every element of the second
argument, a set of Sort (Set <span class="math notranslate nohighlight">\(S_1\)</span>), and returns a set of Sort
(Set <span class="math notranslate nohighlight">\(S_2\)</span>).</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">2</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of function Sort <span class="math notranslate nohighlight">\((\rightarrow S_1 \; S_2)\)</span></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">2:</span></code> Term of set Sort (Set <span class="math notranslate nohighlight">\(S_1\)</span>)</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This kind is experimental and may be changed or removed in future
versions.</p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.SET_MEMBER">
<span class="sig-name descname"><span class="pre">SET_MEMBER</span></span><a class="headerlink" href="#cvc5.Kind.SET_MEMBER" title="Link to this definition"></a></dt>
<dd><p>Set membership predicate.</p>
<p>Determines if the given set element is a member of the second set.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">2</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of any Sort (must match the element Sort of the given set Term)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">2:</span></code> Term of set Sort</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.SET_MINUS">
<span class="sig-name descname"><span class="pre">SET_MINUS</span></span><a class="headerlink" href="#cvc5.Kind.SET_MINUS" title="Link to this definition"></a></dt>
<dd><p>Set subtraction.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">2</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1..2:</span></code> Terms of set Sort</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.SET_SINGLETON">
<span class="sig-name descname"><span class="pre">SET_SINGLETON</span></span><a class="headerlink" href="#cvc5.Kind.SET_SINGLETON" title="Link to this definition"></a></dt>
<dd><p>Singleton set.</p>
<p>Construct a singleton set from an element given as a parameter.
The returned set has the same Sort as the element.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">1</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of any Sort (the set element)</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.SET_SOME">
<span class="sig-name descname"><span class="pre">SET_SOME</span></span><a class="headerlink" href="#cvc5.Kind.SET_SOME" title="Link to this definition"></a></dt>
<dd><p>Set some.</p>
<p>This operator checks whether at least one element of a set satisfies a predicate.
(set.some <span class="math notranslate nohighlight">\(p \; A\)</span>) takes a predicate <span class="math notranslate nohighlight">\(p\)</span> of Sort
<span class="math notranslate nohighlight">\((\rightarrow T \; Bool)\)</span> as a first argument, and a set <span class="math notranslate nohighlight">\(A\)</span>
of Sort (Set <span class="math notranslate nohighlight">\(T\)</span>) as a second argument, and returns true iff at least
one element of <span class="math notranslate nohighlight">\(A\)</span> satisfies predicate <span class="math notranslate nohighlight">\(p\)</span>.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">2</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of function Sort <span class="math notranslate nohighlight">\((\rightarrow T \; Bool)\)</span></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">2:</span></code> Term of set Sort (Set <span class="math notranslate nohighlight">\(T\)</span>)</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
</ul>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This kind is experimental and may be changed or removed in
future versions.</p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.SET_SUBSET">
<span class="sig-name descname"><span class="pre">SET_SUBSET</span></span><a class="headerlink" href="#cvc5.Kind.SET_SUBSET" title="Link to this definition"></a></dt>
<dd><p>Subset predicate.</p>
<p>Determines if the first set is a subset of the second set.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">2</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1..2:</span></code> Terms of set Sort</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.SET_UNION">
<span class="sig-name descname"><span class="pre">SET_UNION</span></span><a class="headerlink" href="#cvc5.Kind.SET_UNION" title="Link to this definition"></a></dt>
<dd><p>Set union.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">2</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1..2:</span></code> Terms of set Sort</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.SET_UNIVERSE">
<span class="sig-name descname"><span class="pre">SET_UNIVERSE</span></span><a class="headerlink" href="#cvc5.Kind.SET_UNIVERSE" title="Link to this definition"></a></dt>
<dd><p>Finite universe set.</p>
<p>All set variables must be interpreted as subsets of it.</p>
<ul class="simple">
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkUniverseSet(const Sort&amp;)</p></li>
</ul>
</li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><a class="reference internal" href="#cvc5.Kind.SET_UNIVERSE" title="cvc5.Kind.SET_UNIVERSE"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SET_UNIVERSE</span></code></a> is considered a special symbol of the
theory of sets and is not considered as a set value, i.e.,
<a class="reference internal" href="term.html#cvc5.Term.isSetValue" title="cvc5.Term.isSetValue"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Term.isSetValue()</span></code></a> will return <code class="docutils literal notranslate"><span class="pre">false</span></code>.</p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.SEXPR">
<span class="sig-name descname"><span class="pre">SEXPR</span></span><a class="headerlink" href="#cvc5.Kind.SEXPR" title="Link to this definition"></a></dt>
<dd><p>Symbolic expression.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">&gt;</span> <span class="pre">0</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1..n:</span></code> Terms with same sorts</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This kind is experimental and may be changed or removed in future
versions.</p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.SINE">
<span class="sig-name descname"><span class="pre">SINE</span></span><a class="headerlink" href="#cvc5.Kind.SINE" title="Link to this definition"></a></dt>
<dd><p>Sine function.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">1</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of Sort Real</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.SKOLEM">
<span class="sig-name descname"><span class="pre">SKOLEM</span></span><a class="headerlink" href="#cvc5.Kind.SKOLEM" title="Link to this definition"></a></dt>
<dd><p>A Skolem.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Represents an internally generated term. Information on the skolem is
available via the calls Term::getSkolemId and
Term::getSkolemIndices.</p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.SKOLEM_ADD_TO_POOL">
<span class="sig-name descname"><span class="pre">SKOLEM_ADD_TO_POOL</span></span><a class="headerlink" href="#cvc5.Kind.SKOLEM_ADD_TO_POOL" title="Link to this definition"></a></dt>
<dd><p>A skolemization-add-to-pool annotation.</p>
<p>An skolemization-add-to-pool annotation indicates that when a quantified
formula is skolemized, the skolemized version of a term should be added to
the given pool.</p>
<p>For example, consider a quantified formula:</p>
<div class="highlight-lisp notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="nv">FORALL</span><span class="w"> </span><span class="p">(</span><span class="nv">VARIABLE_LIST</span><span class="w"> </span><span class="nv">x</span><span class="p">)</span><span class="w"> </span><span class="nv">F</span>
<span class="w">        </span><span class="p">(</span><span class="nv">INST_PATTERN_LIST</span><span class="w"> </span><span class="p">(</span><span class="nv">SKOLEM_ADD_TO_POOL</span><span class="w"> </span><span class="p">(</span><span class="nv">ADD</span><span class="w"> </span><span class="nv">x</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="nv">p</span><span class="p">)))</span>
</pre></div>
</div>
<p>where assume that <span class="math notranslate nohighlight">\(x\)</span> has type Int. When this quantified formula is
skolemized, e.g., with <span class="math notranslate nohighlight">\(k\)</span> of type Int, then the term <code class="docutils literal notranslate"><span class="pre">(ADD</span> <span class="pre">k</span> <span class="pre">1)</span></code>
is added to the pool <span class="math notranslate nohighlight">\(p\)</span>.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">2</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> The Term whose free variables are bound by the quantified formula.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">2:</span></code> The pool to add to, whose Sort should be a set of elements that match the Sort of the first argument.</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This kind is experimental and may be changed or removed in future
versions.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Should only be used as a child of <a class="reference internal" href="#cvc5.Kind.INST_PATTERN_LIST" title="cvc5.Kind.INST_PATTERN_LIST"><code class="xref py py-obj docutils literal notranslate"><span class="pre">INST_PATTERN_LIST</span></code></a>.</p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.SQRT">
<span class="sig-name descname"><span class="pre">SQRT</span></span><a class="headerlink" href="#cvc5.Kind.SQRT" title="Link to this definition"></a></dt>
<dd><p>Square root.</p>
<p>If the argument <cite>x</cite> is non-negative, then this returns a non-negative value
<cite>y</cite> such that <cite>y * y = x</cite>.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">1</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of Sort Real</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.STAR_CONTAINS">
<span class="sig-name descname"><span class="pre">STAR_CONTAINS</span></span><a class="headerlink" href="#cvc5.Kind.STAR_CONTAINS" title="Link to this definition"></a></dt>
<dd><p>Star contains predicate.
Given a set S of integer vectors of the same dimension,
the star operator represents the set of all linear combinations
of vectors from S.
Here we are interested only in sets of vectors given using
set-builder notation (set comprehension).
The syntax of the operator is
(int.star-contains ((x_1 Int) … (x_n Int)) p (y_1,…, y_n))
where ((x_1 Int) … (x_n Int)) are integer bound variables,
p is a first order formula of sort bool with free variables
among x_1,…,x_n, and (y_1,…, y_n) is a vector of integers.
Either p(y_1,…, y_n) holds or there is exists
nonnegative integers lambda_1,…,lambda_k  and vectors
v_1,…,v_k such that p(v_i) holds for all i=1,…,k and
(y_1,…, y_n) = lambda_1*v_1 + … + lambda_k*v_k.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.STORE">
<span class="sig-name descname"><span class="pre">STORE</span></span><a class="headerlink" href="#cvc5.Kind.STORE" title="Link to this definition"></a></dt>
<dd><p>Array store.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">3</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of array Sort</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">2:</span></code> Term of array index Sort</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">3:</span></code> Term of array element Sort</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.STRING_CHARAT">
<span class="sig-name descname"><span class="pre">STRING_CHARAT</span></span><a class="headerlink" href="#cvc5.Kind.STRING_CHARAT" title="Link to this definition"></a></dt>
<dd><p>String character at.</p>
<p>Returns the character at index <span class="math notranslate nohighlight">\(i\)</span> from a string <span class="math notranslate nohighlight">\(s\)</span>. If the
index is negative or the index is greater than the length of the string,
the result is the empty string. Otherwise the result is a string of
length 1.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">2</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of Sort String (string <span class="math notranslate nohighlight">\(s\)</span>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">2:</span></code> Term of Sort Int (index <span class="math notranslate nohighlight">\(i\)</span>)</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.STRING_CONCAT">
<span class="sig-name descname"><span class="pre">STRING_CONCAT</span></span><a class="headerlink" href="#cvc5.Kind.STRING_CONCAT" title="Link to this definition"></a></dt>
<dd><p>String concat.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">&gt;</span> <span class="pre">1</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1..n:</span></code> Terms of Sort String</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.STRING_CONTAINS">
<span class="sig-name descname"><span class="pre">STRING_CONTAINS</span></span><a class="headerlink" href="#cvc5.Kind.STRING_CONTAINS" title="Link to this definition"></a></dt>
<dd><p>String contains.</p>
<p>Determines whether a string <span class="math notranslate nohighlight">\(s_1\)</span> contains another string
<span class="math notranslate nohighlight">\(s_2\)</span>. If <span class="math notranslate nohighlight">\(s_2\)</span> is empty, the result is always <code class="docutils literal notranslate"><span class="pre">true</span></code>.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">2</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of Sort String (the string <span class="math notranslate nohighlight">\(s_1\)</span>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">2:</span></code> Term of Sort String (the string <span class="math notranslate nohighlight">\(s_2\)</span>)</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.STRING_FROM_CODE">
<span class="sig-name descname"><span class="pre">STRING_FROM_CODE</span></span><a class="headerlink" href="#cvc5.Kind.STRING_FROM_CODE" title="Link to this definition"></a></dt>
<dd><p>String from code.</p>
<p>Returns a string containing a single character whose code point matches
the argument to this function, or the empty string if the argument is
out-of-bounds.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">1</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of Sort Int</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.STRING_FROM_INT">
<span class="sig-name descname"><span class="pre">STRING_FROM_INT</span></span><a class="headerlink" href="#cvc5.Kind.STRING_FROM_INT" title="Link to this definition"></a></dt>
<dd><p>Conversion from Int to String.</p>
<p>If the integer is negative this operator returns the empty string.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">1</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of Sort Int</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.STRING_INDEXOF">
<span class="sig-name descname"><span class="pre">STRING_INDEXOF</span></span><a class="headerlink" href="#cvc5.Kind.STRING_INDEXOF" title="Link to this definition"></a></dt>
<dd><p>String index-of.</p>
<p>Returns the index of a substring <span class="math notranslate nohighlight">\(s_2\)</span> in a string <span class="math notranslate nohighlight">\(s_1\)</span>
starting at index <span class="math notranslate nohighlight">\(i\)</span>. If the index is negative or greater than the
length of string <span class="math notranslate nohighlight">\(s_1\)</span> or the substring <span class="math notranslate nohighlight">\(s_2\)</span> does not appear
in string <span class="math notranslate nohighlight">\(s_1\)</span> after index <span class="math notranslate nohighlight">\(i\)</span>, the result is -1.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">2</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of Sort String (substring <span class="math notranslate nohighlight">\(s_1\)</span>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">2:</span></code> Term of Sort String (substring <span class="math notranslate nohighlight">\(s_2\)</span>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">3:</span></code> Term of Sort Int (index <span class="math notranslate nohighlight">\(i\)</span>)</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.STRING_INDEXOF_RE">
<span class="sig-name descname"><span class="pre">STRING_INDEXOF_RE</span></span><a class="headerlink" href="#cvc5.Kind.STRING_INDEXOF_RE" title="Link to this definition"></a></dt>
<dd><p>String index-of regular expression match.</p>
<p>Returns the first match of a regular expression <span class="math notranslate nohighlight">\(r\)</span> in a
string <span class="math notranslate nohighlight">\(s\)</span>. If the index is negative or greater than the length of
string <span class="math notranslate nohighlight">\(s_1\)</span>, or <span class="math notranslate nohighlight">\(r\)</span> does not match a substring in <span class="math notranslate nohighlight">\(s\)</span>
after index <span class="math notranslate nohighlight">\(i\)</span>, the result is -1.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">3</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of Sort String (string <span class="math notranslate nohighlight">\(s\)</span>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">2:</span></code> Term of Sort RegLan (regular expression <span class="math notranslate nohighlight">\(r\)</span>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">3:</span></code> Term of Sort Int (index <span class="math notranslate nohighlight">\(i\)</span>)</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.STRING_IN_REGEXP">
<span class="sig-name descname"><span class="pre">STRING_IN_REGEXP</span></span><a class="headerlink" href="#cvc5.Kind.STRING_IN_REGEXP" title="Link to this definition"></a></dt>
<dd><p>String membership.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">2</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of Sort String</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">2:</span></code> Term of Sort RegLan</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.STRING_IS_DIGIT">
<span class="sig-name descname"><span class="pre">STRING_IS_DIGIT</span></span><a class="headerlink" href="#cvc5.Kind.STRING_IS_DIGIT" title="Link to this definition"></a></dt>
<dd><p>String is-digit.</p>
<p>Returns true if given string is a digit (it is one of <code class="docutils literal notranslate"><span class="pre">&quot;0&quot;</span></code>, …,
<code class="docutils literal notranslate"><span class="pre">&quot;9&quot;</span></code>).</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">1</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of Sort String</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.STRING_LENGTH">
<span class="sig-name descname"><span class="pre">STRING_LENGTH</span></span><a class="headerlink" href="#cvc5.Kind.STRING_LENGTH" title="Link to this definition"></a></dt>
<dd><p>String length.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">1</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of Sort String</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.STRING_LEQ">
<span class="sig-name descname"><span class="pre">STRING_LEQ</span></span><a class="headerlink" href="#cvc5.Kind.STRING_LEQ" title="Link to this definition"></a></dt>
<dd><p>String less than or equal.</p>
<p>Returns true if string <span class="math notranslate nohighlight">\(s_1\)</span> is less than or equal to <span class="math notranslate nohighlight">\(s_2\)</span>
based on a lexiographic ordering over code points.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">2</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of Sort String (<span class="math notranslate nohighlight">\(s_1\)</span>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">2:</span></code> Term of Sort String (<span class="math notranslate nohighlight">\(s_2\)</span>)</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.STRING_LT">
<span class="sig-name descname"><span class="pre">STRING_LT</span></span><a class="headerlink" href="#cvc5.Kind.STRING_LT" title="Link to this definition"></a></dt>
<dd><p>String less than.</p>
<p>Returns true if string <span class="math notranslate nohighlight">\(s_1\)</span> is (strictly) less than <span class="math notranslate nohighlight">\(s_2\)</span>
based on a lexiographic ordering over code points.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">2</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of Sort String (<span class="math notranslate nohighlight">\(s_1\)</span>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">2:</span></code> Term of Sort String (<span class="math notranslate nohighlight">\(s_2\)</span>)</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.STRING_PREFIX">
<span class="sig-name descname"><span class="pre">STRING_PREFIX</span></span><a class="headerlink" href="#cvc5.Kind.STRING_PREFIX" title="Link to this definition"></a></dt>
<dd><p>String prefix-of.</p>
<p>Determines whether a string <span class="math notranslate nohighlight">\(s_1\)</span> is a prefix of string <span class="math notranslate nohighlight">\(s_2\)</span>.
If string s1 is empty, this operator returns <code class="docutils literal notranslate"><span class="pre">true</span></code>.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">2</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of Sort String (<span class="math notranslate nohighlight">\(s_1\)</span>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">2:</span></code> Term of Sort String (<span class="math notranslate nohighlight">\(s_2\)</span>)</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.STRING_REPLACE">
<span class="sig-name descname"><span class="pre">STRING_REPLACE</span></span><a class="headerlink" href="#cvc5.Kind.STRING_REPLACE" title="Link to this definition"></a></dt>
<dd><p>String replace.</p>
<p>Replaces a string <span class="math notranslate nohighlight">\(s_2\)</span> in a string <span class="math notranslate nohighlight">\(s_1\)</span> with string
<span class="math notranslate nohighlight">\(s_3\)</span>. If <span class="math notranslate nohighlight">\(s_2\)</span> does not appear in <span class="math notranslate nohighlight">\(s_1\)</span>, <span class="math notranslate nohighlight">\(s_1\)</span> is
returned unmodified.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">3</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of Sort String (string <span class="math notranslate nohighlight">\(s_1\)</span>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">2:</span></code> Term of Sort String (string <span class="math notranslate nohighlight">\(s_2\)</span>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">3:</span></code> Term of Sort String (string <span class="math notranslate nohighlight">\(s_3\)</span>)</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.STRING_REPLACE_ALL">
<span class="sig-name descname"><span class="pre">STRING_REPLACE_ALL</span></span><a class="headerlink" href="#cvc5.Kind.STRING_REPLACE_ALL" title="Link to this definition"></a></dt>
<dd><p>String replace all.</p>
<p>Replaces all occurrences of a string <span class="math notranslate nohighlight">\(s_2\)</span> in a string <span class="math notranslate nohighlight">\(s_1\)</span>
with string <span class="math notranslate nohighlight">\(s_3\)</span>. If <span class="math notranslate nohighlight">\(s_2\)</span> does not appear in <span class="math notranslate nohighlight">\(s_1\)</span>,
<span class="math notranslate nohighlight">\(s_1\)</span> is returned unmodified.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">3</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of Sort String (<span class="math notranslate nohighlight">\(s_1\)</span>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">2:</span></code> Term of Sort String (<span class="math notranslate nohighlight">\(s_2\)</span>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">3:</span></code> Term of Sort String (<span class="math notranslate nohighlight">\(s_3\)</span>)</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.STRING_REPLACE_RE">
<span class="sig-name descname"><span class="pre">STRING_REPLACE_RE</span></span><a class="headerlink" href="#cvc5.Kind.STRING_REPLACE_RE" title="Link to this definition"></a></dt>
<dd><p>String replace regular expression match.</p>
<p>Replaces the first match of a regular expression <span class="math notranslate nohighlight">\(r\)</span> in
string <span class="math notranslate nohighlight">\(s_1\)</span> with string <span class="math notranslate nohighlight">\(s_2\)</span>. If <span class="math notranslate nohighlight">\(r\)</span> does not match a
substring of <span class="math notranslate nohighlight">\(s_1\)</span>, <span class="math notranslate nohighlight">\(s_1\)</span> is returned unmodified.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">3</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of Sort String (<span class="math notranslate nohighlight">\(s_1\)</span>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">2:</span></code> Term of Sort RegLan</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">3:</span></code> Term of Sort String (<span class="math notranslate nohighlight">\(s_2\)</span>)</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.STRING_REPLACE_RE_ALL">
<span class="sig-name descname"><span class="pre">STRING_REPLACE_RE_ALL</span></span><a class="headerlink" href="#cvc5.Kind.STRING_REPLACE_RE_ALL" title="Link to this definition"></a></dt>
<dd><p>String replace all regular expression matches.</p>
<p>Replaces all matches of a regular expression <span class="math notranslate nohighlight">\(r\)</span> in string
<span class="math notranslate nohighlight">\(s_1\)</span> with string <span class="math notranslate nohighlight">\(s_2\)</span>. If <span class="math notranslate nohighlight">\(r\)</span> does not match a
substring of <span class="math notranslate nohighlight">\(s_1\)</span>, string <span class="math notranslate nohighlight">\(s_1\)</span> is returned unmodified.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">3</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of Sort String (<span class="math notranslate nohighlight">\(s_1\)</span>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">2:</span></code> Term of Sort RegLan</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">3:</span></code> Term of Sort String (<span class="math notranslate nohighlight">\(s_2\)</span>)</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.STRING_REV">
<span class="sig-name descname"><span class="pre">STRING_REV</span></span><a class="headerlink" href="#cvc5.Kind.STRING_REV" title="Link to this definition"></a></dt>
<dd><p>String reverse.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">1</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of Sort String</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.STRING_SUBSTR">
<span class="sig-name descname"><span class="pre">STRING_SUBSTR</span></span><a class="headerlink" href="#cvc5.Kind.STRING_SUBSTR" title="Link to this definition"></a></dt>
<dd><p>String substring.</p>
<p>Extracts a substring, starting at index <span class="math notranslate nohighlight">\(i\)</span> and of length <span class="math notranslate nohighlight">\(l\)</span>,
from a string <span class="math notranslate nohighlight">\(s\)</span>.  If the start index is negative, the start index
is greater than the length of the string, or the length is negative, the
result is the empty string.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">3</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of Sort String</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">2:</span></code> Term of Sort Int (index <span class="math notranslate nohighlight">\(i\)</span>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">3:</span></code> Term of Sort Int (length <span class="math notranslate nohighlight">\(l\)</span>)</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.STRING_SUFFIX">
<span class="sig-name descname"><span class="pre">STRING_SUFFIX</span></span><a class="headerlink" href="#cvc5.Kind.STRING_SUFFIX" title="Link to this definition"></a></dt>
<dd><p>String suffix-of.</p>
<p>Determines whether a string <span class="math notranslate nohighlight">\(s_1\)</span> is a suffix of the second string.
If string <span class="math notranslate nohighlight">\(s_1\)</span> is empty, this operator returns <code class="docutils literal notranslate"><span class="pre">true</span></code>.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">2</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of Sort String (<span class="math notranslate nohighlight">\(s_1\)</span>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">2:</span></code> Term of Sort String (<span class="math notranslate nohighlight">\(s_2\)</span>)</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.STRING_TO_CODE">
<span class="sig-name descname"><span class="pre">STRING_TO_CODE</span></span><a class="headerlink" href="#cvc5.Kind.STRING_TO_CODE" title="Link to this definition"></a></dt>
<dd><p>String to code.</p>
<p>Returns the code point of a string if it has length one, or returns <cite>-1</cite>
otherwise.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">1</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of Sort String</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.STRING_TO_INT">
<span class="sig-name descname"><span class="pre">STRING_TO_INT</span></span><a class="headerlink" href="#cvc5.Kind.STRING_TO_INT" title="Link to this definition"></a></dt>
<dd><p>String to integer (total function).</p>
<p>If the string does not contain an integer or the integer is negative, the
operator returns <cite>-1</cite>.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">1</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of Sort Int</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.STRING_TO_LOWER">
<span class="sig-name descname"><span class="pre">STRING_TO_LOWER</span></span><a class="headerlink" href="#cvc5.Kind.STRING_TO_LOWER" title="Link to this definition"></a></dt>
<dd><p>String to lower case.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">1</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of Sort String</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.STRING_TO_REGEXP">
<span class="sig-name descname"><span class="pre">STRING_TO_REGEXP</span></span><a class="headerlink" href="#cvc5.Kind.STRING_TO_REGEXP" title="Link to this definition"></a></dt>
<dd><p>Conversion from string to regexp.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">1</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of Sort String</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.STRING_TO_UPPER">
<span class="sig-name descname"><span class="pre">STRING_TO_UPPER</span></span><a class="headerlink" href="#cvc5.Kind.STRING_TO_UPPER" title="Link to this definition"></a></dt>
<dd><p>String to upper case.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">1</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of Sort String</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.STRING_UPDATE">
<span class="sig-name descname"><span class="pre">STRING_UPDATE</span></span><a class="headerlink" href="#cvc5.Kind.STRING_UPDATE" title="Link to this definition"></a></dt>
<dd><p>String update.</p>
<p>Updates a string <span class="math notranslate nohighlight">\(s\)</span> by replacing its context starting at an index
with string <span class="math notranslate nohighlight">\(t\)</span>. If the start index is negative, the start index is
greater than the length of the string, the result is <span class="math notranslate nohighlight">\(s\)</span>. Otherwise,
the length of the original string is preserved.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">3</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of Sort String</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">2:</span></code> Term of Sort Int (index <span class="math notranslate nohighlight">\(i\)</span>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">3:</span></code> Term of Sort Strong (replacement string <span class="math notranslate nohighlight">\(t\)</span>)</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.SUB">
<span class="sig-name descname"><span class="pre">SUB</span></span><a class="headerlink" href="#cvc5.Kind.SUB" title="Link to this definition"></a></dt>
<dd><p>Arithmetic subtraction, left associative.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">&gt;</span> <span class="pre">1</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1..n:</span></code> Terms of Sort Int or Real (sorts must match)</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.TABLE_AGGREGATE">
<span class="sig-name descname"><span class="pre">TABLE_AGGREGATE</span></span><a class="headerlink" href="#cvc5.Kind.TABLE_AGGREGATE" title="Link to this definition"></a></dt>
<dd><p>Table aggregate operator has the form
<span class="math notranslate nohighlight">\(((\_ \; table.aggr \; n_1 ... n_k) \; f \; i \; A)\)</span>
where <span class="math notranslate nohighlight">\(n_1, ..., n_k\)</span> are natural numbers,
<span class="math notranslate nohighlight">\(f\)</span> is a function of type
<span class="math notranslate nohighlight">\((\rightarrow (Tuple \;  T_1 \; ... \; T_j)\; T \; T)\)</span>,
<span class="math notranslate nohighlight">\(i\)</span> has the type <span class="math notranslate nohighlight">\(T\)</span>,
and <span class="math notranslate nohighlight">\(A\)</span> has type <span class="math notranslate nohighlight">\((Table \;  T_1 \; ... \; T_j)\)</span>.
The returned type is <span class="math notranslate nohighlight">\((Bag \; T)\)</span>.</p>
<p>This operator aggregates elements in A that have the same tuple projection
with indices n_1, …, n_k using the combining function <span class="math notranslate nohighlight">\(f\)</span>,
and initial value <span class="math notranslate nohighlight">\(i\)</span>.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">3</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of sort <span class="math notranslate nohighlight">\((\rightarrow (Tuple \;  T_1 \; ... \; T_j)\; T \; T)\)</span></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">2:</span></code> Term of Sort <span class="math notranslate nohighlight">\(T\)</span></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">3:</span></code> Term of table sort <span class="math notranslate nohighlight">\(Table T_1 ... T_j\)</span></p></li>
</ul>
</li>
<li><p>Indices: <code class="docutils literal notranslate"><span class="pre">n</span></code>
- <code class="docutils literal notranslate"><span class="pre">1..n:</span></code> Indices of the projection</p></li>
<li><p>Create Term of this Kind with:
- TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>Create Op of this kind with:
- TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This kind is experimental and may be changed or removed in future
versions.</p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.TABLE_GROUP">
<span class="sig-name descname"><span class="pre">TABLE_GROUP</span></span><a class="headerlink" href="#cvc5.Kind.TABLE_GROUP" title="Link to this definition"></a></dt>
<dd><p>Table group</p>
<p><span class="math notranslate nohighlight">\(((\_ \; table.group \; n_1 \; \dots \; n_k) \; A)\)</span> partitions tuples
of table <span class="math notranslate nohighlight">\(A\)</span> such that tuples that have the same projection
with indices <span class="math notranslate nohighlight">\(n_1 \; \dots \; n_k\)</span> are in the same part.
It returns a bag of tables of type <span class="math notranslate nohighlight">\((Bag \; T)\)</span> where
<span class="math notranslate nohighlight">\(T\)</span> is the type of <span class="math notranslate nohighlight">\(A\)</span>.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">1</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of table sort</p></li>
</ul>
</li>
<li><p>Indices: <code class="docutils literal notranslate"><span class="pre">n</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1..n:</span></code>  Indices of the projection</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
</ul>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This kind is experimental and may be changed or removed in future
versions.</p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.TABLE_JOIN">
<span class="sig-name descname"><span class="pre">TABLE_JOIN</span></span><a class="headerlink" href="#cvc5.Kind.TABLE_JOIN" title="Link to this definition"></a></dt>
<dd><dl class="simple">
<dt>Table join operator has the form</dt><dd><p><span class="math notranslate nohighlight">\(((\_ \; table.join \; m_1 \; n_1 \; \dots \; m_k \; n_k) \; A \; B)\)</span>
where <span class="math notranslate nohighlight">\(m_1 \; n_1 \; \dots \; m_k \; n_k\)</span> are natural numbers,
and <span class="math notranslate nohighlight">\(A, B\)</span> are tables.
This operator filters the product of two bags based on the equality of
projected tuples using indices <span class="math notranslate nohighlight">\(m_1, \dots, m_k\)</span> in table <span class="math notranslate nohighlight">\(A\)</span>,
and indices <span class="math notranslate nohighlight">\(n_1, \dots, n_k\)</span> in table <span class="math notranslate nohighlight">\(B\)</span>.</p>
</dd>
</dl>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">2</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of table Sort</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">2:</span></code> Term of table Sort</p></li>
</ul>
</li>
<li><p>Indices: <code class="docutils literal notranslate"><span class="pre">n</span></code>
- <code class="docutils literal notranslate"><span class="pre">1..n:</span></code>  Indices of the projection</p></li>
<li><p>Create Term of this Kind with:
- TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>Create Op of this kind with:
- TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This kind is experimental and may be changed or removed in future
versions.</p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.TABLE_PRODUCT">
<span class="sig-name descname"><span class="pre">TABLE_PRODUCT</span></span><a class="headerlink" href="#cvc5.Kind.TABLE_PRODUCT" title="Link to this definition"></a></dt>
<dd><p>Table cross product.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">2</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1..2:</span></code> Terms of table Sort</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This kind is experimental and may be changed or removed in future
versions.</p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.TABLE_PROJECT">
<span class="sig-name descname"><span class="pre">TABLE_PROJECT</span></span><a class="headerlink" href="#cvc5.Kind.TABLE_PROJECT" title="Link to this definition"></a></dt>
<dd><p>Table projection operator extends tuple projection operator to tables.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">1</span></code>
- <code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of table Sort</p></li>
<li><p>Indices: <code class="docutils literal notranslate"><span class="pre">n</span></code>
- <code class="docutils literal notranslate"><span class="pre">1..n:</span></code> Indices of the projection</p></li>
<li><p>Create Term of this Kind with:
- TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>Create Op of this kind with:
- TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This kind is experimental and may be changed or removed in future
versions.</p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.TANGENT">
<span class="sig-name descname"><span class="pre">TANGENT</span></span><a class="headerlink" href="#cvc5.Kind.TANGENT" title="Link to this definition"></a></dt>
<dd><p>Tangent function.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">1</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of Sort Real</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.TO_INTEGER">
<span class="sig-name descname"><span class="pre">TO_INTEGER</span></span><a class="headerlink" href="#cvc5.Kind.TO_INTEGER" title="Link to this definition"></a></dt>
<dd><p>Convert Term of sort Int or Real to Int via the floor function.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">1</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of Sort Int or Real</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.TO_REAL">
<span class="sig-name descname"><span class="pre">TO_REAL</span></span><a class="headerlink" href="#cvc5.Kind.TO_REAL" title="Link to this definition"></a></dt>
<dd><p>Convert Term of Sort Int or Real to Real.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">1</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of Sort Int or Real</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.TUPLE_PROJECT">
<span class="sig-name descname"><span class="pre">TUPLE_PROJECT</span></span><a class="headerlink" href="#cvc5.Kind.TUPLE_PROJECT" title="Link to this definition"></a></dt>
<dd><p>Tuple projection.</p>
<p>This operator takes a tuple as an argument and returns a tuple obtained by
concatenating components of its argument at the provided indices.</p>
<p>For example,</p>
<div class="highlight-smtlib notranslate"><div class="highlight"><pre><span></span>((<span class="na">_</span> <span class="o">tuple.project</span> <span class="m">1</span> <span class="m">2</span> <span class="m">2</span> <span class="m">3</span> <span class="m">1</span>) (<span class="o">tuple</span> <span class="m">10</span> <span class="m">20</span> <span class="m">30</span> <span class="m">40</span>))
</pre></div>
</div>
<p>yields</p>
<div class="highlight-smtlib notranslate"><div class="highlight"><pre><span></span>(<span class="o">tuple</span> <span class="m">20</span> <span class="m">30</span> <span class="m">30</span> <span class="m">40</span> <span class="m">20</span>)
</pre></div>
</div>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">1</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of tuple Sort</p></li>
</ul>
</li>
<li><p>Indices: <code class="docutils literal notranslate"><span class="pre">n</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1..n:</span></code> The tuple indices to project</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.UNDEFINED_KIND">
<span class="sig-name descname"><span class="pre">UNDEFINED_KIND</span></span><a class="headerlink" href="#cvc5.Kind.UNDEFINED_KIND" title="Link to this definition"></a></dt>
<dd><p>Undefined kind.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Should never be exposed or created via the API.</p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.UNINTERPRETED_SORT_VALUE">
<span class="sig-name descname"><span class="pre">UNINTERPRETED_SORT_VALUE</span></span><a class="headerlink" href="#cvc5.Kind.UNINTERPRETED_SORT_VALUE" title="Link to this definition"></a></dt>
<dd><p>The value of an uninterpreted constant.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>May be returned as the result of an API call, but terms of this kind
may not be created explicitly via the API and may not appear in
assertions.</p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.VARIABLE">
<span class="sig-name descname"><span class="pre">VARIABLE</span></span><a class="headerlink" href="#cvc5.Kind.VARIABLE" title="Link to this definition"></a></dt>
<dd><p>(Bound) variable.</p>
<ul class="simple">
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkVar(const Sort&amp;, const std::optional&lt;std::string&gt;&amp;)</p></li>
</ul>
</li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Only permitted in bindings and in lambda and quantifier bodies.</p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.VARIABLE_LIST">
<span class="sig-name descname"><span class="pre">VARIABLE_LIST</span></span><a class="headerlink" href="#cvc5.Kind.VARIABLE_LIST" title="Link to this definition"></a></dt>
<dd><p>Variable list.</p>
<p>A list of variables (used to bind variables under a quantifier)</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">&gt;</span> <span class="pre">0</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1..n:</span></code> Terms of Kind <a class="reference internal" href="#cvc5.Kind.VARIABLE" title="cvc5.Kind.VARIABLE"><code class="xref py py-obj docutils literal notranslate"><span class="pre">VARIABLE</span></code></a></p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.WITNESS">
<span class="sig-name descname"><span class="pre">WITNESS</span></span><a class="headerlink" href="#cvc5.Kind.WITNESS" title="Link to this definition"></a></dt>
<dd><p>Witness.</p>
<p>The syntax of a witness term is similar to a quantified formula except that
only one variable is allowed.
For example, the term</p>
<div class="highlight-smtlib notranslate"><div class="highlight"><pre><span></span>(<span class="o">witness</span> ((<span class="n">x</span> <span class="n">S</span>)) <span class="n">F</span>)
</pre></div>
</div>
<p>returns an element <span class="math notranslate nohighlight">\(x\)</span> of Sort <span class="math notranslate nohighlight">\(S\)</span> and asserts formula
<span class="math notranslate nohighlight">\(F\)</span>.</p>
<p>The witness operator behaves like the description operator
(see https:
no <span class="math notranslate nohighlight">\(x\)</span> that satisfies <span class="math notranslate nohighlight">\(F\)</span>. But if such <span class="math notranslate nohighlight">\(x\)</span> exists, the
witness operator does not enforce the following axiom which ensures
uniqueness up to logical equivalence:</p>
<div class="math notranslate nohighlight">
\[\forall x. F \equiv G \Rightarrow witness~x. F =  witness~x. G\]</div>
<p>For example, if there are two elements of Sort <span class="math notranslate nohighlight">\(S\)</span> that satisfy
formula <span class="math notranslate nohighlight">\(F\)</span>, then the following formula is satisfiable:</p>
<div class="highlight-smtlib notranslate"><div class="highlight"><pre><span></span>(<span class="o">distinct</span>
   (<span class="o">witness</span> ((<span class="n">x</span> <span class="na">Int</span>)) <span class="n">F</span>)
   (<span class="o">witness</span> ((<span class="n">x</span> <span class="na">Int</span>)) <span class="n">F</span>))
</pre></div>
</div>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">3</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1:</span></code> Term of kind <a class="reference internal" href="#cvc5.Kind.VARIABLE_LIST" title="cvc5.Kind.VARIABLE_LIST"><code class="xref py py-obj docutils literal notranslate"><span class="pre">VARIABLE_LIST</span></code></a></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">2:</span></code> Term of Sort Bool (the body of the witness)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">3:</span></code> (optional) Term of kind <a class="reference internal" href="#cvc5.Kind.INST_PATTERN_LIST" title="cvc5.Kind.INST_PATTERN_LIST"><code class="xref py py-obj docutils literal notranslate"><span class="pre">INST_PATTERN_LIST</span></code></a></p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This kind is primarily used internally, but may be returned in
models (e.g., for arithmetic terms in non-linear queries). However,
it is not supported by the parser. Moreover, the user of the API
should be cautious when using this operator. In general, all witness
terms <code class="docutils literal notranslate"><span class="pre">(witness</span> <span class="pre">((x</span> <span class="pre">Int))</span> <span class="pre">F)</span></code> should be such that <code class="docutils literal notranslate"><span class="pre">(exists</span> <span class="pre">((x</span> <span class="pre">Int))</span>
<span class="pre">F)</span></code> is a valid formula. If this is not the case, then the semantics
in formulas that use witness terms may be unintuitive. For example,
the following formula is unsatisfiable:
<code class="docutils literal notranslate"><span class="pre">(or</span> <span class="pre">(=</span> <span class="pre">(witness</span> <span class="pre">((x</span> <span class="pre">Int))</span> <span class="pre">false)</span> <span class="pre">0)</span> <span class="pre">(not</span> <span class="pre">(=</span> <span class="pre">(witness</span> <span class="pre">((x</span> <span class="pre">Int))</span>
<span class="pre">false)</span> <span class="pre">0))</span></code>, whereas notice that <code class="docutils literal notranslate"><span class="pre">(or</span> <span class="pre">(=</span> <span class="pre">z</span> <span class="pre">0)</span> <span class="pre">(not</span> <span class="pre">(=</span> <span class="pre">z</span> <span class="pre">0)))</span></code> is
true for any <span class="math notranslate nohighlight">\(z\)</span>.</p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cvc5.Kind.XOR">
<span class="sig-name descname"><span class="pre">XOR</span></span><a class="headerlink" href="#cvc5.Kind.XOR" title="Link to this definition"></a></dt>
<dd><p>Logical exclusive disjunction, left associative.</p>
<ul class="simple">
<li><p>Arity: <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">&gt;</span> <span class="pre">1</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">1..n:</span></code> Terms of Sort Bool</p></li>
</ul>
</li>
<li><p>Create Term of this Kind with:</p>
<ul>
<li><p>TermManager::mkTerm(Kind, const std::vector&lt;Term&gt;&amp;)</p></li>
<li><p>TermManager::mkTerm(const Op&amp;, const std::vector&lt;Term&gt;&amp;)</p></li>
</ul>
</li>
<li><p>Create Op of this kind with:</p>
<ul>
<li><p>TermManager::mkOp(Kind, const std::vector&lt;uint32_t&gt;&amp;)</p></li>
</ul>
</li>
</ul>
</dd></dl>

</dd></dl>

</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="inputparser.html" class="btn btn-neutral float-left" title="InputParser" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="modes.html" class="btn btn-neutral float-right" title="Modes" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2026, the authors of cvc5.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>
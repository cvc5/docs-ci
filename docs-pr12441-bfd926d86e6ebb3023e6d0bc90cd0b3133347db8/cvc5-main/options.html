

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="./">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-ML12X2V35B"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-ML12X2V35B');
    </script>
    
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Options &mdash; cvc5  documentation</title>
      <link rel="stylesheet" type="text/css" href="static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="static/css/theme.css?v=9edc463e" />
      <link rel="stylesheet" type="text/css" href="static/custom.css?v=b9602cbe" />

  
      <script src="static/jquery.js?v=5d32c60e"></script>
      <script src="static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="static/documentation_options.js?v=5929fcd5"></script>
      <script src="static/doctools.js?v=9bcbadda"></script>
      <script src="static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Output tags" href="output-tags.html" />
    <link rel="prev" title="UnknownExplanation" href="api/python/base/unknownexplanation.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            cvc5
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="installation/installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="binary/binary.html">Binary Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="api/api.html">API Documentation</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Options</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#most-commonly-used-cvc5-options">Most Commonly-Used cvc5 Options</a></li>
<li class="toctree-l2"><a class="reference internal" href="#additional-cvc5-options">Additional cvc5 Options</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#arithmetic-theory-module">Arithmetic Theory Module</a></li>
<li class="toctree-l3"><a class="reference internal" href="#arrays-theory-module">Arrays Theory Module</a></li>
<li class="toctree-l3"><a class="reference internal" href="#bags-theory-module">Bags Theory Module</a></li>
<li class="toctree-l3"><a class="reference internal" href="#base-module">Base Module</a></li>
<li class="toctree-l3"><a class="reference internal" href="#bitvector-theory-module">Bitvector Theory Module</a></li>
<li class="toctree-l3"><a class="reference internal" href="#datatypes-theory-module">Datatypes Theory Module</a></li>
<li class="toctree-l3"><a class="reference internal" href="#decision-heuristics-module">Decision Heuristics Module</a></li>
<li class="toctree-l3"><a class="reference internal" href="#expression-module">Expression Module</a></li>
<li class="toctree-l3"><a class="reference internal" href="#finite-field-theory-module">Finite Field Theory Module</a></li>
<li class="toctree-l3"><a class="reference internal" href="#floating-point-module">Floating-Point Module</a></li>
<li class="toctree-l3"><a class="reference internal" href="#driver-module">Driver Module</a></li>
<li class="toctree-l3"><a class="reference internal" href="#parallel-module">Parallel Module</a></li>
<li class="toctree-l3"><a class="reference internal" href="#parser-module">Parser Module</a></li>
<li class="toctree-l3"><a class="reference internal" href="#printing-module">Printing Module</a></li>
<li class="toctree-l3"><a class="reference internal" href="#proof-module">Proof Module</a></li>
<li class="toctree-l3"><a class="reference internal" href="#sat-layer-module">SAT Layer Module</a></li>
<li class="toctree-l3"><a class="reference internal" href="#quantifiers-module">Quantifiers Module</a></li>
<li class="toctree-l3"><a class="reference internal" href="#separation-logic-theory-module">Separation Logic Theory Module</a></li>
<li class="toctree-l3"><a class="reference internal" href="#sets-theory-module">Sets Theory Module</a></li>
<li class="toctree-l3"><a class="reference internal" href="#smt-layer-module">SMT Layer Module</a></li>
<li class="toctree-l3"><a class="reference internal" href="#strings-theory-module">Strings Theory Module</a></li>
<li class="toctree-l3"><a class="reference internal" href="#theory-layer-module">Theory Layer Module</a></li>
<li class="toctree-l3"><a class="reference internal" href="#uninterpreted-functions-theory-module">Uninterpreted Functions Theory Module</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="output-tags.html">Output tags</a></li>
<li class="toctree-l1"><a class="reference internal" href="proofs/proofs.html">Proof Production</a></li>
<li class="toctree-l1"><a class="reference internal" href="resource-limits.html">Resource limits</a></li>
<li class="toctree-l1"><a class="reference internal" href="skolem-ids.html">Skolem Identifiers</a></li>
<li class="toctree-l1"><a class="reference internal" href="statistics.html">Statistics</a></li>
<li class="toctree-l1"><a class="reference internal" href="examples/examples.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="theories/theories.html">Theory References</a></li>
<li class="toctree-l1"><a class="reference internal" href="references.html">References</a></li>
<li class="toctree-l1"><a class="reference internal" href="genindex.html">Index</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">cvc5</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Options</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="options">
<h1>Options<a class="headerlink" href="#options" title="Link to this heading"></a></h1>
<p>cvc5 can be configured at runtime using a wide range of options.
When cvc5 is used as a binary, options can be set on the command line.
Also, options can be set and inspected using the respective commands of the input language and the corresponding API functions:</p>
<ul class="simple">
<li><p>C++ API: <a class="reference internal" href="api/cpp/classes/solver.html#_CPPv4NK4cvc56Solver9setOptionERKNSt6stringERKNSt6stringE" title="cvc5::Solver::setOption"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">setOption()</span></code></a>,
<a class="reference internal" href="api/cpp/classes/solver.html#_CPPv4NK4cvc56Solver9getOptionERKNSt6stringE" title="cvc5::Solver::getOption"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">getOption()</span></code></a>,
<a class="reference internal" href="api/cpp/classes/solver.html#_CPPv4NK4cvc56Solver14getOptionNamesEv" title="cvc5::Solver::getOptionNames"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">getOptionNames()</span></code></a>,
<a class="reference internal" href="api/cpp/classes/solver.html#_CPPv4NK4cvc56Solver13getOptionInfoERKNSt6stringE" title="cvc5::Solver::getOptionInfo"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">getOptionInfo()</span></code></a></p></li>
<li><p>Java API: <code class="docutils literal notranslate"><span class="pre">setOption()</span></code>, <code class="docutils literal notranslate"><span class="pre">getOption()</span></code>, <code class="docutils literal notranslate"><span class="pre">getOptionNames()</span></code>, <code class="docutils literal notranslate"><span class="pre">getOptionInfo()</span></code></p></li>
<li><p>Base Python API: <a class="reference internal" href="api/python/base/solver.html#cvc5.Solver.setOption" title="cvc5.Solver.setOption"><code class="xref py py-func docutils literal notranslate"><span class="pre">setOption()</span></code></a>,
<a class="reference internal" href="api/python/base/solver.html#cvc5.Solver.getOption" title="cvc5.Solver.getOption"><code class="xref py py-func docutils literal notranslate"><span class="pre">getOption()</span></code></a>,
<a class="reference internal" href="api/python/base/solver.html#cvc5.Solver.getOptionNames" title="cvc5.Solver.getOptionNames"><code class="xref py py-func docutils literal notranslate"><span class="pre">getOptionNames()</span></code></a>,
<a class="reference internal" href="api/python/base/solver.html#cvc5.Solver.getOptionInfo" title="cvc5.Solver.getOptionInfo"><code class="xref py py-func docutils literal notranslate"><span class="pre">getOptionInfo()</span></code></a></p></li>
<li><p>Pythonic API: <a class="reference internal" href="api/python/pythonic/solver.html#cvc5.pythonic.Solver.setOption" title="cvc5.pythonic.Solver.setOption"><code class="xref py py-func docutils literal notranslate"><span class="pre">setOption()</span></code></a>,
<a class="reference internal" href="api/python/pythonic/solver.html#cvc5.pythonic.Solver.getOption" title="cvc5.pythonic.Solver.getOption"><code class="xref py py-func docutils literal notranslate"><span class="pre">getOption()</span></code></a>,
<a class="reference internal" href="api/python/pythonic/solver.html#cvc5.pythonic.Solver.getOptionNames" title="cvc5.pythonic.Solver.getOptionNames"><code class="xref py py-func docutils literal notranslate"><span class="pre">getOptionNames()</span></code></a>,
<a class="reference internal" href="api/python/pythonic/solver.html#cvc5.pythonic.Solver.getOptionInfo" title="cvc5.pythonic.Solver.getOptionInfo"><code class="xref py py-func docutils literal notranslate"><span class="pre">getOptionInfo()</span></code></a></p></li>
</ul>
<p>Generally, all options are identified by a name <code class="docutils literal notranslate"><span class="pre">&lt;name&gt;</span></code>, and (optionally)
by a short name <code class="docutils literal notranslate"><span class="pre">&lt;short&gt;</span></code> (a single letter).
Additionally, they can have one or more aliases, which can be used instead of
<code class="docutils literal notranslate"><span class="pre">&lt;name&gt;</span></code>.</p>
<p><strong>Internally</strong>, options are strongly typed and must be either Boolean, (signed
or unsigned) integers, floating-point numbers, strings, or an enumeration type.
Values for options with a numeric type may be restricted to an interval.</p>
<p>Some options have <strong>custom types</strong> (e.g., <a class="reference internal" href="#lbl-option-err"><span class="std std-ref">err</span></a>) which
require special treatment internally.
The usage of such options is documented as part of the documentation for the corresponding options.</p>
<p>On the command line, a <strong>Boolean</strong> option can be set to <code class="docutils literal notranslate"><span class="pre">true</span></code> via
<code class="docutils literal notranslate"><span class="pre">--&lt;name&gt;</span></code> or <code class="docutils literal notranslate"><span class="pre">-&lt;short&gt;</span></code>.
Most Boolean options can also be set to <code class="docutils literal notranslate"><span class="pre">false</span></code> via <code class="docutils literal notranslate"><span class="pre">--no-&lt;name&gt;</span></code>.
In cvc5’s APIs, this is done via <code class="docutils literal notranslate"><span class="pre">setOption(&quot;&lt;name&gt;&quot;,</span> <span class="pre">&quot;true&quot;</span> <span class="pre">|</span> <span class="pre">&quot;false&quot;)</span></code>.</p>
<p>For <strong>all other types</strong>, values are given on the command line using
<code class="docutils literal notranslate"><span class="pre">--&lt;name&gt;=&lt;value&gt;</span></code> or <code class="docutils literal notranslate"><span class="pre">--&lt;name&gt;</span> <span class="pre">&lt;value&gt;</span></code>,
and <code class="docutils literal notranslate"><span class="pre">setOption(&quot;&lt;name&gt;&quot;,</span> <span class="pre">&quot;&lt;value&gt;&quot;)</span></code> in the APIs.
The given value must be convertible to the appropriate type, in particular for
numeric and enumeration types.</p>
<p>Below is an exhaustive list of options supported by cvc5.</p>
<section id="most-commonly-used-cvc5-options">
<h2>Most Commonly-Used cvc5 Options<a class="headerlink" href="#most-commonly-used-cvc5-options" title="Link to this heading"></a></h2>
<dl class="simple" id="lbl-option-incremental">
<dt><code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">|</span> <span class="pre">incremental</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">true</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p>enable incremental solving</p>
</dd>
</dl>
<dl class="simple" id="lbl-option-lang">
<dt><code class="docutils literal notranslate"><span class="pre">L</span> <span class="pre">|</span> <span class="pre">lang</span> <span class="pre">|</span> <span class="pre">input-language</span></code> [custom <code class="docutils literal notranslate"><span class="pre">Language</span></code>, default <code class="docutils literal notranslate"><span class="pre">Language::LANG_AUTO</span></code>]</dt><dd><p>force input language (default is “auto”; see –lang help)</p>
</dd>
</dl>
<dl id="lbl-option-output">
<dt><code class="docutils literal notranslate"><span class="pre">o</span> <span class="pre">|</span> <span class="pre">output</span></code> [<code class="docutils literal notranslate"><span class="pre">none</span> <span class="pre">|</span> <span class="pre">inst</span> <span class="pre">|</span> <span class="pre">inst-strategy</span> <span class="pre">|</span> <span class="pre">oracles</span> <span class="pre">|</span> <span class="pre">sygus</span> <span class="pre">|</span> <span class="pre">sygus-grammar</span> <span class="pre">|</span> <span class="pre">sygus-enumerator</span> <span class="pre">|</span> <span class="pre">sygus-sol-gterm</span> <span class="pre">|</span> <span class="pre">trigger</span> <span class="pre">|</span> <span class="pre">raw-benchmark</span> <span class="pre">|</span> <span class="pre">learned-lits</span> <span class="pre">|</span> <span class="pre">subs</span> <span class="pre">|</span> <span class="pre">post-asserts</span> <span class="pre">|</span> <span class="pre">pre-asserts</span> <span class="pre">|</span> <span class="pre">deep-restart</span> <span class="pre">|</span> <span class="pre">incomplete</span> <span class="pre">|</span> <span class="pre">lemmas</span> <span class="pre">|</span> <span class="pre">trusted-proof-steps</span> <span class="pre">|</span> <span class="pre">timeout-core-benchmark</span> <span class="pre">|</span> <span class="pre">unsat-core-benchmark</span> <span class="pre">|</span> <span class="pre">unsat-core-lemmas-benchmark</span> <span class="pre">|</span> <span class="pre">unsat-core-lemmas</span> <span class="pre">|</span> <span class="pre">portfolio</span> <span class="pre">|</span> <span class="pre">block-model</span> <span class="pre">|</span> <span class="pre">options-auto</span> <span class="pre">|</span> <span class="pre">rare-db</span> <span class="pre">|</span> <span class="pre">rare-db-expert</span> <span class="pre">|</span> <span class="pre">normalize</span></code>, default <code class="docutils literal notranslate"><span class="pre">none</span></code>]</dt><dd><p>Enable output tag.</p>
<p>Output tags.</p>
<dl class="field-list simple">
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">inst</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>print instantiations during solving</p>
</dd>
<dt class="field-even"><code class="docutils literal notranslate"><span class="pre">inst-strategy</span></code><span class="colon">:</span></dt>
<dd class="field-even"><p>prints a summary of the instantiation techniques as they are run.</p>
</dd>
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">oracles</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>print calls to oracles and responses received</p>
</dd>
<dt class="field-even"><code class="docutils literal notranslate"><span class="pre">sygus</span></code><span class="colon">:</span></dt>
<dd class="field-even"><p>print enumerated terms and candidates generated by the sygus solver</p>
</dd>
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">sygus-grammar</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>print grammars automatically generated by the sygus solver</p>
</dd>
<dt class="field-even"><code class="docutils literal notranslate"><span class="pre">sygus-enumerator</span></code><span class="colon">:</span></dt>
<dd class="field-even"><p>print enumerators generated by the sygus solver</p>
</dd>
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">sygus-sol-gterm</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>print annotations for terms in sygus solutions that indicate the grammar used to generate them</p>
</dd>
<dt class="field-even"><code class="docutils literal notranslate"><span class="pre">trigger</span></code><span class="colon">:</span></dt>
<dd class="field-even"><p>print selected triggers for quantified formulas</p>
</dd>
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">raw-benchmark</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>print the benchmark back on the output verbatim as it is processed</p>
</dd>
<dt class="field-even"><code class="docutils literal notranslate"><span class="pre">learned-lits</span></code><span class="colon">:</span></dt>
<dd class="field-even"><p>print input literals that hold globally</p>
</dd>
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">subs</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>print top-level substitutions learned during preprocessing</p>
</dd>
<dt class="field-even"><code class="docutils literal notranslate"><span class="pre">post-asserts</span></code><span class="colon">:</span></dt>
<dd class="field-even"><p>print a benchmark corresponding to the assertions of the input problem after preprocessing</p>
</dd>
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">pre-asserts</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>print a benchmark corresponding to the assertions of the input problem before preprocessing</p>
</dd>
<dt class="field-even"><code class="docutils literal notranslate"><span class="pre">deep-restart</span></code><span class="colon">:</span></dt>
<dd class="field-even"><p>print when cvc5 performs a deep restart along with the literals it has learned</p>
</dd>
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">incomplete</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>print reason why cvc5 answers unknown for any given check-sat query</p>
</dd>
<dt class="field-even"><code class="docutils literal notranslate"><span class="pre">lemmas</span></code><span class="colon">:</span></dt>
<dd class="field-even"><p>print lemmas as they are added to the SAT solver</p>
</dd>
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">trusted-proof-steps</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>print formulas corresponding to trusted proof steps in final proofs</p>
</dd>
<dt class="field-even"><code class="docutils literal notranslate"><span class="pre">timeout-core-benchmark</span></code><span class="colon">:</span></dt>
<dd class="field-even"><p>print the corresponding benchmark when successfully computing a timeout core.</p>
</dd>
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">unsat-core-benchmark</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>print the corresponding benchmark when successfully computing an unsat core.</p>
</dd>
<dt class="field-even"><code class="docutils literal notranslate"><span class="pre">unsat-core-lemmas-benchmark</span></code><span class="colon">:</span></dt>
<dd class="field-even"><p>print the corresponding benchmark when successfully computing an unsat core with theory lemmas.</p>
</dd>
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">unsat-core-lemmas</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>print diagnostic information on lemmas that appear in an unsat core with theory lemmas</p>
</dd>
<dt class="field-even"><code class="docutils literal notranslate"><span class="pre">portfolio</span></code><span class="colon">:</span></dt>
<dd class="field-even"><p>prints the option strings tried in portfolio mode.</p>
</dd>
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">block-model</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>prints the formulas used when block-model is run.</p>
</dd>
<dt class="field-even"><code class="docutils literal notranslate"><span class="pre">options-auto</span></code><span class="colon">:</span></dt>
<dd class="field-even"><p>prints the options set during automatic configuration.</p>
</dd>
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">rare-db</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>upon initialization, print the set of (non-expert) RARE rewrite rules as they are defined in the proof signature.</p>
</dd>
<dt class="field-even"><code class="docutils literal notranslate"><span class="pre">rare-db-expert</span></code><span class="colon">:</span></dt>
<dd class="field-even"><p>upon initialization, print the set of expert RARE rewrite rules as they are defined in the proof signature.</p>
</dd>
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">normalize</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>prints the benchmark after normalization</p>
</dd>
</dl>
</dd>
</dl>
<dl class="simple" id="lbl-option-parse-only">
<dt><code class="docutils literal notranslate"><span class="pre">parse-only</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p>exit after parsing input</p>
</dd>
</dl>
<dl class="simple" id="lbl-option-preprocess-only">
<dt><code class="docutils literal notranslate"><span class="pre">preprocess-only</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p>exit after preprocessing input</p>
</dd>
</dl>
<dl class="simple" id="lbl-option-quiet">
<dt><code class="docutils literal notranslate"><span class="pre">q</span> <span class="pre">|</span> <span class="pre">quiet</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>]</dt><dd><p>decrease verbosity (may be repeated)</p>
</dd>
</dl>
<dl class="simple" id="lbl-option-rlimit">
<dt><code class="docutils literal notranslate"><span class="pre">rlimit</span></code> [type <code class="docutils literal notranslate"><span class="pre">uint64_t</span></code>, default <code class="docutils literal notranslate"><span class="pre">0</span></code>]</dt><dd><p>set resource limit</p>
</dd>
</dl>
<dl class="simple" id="lbl-option-rlimit-per">
<dt><code class="docutils literal notranslate"><span class="pre">rlimit-per</span> <span class="pre">|</span> <span class="pre">reproducible-resource-limit</span></code> [type <code class="docutils literal notranslate"><span class="pre">uint64_t</span></code>, default <code class="docutils literal notranslate"><span class="pre">0</span></code>]</dt><dd><p>set resource limit per query</p>
</dd>
</dl>
<dl class="simple" id="lbl-option-stats">
<dt><code class="docutils literal notranslate"><span class="pre">stats</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p>give statistics on exit</p>
</dd>
</dl>
<dl class="simple" id="lbl-option-stats-all">
<dt><code class="docutils literal notranslate"><span class="pre">stats-all</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p>print unchanged (defaulted) statistics as well</p>
</dd>
</dl>
<dl class="simple" id="lbl-option-stats-internal">
<dt><code class="docutils literal notranslate"><span class="pre">stats-internal</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p>print internal (non-public) statistics as well</p>
</dd>
</dl>
<dl class="simple" id="lbl-option-tlimit">
<dt><code class="docutils literal notranslate"><span class="pre">tlimit</span></code> [type <code class="docutils literal notranslate"><span class="pre">uint64_t</span></code>, default <code class="docutils literal notranslate"><span class="pre">0</span></code>]</dt><dd><p>set time limit in milliseconds of wall clock time</p>
</dd>
</dl>
<dl class="simple" id="lbl-option-tlimit-per">
<dt><code class="docutils literal notranslate"><span class="pre">tlimit-per</span></code> [type <code class="docutils literal notranslate"><span class="pre">uint64_t</span></code>, default <code class="docutils literal notranslate"><span class="pre">0</span></code>]</dt><dd><p>set time limit per query in milliseconds</p>
</dd>
</dl>
<dl class="simple" id="lbl-option-verbose">
<dt><code class="docutils literal notranslate"><span class="pre">v</span> <span class="pre">|</span> <span class="pre">verbose</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>]</dt><dd><p>increase verbosity (may be repeated)</p>
</dd>
</dl>
<dl class="simple" id="lbl-option-verbosity">
<dt><code class="docutils literal notranslate"><span class="pre">verbosity</span></code> [type <code class="docutils literal notranslate"><span class="pre">int64_t</span></code>, default <code class="docutils literal notranslate"><span class="pre">0</span></code>]</dt><dd><p>the verbosity level of cvc5</p>
</dd>
</dl>
<dl id="lbl-option-decision">
<dt><code class="docutils literal notranslate"><span class="pre">decision</span> <span class="pre">|</span> <span class="pre">decision-mode</span></code> [<code class="docutils literal notranslate"><span class="pre">internal</span> <span class="pre">|</span> <span class="pre">justification</span> <span class="pre">|</span> <span class="pre">stoponly</span></code>, default <code class="docutils literal notranslate"><span class="pre">internal</span></code>]</dt><dd><p>choose decision mode, see –decision=help</p>
<p>Decision modes.</p>
<dl class="field-list simple">
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">internal</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>Use the internal decision heuristics of the SAT solver.</p>
</dd>
<dt class="field-even"><code class="docutils literal notranslate"><span class="pre">justification</span></code><span class="colon">:</span></dt>
<dd class="field-even"><p>An ATGP-inspired justification heuristic.</p>
</dd>
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">stoponly</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>Use the justification heuristic only to stop early, not for decisions.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="simple" id="lbl-option-copyright">
<dt><code class="docutils literal notranslate"><span class="pre">copyright</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>]</dt><dd><p>show cvc5 copyright information</p>
</dd>
</dl>
<dl class="simple" id="lbl-option-early-exit">
<dt><code class="docutils literal notranslate"><span class="pre">early-exit</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">true</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p>do not run destructors at exit; default on except in debug builds</p>
</dd>
</dl>
<dl class="simple" id="lbl-option-help">
<dt><code class="docutils literal notranslate"><span class="pre">h</span> <span class="pre">|</span> <span class="pre">help</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>]</dt><dd><p>full command line reference</p>
</dd>
</dl>
<dl class="simple" id="lbl-option-help-option-categories">
<dt><code class="docutils literal notranslate"><span class="pre">help-option-categories</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>]</dt><dd><p>Print summary of options for each category</p>
</dd>
</dl>
<dl class="simple" id="lbl-option-help-regular">
<dt><code class="docutils literal notranslate"><span class="pre">H</span> <span class="pre">|</span> <span class="pre">help-regular</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>]</dt><dd><p>regular command line reference</p>
</dd>
</dl>
<dl class="simple" id="lbl-option-interactive">
<dt><code class="docutils literal notranslate"><span class="pre">interactive</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p>force interactive shell/non-interactive mode</p>
</dd>
</dl>
<dl class="simple" id="lbl-option-print-success">
<dt><code class="docutils literal notranslate"><span class="pre">print-success</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p>print the “success” output required of SMT-LIBv2</p>
</dd>
</dl>
<dl class="simple" id="lbl-option-seed">
<dt><code class="docutils literal notranslate"><span class="pre">s</span> <span class="pre">|</span> <span class="pre">seed</span> <span class="pre">|</span> <span class="pre">random-seed</span></code> [type <code class="docutils literal notranslate"><span class="pre">uint64_t</span></code>, default <code class="docutils literal notranslate"><span class="pre">0</span></code>]</dt><dd><p>seed for random number generator</p>
</dd>
</dl>
<dl class="simple" id="lbl-option-show-config">
<dt><code class="docutils literal notranslate"><span class="pre">show-config</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>]</dt><dd><p>show cvc5 static configuration</p>
</dd>
</dl>
<dl class="simple" id="lbl-option-version">
<dt><code class="docutils literal notranslate"><span class="pre">V</span> <span class="pre">|</span> <span class="pre">version</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>]</dt><dd><p>identify this cvc5 binary</p>
</dd>
</dl>
<dl class="simple" id="lbl-option-force-logic">
<dt><code class="docutils literal notranslate"><span class="pre">force-logic</span></code> [type <code class="docutils literal notranslate"><span class="pre">string</span></code>, default <code class="docutils literal notranslate"><span class="pre">&quot;&quot;</span></code>]</dt><dd><p>set the logic, and override all further user attempts to change it</p>
</dd>
</dl>
<dl class="simple" id="lbl-option-strict-parsing">
<dt><code class="docutils literal notranslate"><span class="pre">strict-parsing</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p>be less tolerant of non-conforming inputs, this is an alias for –parsing-mode=strict</p>
</dd>
</dl>
<dl class="simple" id="lbl-option-dag-thresh">
<dt><code class="docutils literal notranslate"><span class="pre">dag-thresh</span></code> [type <code class="docutils literal notranslate"><span class="pre">int64_t</span></code>, <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">N</span></code>, default <code class="docutils literal notranslate"><span class="pre">1</span></code>]</dt><dd><p>dagify common subexprs appearing &gt; N times (1 == default, 0 == don’t dagify)</p>
</dd>
</dl>
<dl class="simple" id="lbl-option-expr-depth">
<dt><code class="docutils literal notranslate"><span class="pre">expr-depth</span></code> [type <code class="docutils literal notranslate"><span class="pre">int64_t</span></code>, <code class="docutils literal notranslate"><span class="pre">-1</span> <span class="pre">&lt;=</span> <span class="pre">N</span></code>, default <code class="docutils literal notranslate"><span class="pre">-1</span></code>]</dt><dd><p>print exprs to depth N (0 == default, -1 == no limit)</p>
</dd>
</dl>
<dl class="simple" id="lbl-option-output-lang">
<dt><code class="docutils literal notranslate"><span class="pre">output-lang</span> <span class="pre">|</span> <span class="pre">output-language</span></code> [custom <code class="docutils literal notranslate"><span class="pre">Language</span></code>, default <code class="docutils literal notranslate"><span class="pre">Language::LANG_AUTO</span></code>]</dt><dd><p>force output language (default is “auto”; see –output-lang help)</p>
</dd>
</dl>
<dl id="lbl-option-proof-check">
<dt><code class="docutils literal notranslate"><span class="pre">proof-check</span></code> [<code class="docutils literal notranslate"><span class="pre">eager</span> <span class="pre">|</span> <span class="pre">eager-simple</span> <span class="pre">|</span> <span class="pre">lazy</span> <span class="pre">|</span> <span class="pre">none</span></code>, default <code class="docutils literal notranslate"><span class="pre">none</span></code>]</dt><dd><p>select internal proof checking mode</p>
<p>Internal proof checking modes.</p>
<dl class="field-list simple">
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">eager</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>check rule applications and proofs from generators eagerly for local debugging</p>
</dd>
<dt class="field-even"><code class="docutils literal notranslate"><span class="pre">eager-simple</span></code><span class="colon">:</span></dt>
<dd class="field-even"><p>check rule applications during construction</p>
</dd>
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">lazy</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>check rule applications only during final proof construction</p>
</dd>
<dt class="field-even"><code class="docutils literal notranslate"><span class="pre">none</span></code><span class="colon">:</span></dt>
<dd class="field-even"><p>do not check rule applications</p>
</dd>
</dl>
</dd>
</dl>
<dl id="lbl-option-proof-granularity">
<dt><code class="docutils literal notranslate"><span class="pre">proof-granularity</span></code> [<code class="docutils literal notranslate"><span class="pre">macro</span> <span class="pre">|</span> <span class="pre">rewrite</span> <span class="pre">|</span> <span class="pre">theory-rewrite</span> <span class="pre">|</span> <span class="pre">dsl-rewrite</span> <span class="pre">|</span> <span class="pre">dsl-rewrite-strict</span></code>, default <code class="docutils literal notranslate"><span class="pre">macro</span></code>]</dt><dd><p>modes for proof granularity</p>
<p>Modes for proof granularity.</p>
<dl class="field-list simple">
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">macro</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>Allow macros. Do not improve the granularity of proofs.</p>
</dd>
<dt class="field-even"><code class="docutils literal notranslate"><span class="pre">rewrite</span></code><span class="colon">:</span></dt>
<dd class="field-even"><p>Allow trusted rewrite or substitution steps, expand macros.</p>
</dd>
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">theory-rewrite</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>Allow trusted theory rewrite steps, expand macros, rewrite and substitution steps.</p>
</dd>
<dt class="field-even"><code class="docutils literal notranslate"><span class="pre">dsl-rewrite</span></code><span class="colon">:</span></dt>
<dd class="field-even"><p>Allow theory and DSL rewrite steps, expand macros, rewrite, substitution, and theory rewrite steps.</p>
</dd>
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">dsl-rewrite-strict</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>Allow theory and DSL rewrite steps giving preference to DSL rewrite steps.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="simple" id="lbl-option-proof-print-conclusion">
<dt><code class="docutils literal notranslate"><span class="pre">proof-print-conclusion</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p>Print conclusion of proof steps when printing AST</p>
</dd>
</dl>
<dl class="simple" id="lbl-option-proof-print-reference">
<dt><code class="docutils literal notranslate"><span class="pre">proof-print-reference</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p>Print reference to original file instead of redeclaring</p>
</dd>
</dl>
<dl class="simple" id="lbl-option-enum-inst">
<dt><code class="docutils literal notranslate"><span class="pre">enum-inst</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p>enumerative instantiation: instantiate with ground terms from relevant domain, then arbitrary ground terms before answering unknown</p>
</dd>
</dl>
<dl class="simple" id="lbl-option-full-saturate-quant">
<dt><code class="docutils literal notranslate"><span class="pre">full-saturate-quant</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p>resort to full effort techniques instead of answering unknown due to limited quantifier reasoning. Currently enables enumerative instantiation</p>
</dd>
</dl>
<dl id="lbl-option-print-inst">
<dt><code class="docutils literal notranslate"><span class="pre">print-inst</span></code> [<code class="docutils literal notranslate"><span class="pre">list</span> <span class="pre">|</span> <span class="pre">num</span></code>, default <code class="docutils literal notranslate"><span class="pre">list</span></code>]</dt><dd><p>print format for printing instantiations</p>
<p>Print format for printing instantiations.</p>
<dl class="field-list simple">
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">list</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>Print the list of instantiations per quantified formula, when non-empty.</p>
</dd>
<dt class="field-even"><code class="docutils literal notranslate"><span class="pre">num</span></code><span class="colon">:</span></dt>
<dd class="field-even"><p>Print the total number of instantiations per quantified formula, when non-zero.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="simple" id="lbl-option-check-abducts">
<dt><code class="docutils literal notranslate"><span class="pre">check-abducts</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p>checks whether produced solutions to get-abduct are correct</p>
</dd>
</dl>
<dl class="simple" id="lbl-option-check-interpolants">
<dt><code class="docutils literal notranslate"><span class="pre">check-interpolants</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p>checks whether produced solutions to get-interpolant are correct</p>
</dd>
</dl>
<dl class="simple" id="lbl-option-check-model-subsolver">
<dt><code class="docutils literal notranslate"><span class="pre">check-model-subsolver</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">true</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p>use subsolver to compute values when applicable in calls to get-value and check-models</p>
</dd>
</dl>
<dl class="simple" id="lbl-option-check-models">
<dt><code class="docutils literal notranslate"><span class="pre">check-models</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p>after SAT/INVALID/UNKNOWN, check that the generated model satisfies user assertions</p>
</dd>
</dl>
<dl class="simple" id="lbl-option-check-proofs">
<dt><code class="docutils literal notranslate"><span class="pre">check-proofs</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p>after UNSAT/VALID, check the generated proof (with proof)</p>
</dd>
</dl>
<dl class="simple" id="lbl-option-check-synth-sol">
<dt><code class="docutils literal notranslate"><span class="pre">check-synth-sol</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p>checks whether produced solutions to functions-to-synthesize satisfy the conjecture</p>
</dd>
</dl>
<dl class="simple" id="lbl-option-check-unsat-cores">
<dt><code class="docutils literal notranslate"><span class="pre">check-unsat-cores</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p>after UNSAT/VALID, produce and check an unsat core (expensive)</p>
</dd>
</dl>
<dl class="simple" id="lbl-option-debug-check-models">
<dt><code class="docutils literal notranslate"><span class="pre">debug-check-models</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p>after SAT/INVALID/UNKNOWN, check that the generated model satisfies user and internal assertions</p>
</dd>
</dl>
<dl class="simple" id="lbl-option-produce-models">
<dt><code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">|</span> <span class="pre">produce-models</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p>support the get-value and get-model commands</p>
</dd>
</dl>
<dl class="simple" id="lbl-option-produce-proofs">
<dt><code class="docutils literal notranslate"><span class="pre">produce-proofs</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p>produce proofs, support check-proofs and get-proof</p>
</dd>
</dl>
<dl class="simple" id="lbl-option-produce-unsat-assumptions">
<dt><code class="docutils literal notranslate"><span class="pre">produce-unsat-assumptions</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p>turn on unsat assumptions generation</p>
</dd>
</dl>
<dl class="simple" id="lbl-option-produce-unsat-cores">
<dt><code class="docutils literal notranslate"><span class="pre">produce-unsat-cores</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p>turn on unsat core generation. Unless otherwise specified, cores will be produced using SAT soving under assumptions and preprocessing proofs.</p>
</dd>
</dl>
<dl class="simple" id="lbl-option-condense-function-values">
<dt><code class="docutils literal notranslate"><span class="pre">condense-function-values</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">true</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p>condense values for functions in models rather than explicitly representing them</p>
</dd>
</dl>
<dl id="lbl-option-default-function-value-mode">
<dt><code class="docutils literal notranslate"><span class="pre">default-function-value-mode</span></code> [<code class="docutils literal notranslate"><span class="pre">first</span> <span class="pre">|</span> <span class="pre">first-enum</span> <span class="pre">|</span> <span class="pre">hole</span></code>, default <code class="docutils literal notranslate"><span class="pre">first</span></code>]</dt><dd><p>mode for choosing default values for functions</p>
<p>Defines mode for choosing default values for functions.</p>
<dl class="field-list simple">
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">first</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>The default value is equal to the value of the first application found of that function when applicable, or the first enumerated term otherwise.</p>
</dd>
<dt class="field-even"><code class="docutils literal notranslate"><span class="pre">first-enum</span></code><span class="colon">:</span></dt>
<dd class="field-even"><p>The default value is equal to the first enumerated value of its range type.</p>
</dd>
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">hole</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>The default value is equal to a distinguished variable.</p>
</dd>
</dl>
</dd>
</dl>
</section>
<section id="additional-cvc5-options">
<h2>Additional cvc5 Options<a class="headerlink" href="#additional-cvc5-options" title="Link to this heading"></a></h2>
<section id="arithmetic-theory-module">
<h3>Arithmetic Theory Module<a class="headerlink" href="#arithmetic-theory-module" title="Link to this heading"></a></h3>
<dl class="expert-option simple" id="lbl-option-approx-branch-depth">
<dt><code class="docutils literal notranslate"><span class="pre">approx-branch-depth</span></code> [type <code class="docutils literal notranslate"><span class="pre">int64_t</span></code>, default <code class="docutils literal notranslate"><span class="pre">200</span></code>]</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>maximum branch depth the approximate solver is allowed to take</p>
</dd>
</dl>
<dl class="simple" id="lbl-option-arith-brab">
<dt><code class="docutils literal notranslate"><span class="pre">arith-brab</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">true</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p>whether to use simple rounding, similar to a unit-cube test, for integers</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-arith-eq-solver">
<dt><code class="docutils literal notranslate"><span class="pre">arith-eq-solver</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>whether to use the equality solver in the theory of arithmetic</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-arith-exp">
<dt><code class="docutils literal notranslate"><span class="pre">arith-exp</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">true</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>enables non-standard extensions of the arithmetic solver</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-arith-prop">
<dt><code class="docutils literal notranslate"><span class="pre">arith-prop</span></code> [<code class="docutils literal notranslate"><span class="pre">none</span> <span class="pre">|</span> <span class="pre">unate</span> <span class="pre">|</span> <span class="pre">bi</span> <span class="pre">|</span> <span class="pre">both</span></code>, default <code class="docutils literal notranslate"><span class="pre">both</span></code>]</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>turns on arithmetic propagation (default is ‘old’, see –arith-prop=help)</p>
<p>This decides on kind of propagation arithmetic attempts to do during the search.</p>
<dl class="field-list simple">
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">unate</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>Use constraints to do unate propagation.</p>
</dd>
<dt class="field-even"><code class="docutils literal notranslate"><span class="pre">bi</span></code><span class="colon">:</span></dt>
<dd class="field-even"><p>(Bounds Inference) infers bounds on basic variables using the upper and lower bounds of the non-basic variables in the tableau.</p>
</dd>
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">both</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>Use bounds inference and unate.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-arith-prop-clauses">
<dt><code class="docutils literal notranslate"><span class="pre">arith-prop-clauses</span></code> [type <code class="docutils literal notranslate"><span class="pre">uint64_t</span></code>, default <code class="docutils literal notranslate"><span class="pre">8</span></code>]</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>rows shorter than this are propagated as clauses</p>
</dd>
</dl>
<dl class="simple" id="lbl-option-arith-rewrite-equalities">
<dt><code class="docutils literal notranslate"><span class="pre">arith-rewrite-equalities</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p>turns on the preprocessing rewrite turning equalities into a conjunction of inequalities</p>
</dd>
</dl>
<dl class="simple" id="lbl-option-arith-static-learning">
<dt><code class="docutils literal notranslate"><span class="pre">arith-static-learning</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">true</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p>do arithmetic static learning for ite terms based on bounds when static learning is enabled</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-collect-pivot-stats">
<dt><code class="docutils literal notranslate"><span class="pre">collect-pivot-stats</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>collect the pivot history</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-cut-all-bounded">
<dt><code class="docutils literal notranslate"><span class="pre">cut-all-bounded</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>turns on the integer solving step of periodically cutting all integer variables that have both upper and lower bounds</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-dio-decomps">
<dt><code class="docutils literal notranslate"><span class="pre">dio-decomps</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>let skolem variables for integer divisibility constraints leak from the dio solver</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-dio-solver">
<dt><code class="docutils literal notranslate"><span class="pre">dio-solver</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">true</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>turns on Linear Diophantine Equation solver (Griggio, JSAT 2012)</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-dio-turns">
<dt><code class="docutils literal notranslate"><span class="pre">dio-turns</span></code> [type <code class="docutils literal notranslate"><span class="pre">int64_t</span></code>, default <code class="docutils literal notranslate"><span class="pre">10</span></code>]</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>turns in a row dio solver cutting gets</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-error-selection-rule">
<dt><code class="docutils literal notranslate"><span class="pre">error-selection-rule</span></code> [<code class="docutils literal notranslate"><span class="pre">min</span> <span class="pre">|</span> <span class="pre">varord</span> <span class="pre">|</span> <span class="pre">max</span> <span class="pre">|</span> <span class="pre">sum</span></code>, default <code class="docutils literal notranslate"><span class="pre">min</span></code>]</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>change the pivot rule for the basic variable (default is ‘min’, see –pivot-rule help)</p>
<p>This decides on the rule used by simplex during heuristic rounds for deciding the next basic variable to select.</p>
<dl class="field-list simple">
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">min</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>The minimum abs() value of the variable’s violation of its bound.</p>
</dd>
<dt class="field-even"><code class="docutils literal notranslate"><span class="pre">varord</span></code><span class="colon">:</span></dt>
<dd class="field-even"><p>The variable order.</p>
</dd>
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">max</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>The maximum violation the bound.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-fc-penalties">
<dt><code class="docutils literal notranslate"><span class="pre">fc-penalties</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>turns on degenerate pivot penalties</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-heuristic-pivots">
<dt><code class="docutils literal notranslate"><span class="pre">heuristic-pivots</span></code> [type <code class="docutils literal notranslate"><span class="pre">int64_t</span></code>, default <code class="docutils literal notranslate"><span class="pre">0</span></code>]</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>the number of times to apply the heuristic pivot rule; if N &lt; 0, this defaults to the number of variables; if this is unset, this is tuned by the logic selection</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-lemmas-on-replay-failure">
<dt><code class="docutils literal notranslate"><span class="pre">lemmas-on-replay-failure</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>attempt to use external lemmas if approximate solve integer failed</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-maxcutsincontext">
<dt><code class="docutils literal notranslate"><span class="pre">maxCutsInContext</span></code> [type <code class="docutils literal notranslate"><span class="pre">uint64_t</span></code>, default <code class="docutils literal notranslate"><span class="pre">65535</span></code>]</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>maximum cuts in a given context before signalling a restart</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-miplib-trick">
<dt><code class="docutils literal notranslate"><span class="pre">miplib-trick</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>turns on the preprocessing step of attempting to infer bounds on miplib problems</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-miplib-trick-subs">
<dt><code class="docutils literal notranslate"><span class="pre">miplib-trick-subs</span></code> [type <code class="docutils literal notranslate"><span class="pre">uint64_t</span></code>, default <code class="docutils literal notranslate"><span class="pre">1</span></code>]</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>do substitution for miplib ‘tmp’ vars if defined in &lt;= N eliminated vars</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-new-prop">
<dt><code class="docutils literal notranslate"><span class="pre">new-prop</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">true</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>use the new row propagation system</p>
</dd>
</dl>
<dl class="simple" id="lbl-option-nl-cov">
<dt><code class="docutils literal notranslate"><span class="pre">nl-cov</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">true</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p>whether to use the cylindrical algebraic coverings solver for non-linear arithmetic</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-nl-cov-force">
<dt><code class="docutils literal notranslate"><span class="pre">nl-cov-force</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>forces using the cylindrical algebraic coverings solver, even in cases where it is possibly not safe to do so</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-nl-cov-lift">
<dt><code class="docutils literal notranslate"><span class="pre">nl-cov-lift</span></code> [<code class="docutils literal notranslate"><span class="pre">regular</span> <span class="pre">|</span> <span class="pre">lazard</span></code>, default <code class="docutils literal notranslate"><span class="pre">regular</span></code>]</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>choose the Coverings lifting mode</p>
<p>Modes for the Coverings lifting in non-linear arithmetic.</p>
<dl class="field-list simple">
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">regular</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>Regular lifting.</p>
</dd>
<dt class="field-even"><code class="docutils literal notranslate"><span class="pre">lazard</span></code><span class="colon">:</span></dt>
<dd class="field-even"><p>Lazard’s lifting scheme.</p>
</dd>
</dl>
</dd>
</dl>
<dl id="lbl-option-nl-cov-linear-model">
<dt><code class="docutils literal notranslate"><span class="pre">nl-cov-linear-model</span></code> [<code class="docutils literal notranslate"><span class="pre">none</span> <span class="pre">|</span> <span class="pre">initial</span> <span class="pre">|</span> <span class="pre">persistent</span></code>, default <code class="docutils literal notranslate"><span class="pre">none</span></code>]</dt><dd><p>whether to use the linear model as initial guess for the cylindrical algebraic coverings solver</p>
<p>Modes for the usage of the linear model in non-linear arithmetic.</p>
<dl class="field-list simple">
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">none</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>Do not use linear model to seed nonlinear model</p>
</dd>
<dt class="field-even"><code class="docutils literal notranslate"><span class="pre">initial</span></code><span class="colon">:</span></dt>
<dd class="field-even"><p>Use linear model to seed nonlinear model initially, discard it when it does not work</p>
</dd>
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">persistent</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>Use linear model to seed nonlinear model whenever possible</p>
</dd>
</dl>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-nl-cov-proj">
<dt><code class="docutils literal notranslate"><span class="pre">nl-cov-proj</span></code> [<code class="docutils literal notranslate"><span class="pre">mccallum</span> <span class="pre">|</span> <span class="pre">lazard</span> <span class="pre">|</span> <span class="pre">lazard-mod</span></code>, default <code class="docutils literal notranslate"><span class="pre">mccallum</span></code>]</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>choose the Coverings projection operator</p>
<p>Modes for the Coverings projection operator in non-linear arithmetic.</p>
<dl class="field-list simple">
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">mccallum</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>McCallum’s projection operator.</p>
</dd>
<dt class="field-even"><code class="docutils literal notranslate"><span class="pre">lazard</span></code><span class="colon">:</span></dt>
<dd class="field-even"><p>Lazard’s projection operator.</p>
</dd>
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">lazard-mod</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>A modification of Lazard’s projection operator.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-nl-cov-prune">
<dt><code class="docutils literal notranslate"><span class="pre">nl-cov-prune</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>whether to prune intervals more aggressively</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-nl-cov-var-elim">
<dt><code class="docutils literal notranslate"><span class="pre">nl-cov-var-elim</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">true</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>whether to eliminate variables using equalities before going into the cylindrical algebraic coverings solver. It can not be used when producing proofs right now.</p>
</dd>
</dl>
<dl id="lbl-option-nl-ext">
<dt><code class="docutils literal notranslate"><span class="pre">nl-ext</span></code> [<code class="docutils literal notranslate"><span class="pre">none</span> <span class="pre">|</span> <span class="pre">light</span> <span class="pre">|</span> <span class="pre">full</span></code>, default <code class="docutils literal notranslate"><span class="pre">full</span></code>]</dt><dd><p>incremental linearization approach to non-linear</p>
<p>Modes for the non-linear linearization</p>
<dl class="field-list simple">
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">none</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>Disable linearization approach</p>
</dd>
<dt class="field-even"><code class="docutils literal notranslate"><span class="pre">light</span></code><span class="colon">:</span></dt>
<dd class="field-even"><p>Only use a few light-weight lemma schemes</p>
</dd>
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">full</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>Use all lemma schemes</p>
</dd>
</dl>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-nl-ext-ent-conf">
<dt><code class="docutils literal notranslate"><span class="pre">nl-ext-ent-conf</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>check for entailed conflicts in non-linear solver</p>
</dd>
</dl>
<dl class="simple" id="lbl-option-nl-ext-factor">
<dt><code class="docutils literal notranslate"><span class="pre">nl-ext-factor</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">true</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p>use factoring inference in non-linear incremental linearization solver</p>
</dd>
</dl>
<dl class="simple" id="lbl-option-nl-ext-flatten-mon">
<dt><code class="docutils literal notranslate"><span class="pre">nl-ext-flatten-mon</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">true</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p>use inference schema based on flattening monomials</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-nl-ext-inc-prec">
<dt><code class="docutils literal notranslate"><span class="pre">nl-ext-inc-prec</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">true</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>whether to increment the precision for irrational function constraints</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-nl-ext-purify">
<dt><code class="docutils literal notranslate"><span class="pre">nl-ext-purify</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>purify non-linear terms at preprocess</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-nl-ext-rbound">
<dt><code class="docutils literal notranslate"><span class="pre">nl-ext-rbound</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>use resolution-style inference for inferring new bounds in non-linear incremental linearization solver</p>
</dd>
</dl>
<dl class="simple" id="lbl-option-nl-ext-rewrite">
<dt><code class="docutils literal notranslate"><span class="pre">nl-ext-rewrite</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">true</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p>do context-dependent simplification based on rewrites in non-linear solver</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-nl-ext-split-zero">
<dt><code class="docutils literal notranslate"><span class="pre">nl-ext-split-zero</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>initial splits on zero for all variables</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-nl-ext-tf-taylor-deg">
<dt><code class="docutils literal notranslate"><span class="pre">nl-ext-tf-taylor-deg</span></code> [type <code class="docutils literal notranslate"><span class="pre">int64_t</span></code>, default <code class="docutils literal notranslate"><span class="pre">4</span></code>]</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>initial degree of polynomials for Taylor approximation</p>
</dd>
</dl>
<dl class="simple" id="lbl-option-nl-ext-tf-tplanes">
<dt><code class="docutils literal notranslate"><span class="pre">nl-ext-tf-tplanes</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">true</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p>use non-terminating tangent plane strategy for transcendental functions for non-linear incremental linearization solver</p>
</dd>
</dl>
<dl class="simple" id="lbl-option-nl-ext-tplanes">
<dt><code class="docutils literal notranslate"><span class="pre">nl-ext-tplanes</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">true</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p>use non-terminating tangent plane strategy for non-linear incremental linearization solver</p>
</dd>
</dl>
<dl class="simple" id="lbl-option-nl-ext-tplanes-interleave">
<dt><code class="docutils literal notranslate"><span class="pre">nl-ext-tplanes-interleave</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p>interleave tangent plane strategy for non-linear incremental linearization solver</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-nl-icp">
<dt><code class="docutils literal notranslate"><span class="pre">nl-icp</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>whether to use ICP-style propagations for non-linear arithmetic</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-nl-rlv">
<dt><code class="docutils literal notranslate"><span class="pre">nl-rlv</span></code> [<code class="docutils literal notranslate"><span class="pre">none</span> <span class="pre">|</span> <span class="pre">interleave</span> <span class="pre">|</span> <span class="pre">always</span></code>, default <code class="docutils literal notranslate"><span class="pre">none</span></code>]</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>choose mode for using relevance of assertions in non-linear arithmetic</p>
<p>Modes for using relevance of assertions in non-linear arithmetic.</p>
<dl class="field-list simple">
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">none</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>Do not use relevance.</p>
</dd>
<dt class="field-even"><code class="docutils literal notranslate"><span class="pre">interleave</span></code><span class="colon">:</span></dt>
<dd class="field-even"><p>Alternate rounds using relevance.</p>
</dd>
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">always</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>Always use relevance.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-nl-rlv-assert-bounds">
<dt><code class="docutils literal notranslate"><span class="pre">nl-rlv-assert-bounds</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>use bound inference utility to prune when an assertion is entailed by another</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-pb-rewrites">
<dt><code class="docutils literal notranslate"><span class="pre">pb-rewrites</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>apply pseudo boolean rewrites</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-pivot-threshold">
<dt><code class="docutils literal notranslate"><span class="pre">pivot-threshold</span></code> [type <code class="docutils literal notranslate"><span class="pre">uint64_t</span></code>, default <code class="docutils literal notranslate"><span class="pre">2</span></code>]</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>sets the number of pivots using –pivot-rule per basic variable per simplex instance before using variable order</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-pp-assert-max-sub-size">
<dt><code class="docutils literal notranslate"><span class="pre">pp-assert-max-sub-size</span></code> [type <code class="docutils literal notranslate"><span class="pre">uint64_t</span></code>, default <code class="docutils literal notranslate"><span class="pre">2</span></code>]</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>threshold for substituting an equality in ppAssert</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-prop-row-length">
<dt><code class="docutils literal notranslate"><span class="pre">prop-row-length</span></code> [type <code class="docutils literal notranslate"><span class="pre">uint64_t</span></code>, default <code class="docutils literal notranslate"><span class="pre">16</span></code>]</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>sets the maximum row length to be used in propagation</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-replay-early-close-depth">
<dt><code class="docutils literal notranslate"><span class="pre">replay-early-close-depth</span></code> [type <code class="docutils literal notranslate"><span class="pre">int64_t</span></code>, default <code class="docutils literal notranslate"><span class="pre">1</span></code>]</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>multiples of the depths to try to close the approx log eagerly</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-replay-lemma-reject-cut">
<dt><code class="docutils literal notranslate"><span class="pre">replay-lemma-reject-cut</span></code> [type <code class="docutils literal notranslate"><span class="pre">uint64_t</span></code>, default <code class="docutils literal notranslate"><span class="pre">25500</span></code>]</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>maximum complexity of any coefficient while outputting replaying cut lemmas</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-replay-num-err-penalty">
<dt><code class="docutils literal notranslate"><span class="pre">replay-num-err-penalty</span></code> [type <code class="docutils literal notranslate"><span class="pre">int64_t</span></code>, default <code class="docutils literal notranslate"><span class="pre">4194304</span></code>]</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>number of solve integer attempts to skips after a numeric failure</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-replay-reject-cut">
<dt><code class="docutils literal notranslate"><span class="pre">replay-reject-cut</span></code> [type <code class="docutils literal notranslate"><span class="pre">uint64_t</span></code>, default <code class="docutils literal notranslate"><span class="pre">25500</span></code>]</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>maximum complexity of any coefficient while replaying cuts</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-restrict-pivots">
<dt><code class="docutils literal notranslate"><span class="pre">restrict-pivots</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">true</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>have a pivot cap for simplex at effort levels below fullEffort</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-revert-arith-models-on-unsat">
<dt><code class="docutils literal notranslate"><span class="pre">revert-arith-models-on-unsat</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>revert the arithmetic model to a known safe model on unsat if one is cached</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-rr-turns">
<dt><code class="docutils literal notranslate"><span class="pre">rr-turns</span></code> [type <code class="docutils literal notranslate"><span class="pre">int64_t</span></code>, default <code class="docutils literal notranslate"><span class="pre">3</span></code>]</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>round robin turn</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-se-solve-int">
<dt><code class="docutils literal notranslate"><span class="pre">se-solve-int</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>attempt to use the approximate solve integer method on standard effort</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-simplex-check-period">
<dt><code class="docutils literal notranslate"><span class="pre">simplex-check-period</span></code> [type <code class="docutils literal notranslate"><span class="pre">uint64_t</span></code>, default <code class="docutils literal notranslate"><span class="pre">200</span></code>]</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>the number of pivots to do in simplex before rechecking for a conflict on all variables</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-soi-qe">
<dt><code class="docutils literal notranslate"><span class="pre">soi-qe</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>use quick explain to minimize the sum of infeasibility conflicts</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-standard-effort-variable-order-pivots">
<dt><code class="docutils literal notranslate"><span class="pre">standard-effort-variable-order-pivots</span></code> [type <code class="docutils literal notranslate"><span class="pre">int64_t</span></code>, default <code class="docutils literal notranslate"><span class="pre">-1</span></code>]</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>limits the number of pivots in a single invocation of check() at a non-full effort level using Bland’s pivot rule</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-unate-lemmas">
<dt><code class="docutils literal notranslate"><span class="pre">unate-lemmas</span></code> [<code class="docutils literal notranslate"><span class="pre">all</span> <span class="pre">|</span> <span class="pre">eqs</span> <span class="pre">|</span> <span class="pre">ineqs</span> <span class="pre">|</span> <span class="pre">none</span></code>, default <code class="docutils literal notranslate"><span class="pre">all</span></code>]</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>determines which lemmas to add before solving (default is ‘all’, see –unate-lemmas=help)</p>
<p>Unate lemmas are generated before SAT search begins using the relationship of constant terms and polynomials.</p>
<dl class="field-list simple">
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">all</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>A combination of inequalities and equalities.</p>
</dd>
<dt class="field-even"><code class="docutils literal notranslate"><span class="pre">eqs</span></code><span class="colon">:</span></dt>
<dd class="field-even"><p>Outputs lemmas of the general forms (= p c) implies (&lt;= p d) for c &lt; d, or (= p c) implies (not (= p d)) for c != d.</p>
</dd>
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">ineqs</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>Outputs lemmas of the general form (&lt;= p c) implies (&lt;= p d) for c &lt; d.</p>
</dd>
<dt class="field-even"><code class="docutils literal notranslate"><span class="pre">none</span></code><span class="colon">:</span></dt>
<dd class="field-even"><p>Do not add unate lemmas.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-use-approx">
<dt><code class="docutils literal notranslate"><span class="pre">use-approx</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>attempt to use an approximate solver</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-use-fcsimplex">
<dt><code class="docutils literal notranslate"><span class="pre">use-fcsimplex</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>use focusing and converging simplex (FMCAD 2013 submission)</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-use-soi">
<dt><code class="docutils literal notranslate"><span class="pre">use-soi</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>use sum of infeasibility simplex (FMCAD 2013 submission)</p>
</dd>
</dl>
</section>
<section id="arrays-theory-module">
<h3>Arrays Theory Module<a class="headerlink" href="#arrays-theory-module" title="Link to this heading"></a></h3>
<dl class="simple" id="lbl-option-arrays-eager-index">
<dt><code class="docutils literal notranslate"><span class="pre">arrays-eager-index</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">true</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p>turn on eager index splitting for generated array lemmas</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-arrays-eager-lemmas">
<dt><code class="docutils literal notranslate"><span class="pre">arrays-eager-lemmas</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>turn on eager lemma generation for arrays</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-arrays-exp">
<dt><code class="docutils literal notranslate"><span class="pre">arrays-exp</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>enable experimental features in the theory of arrays</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-arrays-optimize-linear">
<dt><code class="docutils literal notranslate"><span class="pre">arrays-optimize-linear</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">true</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>turn on optimization for linear array terms (see de Moura FMCAD 09 arrays paper)</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-arrays-prop">
<dt><code class="docutils literal notranslate"><span class="pre">arrays-prop</span></code> [type <code class="docutils literal notranslate"><span class="pre">int64_t</span></code>, default <code class="docutils literal notranslate"><span class="pre">2</span></code>]</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>propagation effort for arrays: 0 is none, 1 is some, 2 is full</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-arrays-reduce-sharing">
<dt><code class="docutils literal notranslate"><span class="pre">arrays-reduce-sharing</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>use model information to reduce size of care graph for arrays</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-arrays-weak-equiv">
<dt><code class="docutils literal notranslate"><span class="pre">arrays-weak-equiv</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>use algorithm from Christ/Hoenicke (SMT 2014)</p>
</dd>
</dl>
</section>
<section id="bags-theory-module">
<h3>Bags Theory Module<a class="headerlink" href="#bags-theory-module" title="Link to this heading"></a></h3>
<dl class="expert-option simple" id="lbl-option-bags">
<dt><code class="docutils literal notranslate"><span class="pre">bags</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">true</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>enables the bags solver in applicable logics</p>
</dd>
</dl>
</section>
<section id="base-module">
<h3>Base Module<a class="headerlink" href="#base-module" title="Link to this heading"></a></h3>
<dl class="expert-option simple" id="lbl-option-err">
<dt><code class="docutils literal notranslate"><span class="pre">err</span> <span class="pre">|</span> <span class="pre">diagnostic-output-channel</span></code> [custom <code class="docutils literal notranslate"><span class="pre">ManagedErr</span></code>, default <code class="docutils literal notranslate"><span class="pre">{}</span></code>]</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>Set the error (or diagnostic) output channel. Writes to stderr for “stderr” or “–”, stdout for “stdout” or the given filename otherwise.</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-in">
<dt><code class="docutils literal notranslate"><span class="pre">in</span></code> [custom <code class="docutils literal notranslate"><span class="pre">ManagedIn</span></code>, default <code class="docutils literal notranslate"><span class="pre">{}</span></code>]</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>Set the input channel. Reads from stdin for “stdin” or “–” and the given filename otherwise.</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-out">
<dt><code class="docutils literal notranslate"><span class="pre">out</span> <span class="pre">|</span> <span class="pre">regular-output-channel</span></code> [custom <code class="docutils literal notranslate"><span class="pre">ManagedOut</span></code>, default <code class="docutils literal notranslate"><span class="pre">{}</span></code>]</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>Set the regular output channel. Writes to stdout for “stdout” or “–”, stderr for “stderr” or the given filename otherwise.</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-plugin-notify-sat-clause-in-solve">
<dt><code class="docutils literal notranslate"><span class="pre">plugin-notify-sat-clause-in-solve</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">true</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>only inform plugins of SAT clauses when we are in the main solving loop of the SAT solver</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-plugin-share-skolems">
<dt><code class="docutils literal notranslate"><span class="pre">plugin-share-skolems</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">true</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>true if we permit sharing theory lemmas and SAT clauses with skolems</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-rweight">
<dt><code class="docutils literal notranslate"><span class="pre">rweight</span></code> [type <code class="docutils literal notranslate"><span class="pre">string</span></code>]</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>set a single resource weight</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-safe-mode">
<dt><code class="docutils literal notranslate"><span class="pre">safe-mode</span></code> [<code class="docutils literal notranslate"><span class="pre">unrestricted</span> <span class="pre">|</span> <span class="pre">safe</span> <span class="pre">|</span> <span class="pre">stable</span></code>, default <code class="docutils literal notranslate"><span class="pre">unrestricted</span></code>]</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>modes for restricting expert options and theories</p>
<p>Modes for restricting expert options and theories.</p>
<dl class="field-list simple">
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">unrestricted</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>Do not restrict options or theories.</p>
</dd>
<dt class="field-even"><code class="docutils literal notranslate"><span class="pre">safe</span></code><span class="colon">:</span></dt>
<dd class="field-even"><p>Do not allow using expert options or theories, more than one regular option, or any feature that does not have full proof and model support.</p>
</dd>
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">stable</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>Do not allow using expert options or theories, or more than one regular option. May allow incomplete proofs or models.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="simple" id="lbl-option-stats-every-query">
<dt><code class="docutils literal notranslate"><span class="pre">stats-every-query</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p>in incremental mode, print stats after every satisfiability or validity query</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-trace">
<dt><code class="docutils literal notranslate"><span class="pre">t</span> <span class="pre">|</span> <span class="pre">trace</span></code> [type <code class="docutils literal notranslate"><span class="pre">string</span></code>]</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>trace something (e.g. -t pushpop), can repeat and may contain wildcards like (e.g. -t theory::*)</p>
</dd>
</dl>
</section>
<section id="bitvector-theory-module">
<h3>Bitvector Theory Module<a class="headerlink" href="#bitvector-theory-module" title="Link to this heading"></a></h3>
<dl id="lbl-option-bitblast">
<dt><code class="docutils literal notranslate"><span class="pre">bitblast</span></code> [<code class="docutils literal notranslate"><span class="pre">lazy</span> <span class="pre">|</span> <span class="pre">eager</span></code>, default <code class="docutils literal notranslate"><span class="pre">lazy</span></code>]</dt><dd><p>choose bitblasting mode, see –bitblast=help</p>
<p>Bit-blasting modes.</p>
<dl class="field-list simple">
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">lazy</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>Separate Boolean structure and term reasoning between the core SAT solver and the bit-vector SAT solver.</p>
</dd>
<dt class="field-even"><code class="docutils literal notranslate"><span class="pre">eager</span></code><span class="colon">:</span></dt>
<dd class="field-even"><p>Bitblast eagerly to bit-vector SAT solver.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-bitwise-eq">
<dt><code class="docutils literal notranslate"><span class="pre">bitwise-eq</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>lift equivalence with one-bit bit-vectors to be boolean operations</p>
</dd>
</dl>
<dl id="lbl-option-bool-to-bv">
<dt><code class="docutils literal notranslate"><span class="pre">bool-to-bv</span></code> [<code class="docutils literal notranslate"><span class="pre">off</span> <span class="pre">|</span> <span class="pre">ite</span> <span class="pre">|</span> <span class="pre">all</span></code>, default <code class="docutils literal notranslate"><span class="pre">off</span></code>]</dt><dd><p>convert booleans to bit-vectors of size 1 at various levels of aggressiveness, see –bool-to-bv=help</p>
<p>BoolToBV preprocessing pass modes.</p>
<dl class="field-list simple">
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">off</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>Don’t push any booleans to width one bit-vectors.</p>
</dd>
<dt class="field-even"><code class="docutils literal notranslate"><span class="pre">ite</span></code><span class="colon">:</span></dt>
<dd class="field-even"><p>Try to turn ITEs into BITVECTOR_ITE when possible. It can fail per-formula if not all sub-formulas can be turned to bit-vectors.</p>
</dd>
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">all</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>Force all booleans to be bit-vectors of width one except at the top level. Most aggressive mode.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-bv-assert-input">
<dt><code class="docutils literal notranslate"><span class="pre">bv-assert-input</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>assert input assertions on user-level 0 instead of assuming them in the bit-vector SAT solver</p>
</dd>
</dl>
<dl class="simple" id="lbl-option-bv-eager-eval">
<dt><code class="docutils literal notranslate"><span class="pre">bv-eager-eval</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p>perform eager context-dependent evaluation for applications of bv kinds in the equality engine</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-bv-eq-engine">
<dt><code class="docutils literal notranslate"><span class="pre">bv-eq-engine</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">true</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>enable equality engine when possible in bitvector theory</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-bv-gauss-elim">
<dt><code class="docutils literal notranslate"><span class="pre">bv-gauss-elim</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>simplify formula via Gaussian Elimination if applicable</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-bv-intro-pow2">
<dt><code class="docutils literal notranslate"><span class="pre">bv-intro-pow2</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>introduce bitvector powers of two as a preprocessing pass</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-bv-propagate">
<dt><code class="docutils literal notranslate"><span class="pre">bv-propagate</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">true</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>use bit-vector propagation in the bit-blaster</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-bv-rw-extend-eq">
<dt><code class="docutils literal notranslate"><span class="pre">bv-rw-extend-eq</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>enable additional rewrites over zero/sign extend over equalities with constants (useful on BV/2017-Preiner-scholl-smt08)</p>
</dd>
</dl>
<dl id="lbl-option-bv-sat-solver">
<dt><code class="docutils literal notranslate"><span class="pre">bv-sat-solver</span></code> [<code class="docutils literal notranslate"><span class="pre">minisat</span> <span class="pre">|</span> <span class="pre">cryptominisat</span> <span class="pre">|</span> <span class="pre">cadical</span> <span class="pre">|</span> <span class="pre">kissat</span></code>, default <code class="docutils literal notranslate"><span class="pre">cadical</span></code>]</dt><dd><p>choose which sat solver to use, see –bv-sat-solver=help</p>
<p>SAT solver for bit-blasting backend.</p>
</dd>
</dl>
<dl id="lbl-option-bv-solver">
<dt><code class="docutils literal notranslate"><span class="pre">bv-solver</span></code> [<code class="docutils literal notranslate"><span class="pre">bitblast</span> <span class="pre">|</span> <span class="pre">bitblast-internal</span></code>, default <code class="docutils literal notranslate"><span class="pre">bitblast</span></code>]</dt><dd><p>choose bit-vector solver, see –bv-solver=help</p>
<p>Bit-vector solvers.</p>
<dl class="field-list simple">
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">bitblast</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>Enables bitblasting solver.</p>
</dd>
<dt class="field-even"><code class="docutils literal notranslate"><span class="pre">bitblast-internal</span></code><span class="colon">:</span></dt>
<dd class="field-even"><p>Enables bitblasting to internal SAT solver with proof support.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="simple" id="lbl-option-bv-to-bool">
<dt><code class="docutils literal notranslate"><span class="pre">bv-to-bool</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p>lift bit-vectors of size 1 to booleans when possible</p>
</dd>
</dl>
</section>
<section id="datatypes-theory-module">
<h3>Datatypes Theory Module<a class="headerlink" href="#datatypes-theory-module" title="Link to this heading"></a></h3>
<dl class="expert-option simple" id="lbl-option-cdt-bisimilar">
<dt><code class="docutils literal notranslate"><span class="pre">cdt-bisimilar</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">true</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>do bisimilarity check for co-datatypes</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-datatypes-exp">
<dt><code class="docutils literal notranslate"><span class="pre">datatypes-exp</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">true</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>enables reasoning about codatatypes and extended datatype terms</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-dt-binary-split">
<dt><code class="docutils literal notranslate"><span class="pre">dt-binary-split</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>do binary splits for datatype constructor types</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-dt-blast-splits">
<dt><code class="docutils literal notranslate"><span class="pre">dt-blast-splits</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>when applicable, blast splitting lemmas for all variables at once</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-dt-cyclic">
<dt><code class="docutils literal notranslate"><span class="pre">dt-cyclic</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">true</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>do cyclicity check for datatypes</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-dt-infer-as-lemmas">
<dt><code class="docutils literal notranslate"><span class="pre">dt-infer-as-lemmas</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>always send lemmas out instead of making internal inferences</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-dt-nested-rec">
<dt><code class="docutils literal notranslate"><span class="pre">dt-nested-rec</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>allow nested recursion in datatype definitions</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-dt-polite-optimize">
<dt><code class="docutils literal notranslate"><span class="pre">dt-polite-optimize</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">true</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>turn on optimization for polite combination</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-dt-share-sel">
<dt><code class="docutils literal notranslate"><span class="pre">dt-share-sel</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>internally use shared selectors across multiple constructors</p>
</dd>
</dl>
<dl class="simple" id="lbl-option-sygus-abort-size">
<dt><code class="docutils literal notranslate"><span class="pre">sygus-abort-size</span></code> [type <code class="docutils literal notranslate"><span class="pre">int64_t</span></code>, default <code class="docutils literal notranslate"><span class="pre">-1</span></code>]</dt><dd><p>tells enumerative sygus to only consider solutions up to term size N (-1 == no limit, default)</p>
</dd>
</dl>
<dl id="lbl-option-sygus-fair">
<dt><code class="docutils literal notranslate"><span class="pre">sygus-fair</span></code> [<code class="docutils literal notranslate"><span class="pre">direct</span> <span class="pre">|</span> <span class="pre">dt-size</span> <span class="pre">|</span> <span class="pre">dt-height-bound</span> <span class="pre">|</span> <span class="pre">dt-size-bound</span> <span class="pre">|</span> <span class="pre">none</span></code>, default <code class="docutils literal notranslate"><span class="pre">dt-size</span></code>]</dt><dd><p>if and how to apply fairness for sygus</p>
<p>Modes for enforcing fairness for counterexample guided quantifier instantion.</p>
<dl class="field-list simple">
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">direct</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>Enforce fairness using direct conflict lemmas.</p>
</dd>
<dt class="field-even"><code class="docutils literal notranslate"><span class="pre">dt-size</span></code><span class="colon">:</span></dt>
<dd class="field-even"><p>Enforce fairness using size operator.</p>
</dd>
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">dt-height-bound</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>Enforce fairness by height bound predicate.</p>
</dd>
<dt class="field-even"><code class="docutils literal notranslate"><span class="pre">dt-size-bound</span></code><span class="colon">:</span></dt>
<dd class="field-even"><p>Enforce fairness by size bound predicate.</p>
</dd>
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">none</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>Do not enforce fairness.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-sygus-fair-max">
<dt><code class="docutils literal notranslate"><span class="pre">sygus-fair-max</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">true</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>use max instead of sum for multi-function sygus conjectures</p>
</dd>
</dl>
<dl id="lbl-option-sygus-rewriter">
<dt><code class="docutils literal notranslate"><span class="pre">sygus-rewriter</span></code> [<code class="docutils literal notranslate"><span class="pre">none</span> <span class="pre">|</span> <span class="pre">basic</span> <span class="pre">|</span> <span class="pre">extended</span></code>, default <code class="docutils literal notranslate"><span class="pre">extended</span></code>]</dt><dd><p>if and how to apply rewriting for sygus symmetry breaking</p>
<p>Modes for applying rewriting for sygus symmetry breaking.</p>
<dl class="field-list simple">
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">none</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>Do not use the rewriter.</p>
</dd>
<dt class="field-even"><code class="docutils literal notranslate"><span class="pre">basic</span></code><span class="colon">:</span></dt>
<dd class="field-even"><p>Use the basic rewriter.</p>
</dd>
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">extended</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>Use the extended rewriter.</p>
</dd>
</dl>
</dd>
</dl>
<dl id="lbl-option-sygus-simple-sym-break">
<dt><code class="docutils literal notranslate"><span class="pre">sygus-simple-sym-break</span></code> [<code class="docutils literal notranslate"><span class="pre">none</span> <span class="pre">|</span> <span class="pre">basic</span> <span class="pre">|</span> <span class="pre">agg</span></code>, default <code class="docutils literal notranslate"><span class="pre">agg</span></code>]</dt><dd><p>if and how to apply simple symmetry breaking based on the grammar for smart enumeration</p>
<p>Modes for applying simple symmetry breaking based on the grammar for smart enumeration.</p>
<dl class="field-list simple">
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">none</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>Do not apply simple symmetry breaking.</p>
</dd>
<dt class="field-even"><code class="docutils literal notranslate"><span class="pre">basic</span></code><span class="colon">:</span></dt>
<dd class="field-even"><p>Apply basic simple symmetry breaking.</p>
</dd>
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">agg</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>Apply aggressive simple symmetry breaking.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-sygus-sym-break-lazy">
<dt><code class="docutils literal notranslate"><span class="pre">sygus-sym-break-lazy</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">true</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>lazily add symmetry breaking lemmas for terms</p>
</dd>
</dl>
<dl class="simple" id="lbl-option-sygus-sym-break-pbe">
<dt><code class="docutils literal notranslate"><span class="pre">sygus-sym-break-pbe</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">true</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p>sygus symmetry breaking lemmas based on pbe conjectures</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-sygus-sym-break-rlv">
<dt><code class="docutils literal notranslate"><span class="pre">sygus-sym-break-rlv</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">true</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>add relevancy conditions to symmetry breaking lemmas</p>
</dd>
</dl>
</section>
<section id="decision-heuristics-module">
<h3>Decision Heuristics Module<a class="headerlink" href="#decision-heuristics-module" title="Link to this heading"></a></h3>
<dl class="expert-option simple" id="lbl-option-jh-rlv-order">
<dt><code class="docutils literal notranslate"><span class="pre">jh-rlv-order</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>maintain activity-based ordering for decision justification heuristic</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-jh-skolem">
<dt><code class="docutils literal notranslate"><span class="pre">jh-skolem</span></code> [<code class="docutils literal notranslate"><span class="pre">first</span> <span class="pre">|</span> <span class="pre">last</span></code>, default <code class="docutils literal notranslate"><span class="pre">first</span></code>]</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>policy for when to satisfy skolem definitions in justification heuristic</p>
<p>Policy for when to satisfy skolem definitions in justification heuristic</p>
<dl class="field-list simple">
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">first</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>satisfy pending relevant skolem definitions before input assertions</p>
</dd>
<dt class="field-even"><code class="docutils literal notranslate"><span class="pre">last</span></code><span class="colon">:</span></dt>
<dd class="field-even"><p>satisfy pending relevant skolem definitions after input assertions</p>
</dd>
</dl>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-jh-skolem-rlv">
<dt><code class="docutils literal notranslate"><span class="pre">jh-skolem-rlv</span></code> [<code class="docutils literal notranslate"><span class="pre">assert</span> <span class="pre">|</span> <span class="pre">always</span></code>, default <code class="docutils literal notranslate"><span class="pre">assert</span></code>]</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>policy for when to consider skolem definitions relevant in justification heuristic</p>
<p>Policy for when to consider skolem definitions relevant in justification heuristic</p>
<dl class="field-list simple">
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">assert</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>skolems are relevant when they occur in an asserted literal</p>
</dd>
<dt class="field-even"><code class="docutils literal notranslate"><span class="pre">always</span></code><span class="colon">:</span></dt>
<dd class="field-even"><p>skolems are always relevant</p>
</dd>
</dl>
</dd>
</dl>
</section>
<section id="expression-module">
<h3>Expression Module<a class="headerlink" href="#expression-module" title="Link to this heading"></a></h3>
<dl class="expert-option simple" id="lbl-option-type-checking">
<dt><code class="docutils literal notranslate"><span class="pre">type-checking</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">DO_SEMANTIC_CHECKS_BY_DEFAULT</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>type check expressions</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-wf-checking">
<dt><code class="docutils literal notranslate"><span class="pre">wf-checking</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">true</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>check that terms passed to API methods are well formed (default false for text interface)</p>
</dd>
</dl>
</section>
<section id="finite-field-theory-module">
<h3>Finite Field Theory Module<a class="headerlink" href="#finite-field-theory-module" title="Link to this heading"></a></h3>
<dl class="expert-option simple" id="lbl-option-ff">
<dt><code class="docutils literal notranslate"><span class="pre">ff</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">true</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>enables the finite field solver in applicable logics</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-ff-bitsum">
<dt><code class="docutils literal notranslate"><span class="pre">ff-bitsum</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>parse bitsums</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-ff-elim-disjunctive-bit">
<dt><code class="docutils literal notranslate"><span class="pre">ff-elim-disjunctive-bit</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">true</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>rewrite disjunctive bit constraints (or (= x 1) (= x 0)) as (= (* x x) x)</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-ff-field-polys">
<dt><code class="docutils literal notranslate"><span class="pre">ff-field-polys</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>include field polynomials in Groebner basis computation; don’t do this</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-ff-solver">
<dt><code class="docutils literal notranslate"><span class="pre">ff-solver</span></code> [<code class="docutils literal notranslate"><span class="pre">gb</span> <span class="pre">|</span> <span class="pre">split</span></code>, default <code class="docutils literal notranslate"><span class="pre">gb</span></code>]</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>which field solver (default: ‘gb’; see –ff-solver=help)</p>
<p>Which field solver</p>
<dl class="field-list simple">
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">gb</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>use one Groebner basis for the whole system</p>
</dd>
<dt class="field-even"><code class="docutils literal notranslate"><span class="pre">split</span></code><span class="colon">:</span></dt>
<dd class="field-even"><p>use multiple Groebner bases for partitions of the system</p>
</dd>
</dl>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-ff-trace-gb">
<dt><code class="docutils literal notranslate"><span class="pre">ff-trace-gb</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">true</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>use a traced groebner basis engine</p>
</dd>
</dl>
</section>
<section id="floating-point-module">
<h3>Floating-Point Module<a class="headerlink" href="#floating-point-module" title="Link to this heading"></a></h3>
<dl class="expert-option simple" id="lbl-option-fp">
<dt><code class="docutils literal notranslate"><span class="pre">fp</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">true</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>enables the floating point theory in applicable logics</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-fp-exp">
<dt><code class="docutils literal notranslate"><span class="pre">fp-exp</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>Allow floating-point sorts of all sizes, rather than only Float32 (8/24) or Float64 (11/53) (experimental)</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-fp-lazy-wb">
<dt><code class="docutils literal notranslate"><span class="pre">fp-lazy-wb</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>Enable lazier word-blasting (on preNotifyFact instead of registerTerm)</p>
</dd>
</dl>
</section>
<section id="driver-module">
<h3>Driver Module<a class="headerlink" href="#driver-module" title="Link to this heading"></a></h3>
<dl class="simple" id="lbl-option-dump-difficulty">
<dt><code class="docutils literal notranslate"><span class="pre">dump-difficulty</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p>dump the difficulty measure after every response to check-sat</p>
</dd>
</dl>
<dl class="simple" id="lbl-option-dump-instantiations">
<dt><code class="docutils literal notranslate"><span class="pre">dump-instantiations</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p>output instantiations of quantified formulas after every UNSAT/VALID response</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-dump-instantiations-debug">
<dt><code class="docutils literal notranslate"><span class="pre">dump-instantiations-debug</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>output instantiations of quantified formulas after every UNSAT/VALID response, with debug information</p>
</dd>
</dl>
<dl class="simple" id="lbl-option-dump-models">
<dt><code class="docutils literal notranslate"><span class="pre">dump-models</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p>output models after every SAT/INVALID/UNKNOWN response</p>
</dd>
</dl>
<dl class="simple" id="lbl-option-dump-proofs">
<dt><code class="docutils literal notranslate"><span class="pre">dump-proofs</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p>output proofs after every UNSAT/VALID response</p>
</dd>
</dl>
<dl class="simple" id="lbl-option-dump-unsat-cores">
<dt><code class="docutils literal notranslate"><span class="pre">dump-unsat-cores</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p>output unsat cores after every UNSAT/VALID response</p>
</dd>
</dl>
<dl class="simple" id="lbl-option-dump-unsat-cores-lemmas">
<dt><code class="docutils literal notranslate"><span class="pre">dump-unsat-cores-lemmas</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p>output lemmas in unsat cores after every UNSAT/VALID response</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-force-no-limit-cpu-while-dump">
<dt><code class="docutils literal notranslate"><span class="pre">force-no-limit-cpu-while-dump</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>Force no CPU limit when dumping models and proofs</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-portfolio-dry-run">
<dt><code class="docutils literal notranslate"><span class="pre">portfolio-dry-run</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>Print the strategies that would be run with –use-portfolio, without executing them</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-portfolio-jobs">
<dt><code class="docutils literal notranslate"><span class="pre">portfolio-jobs</span></code> [type <code class="docutils literal notranslate"><span class="pre">uint64_t</span></code>, default <code class="docutils literal notranslate"><span class="pre">1</span></code>]</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>Number of parallel jobs the portfolio engine can run</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-segv-spin">
<dt><code class="docutils literal notranslate"><span class="pre">segv-spin</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>spin on segfault/other crash waiting for gdb</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-show-trace-tags">
<dt><code class="docutils literal notranslate"><span class="pre">show-trace-tags</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>]</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>show all available tags for tracing</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-use-portfolio">
<dt><code class="docutils literal notranslate"><span class="pre">use-portfolio</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>Use internal portfolio mode based on the logic</p>
</dd>
</dl>
</section>
<section id="parallel-module">
<h3>Parallel Module<a class="headerlink" href="#parallel-module" title="Link to this heading"></a></h3>
<dl class="expert-option simple" id="lbl-option-append-learned-literals-to-cubes">
<dt><code class="docutils literal notranslate"><span class="pre">append-learned-literals-to-cubes</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>emit learned literals with the cubes</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-checks-before-partition">
<dt><code class="docutils literal notranslate"><span class="pre">checks-before-partition</span></code> [type <code class="docutils literal notranslate"><span class="pre">uint64_t</span></code>, default <code class="docutils literal notranslate"><span class="pre">1</span></code>]</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>number of standard or full effort checks until partitioning</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-checks-between-partitions">
<dt><code class="docutils literal notranslate"><span class="pre">checks-between-partitions</span></code> [type <code class="docutils literal notranslate"><span class="pre">uint64_t</span></code>, default <code class="docutils literal notranslate"><span class="pre">1</span></code>]</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>number of checks between partitions</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-compute-partitions">
<dt><code class="docutils literal notranslate"><span class="pre">compute-partitions</span></code> [type <code class="docutils literal notranslate"><span class="pre">uint64_t</span></code>, default <code class="docutils literal notranslate"><span class="pre">0</span></code>]</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>make n partitions. n &lt;2 disables computing partitions entirely</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-partition-check">
<dt><code class="docutils literal notranslate"><span class="pre">partition-check</span> <span class="pre">|</span> <span class="pre">check</span></code> [<code class="docutils literal notranslate"><span class="pre">standard</span> <span class="pre">|</span> <span class="pre">full</span></code>, default <code class="docutils literal notranslate"><span class="pre">standard</span></code>]</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>select whether partitioning happens at full or standard check</p>
<p>Partition check modes.</p>
<dl class="field-list simple">
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">standard</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>create partitions at standard checks</p>
</dd>
<dt class="field-even"><code class="docutils literal notranslate"><span class="pre">full</span></code><span class="colon">:</span></dt>
<dd class="field-even"><p>create partitions at full checks</p>
</dd>
</dl>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-partition-conflict-size">
<dt><code class="docutils literal notranslate"><span class="pre">partition-conflict-size</span></code> [type <code class="docutils literal notranslate"><span class="pre">uint64_t</span></code>, default <code class="docutils literal notranslate"><span class="pre">0</span></code>]</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>number of literals in a cube; if no partition size is set, then the partition conflict size is chosen to be log2(number of requested partitions)</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-partition-start-time">
<dt><code class="docutils literal notranslate"><span class="pre">partition-start-time</span></code> [type <code class="docutils literal notranslate"><span class="pre">uint64_t</span></code>, default <code class="docutils literal notranslate"><span class="pre">30</span></code>]</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>time to start creating partitions in seconds</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-partition-strategy">
<dt><code class="docutils literal notranslate"><span class="pre">partition-strategy</span> <span class="pre">|</span> <span class="pre">partition</span></code> [<code class="docutils literal notranslate"><span class="pre">decision-scatter</span> <span class="pre">|</span> <span class="pre">heap-scatter</span> <span class="pre">|</span> <span class="pre">lemma-scatter</span> <span class="pre">|</span> <span class="pre">decision-cube</span> <span class="pre">|</span> <span class="pre">heap-cube</span> <span class="pre">|</span> <span class="pre">lemma-cube</span></code>, default <code class="docutils literal notranslate"><span class="pre">decision-scatter</span></code>]</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>choose partition strategy mode</p>
<p>Partition strategy modes.</p>
<dl class="field-list simple">
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">decision-scatter</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>For 4 partitions, creates partitions C1, !C1 &amp; C2, !C1 &amp; !C2 &amp; C3, !C1 &amp; !C2 &amp; !C3, from decisions</p>
</dd>
<dt class="field-even"><code class="docutils literal notranslate"><span class="pre">heap-scatter</span></code><span class="colon">:</span></dt>
<dd class="field-even"><p>For 4 partitions, creates partitions C1, !C1 &amp; C2, !C1 &amp; !C2 &amp; C3, !C1 &amp; !C2 &amp; !C3, from heap</p>
</dd>
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">lemma-scatter</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>For 4 partitions, creates partitions C1, !C1 &amp; C2, !C1 &amp; !C2 &amp; C3, !C1 &amp; !C2 &amp; !C3, from lemmas</p>
</dd>
<dt class="field-even"><code class="docutils literal notranslate"><span class="pre">decision-cube</span></code><span class="colon">:</span></dt>
<dd class="field-even"><p>Creates mutually exclusive cubes from the decisions in the SAT solver.</p>
</dd>
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">heap-cube</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>Creates mutually exclusive cubes from the order heap in the SAT solver.</p>
</dd>
<dt class="field-even"><code class="docutils literal notranslate"><span class="pre">lemma-cube</span></code><span class="colon">:</span></dt>
<dd class="field-even"><p>Creates mutually exclusive cubes from the lemmas sent to the SAT solver.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-partition-time-interval">
<dt><code class="docutils literal notranslate"><span class="pre">partition-time-interval</span></code> [type <code class="docutils literal notranslate"><span class="pre">double</span></code>, default <code class="docutils literal notranslate"><span class="pre">1.0</span></code>]</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>time to wait between scatter partitions</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-partition-tlimit">
<dt><code class="docutils literal notranslate"><span class="pre">partition-tlimit</span></code> [type <code class="docutils literal notranslate"><span class="pre">uint64_t</span></code>, default <code class="docutils literal notranslate"><span class="pre">60</span></code>]</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>time limit for partitioning in seconds</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-partition-when">
<dt><code class="docutils literal notranslate"><span class="pre">partition-when</span></code> [<code class="docutils literal notranslate"><span class="pre">tlimit</span> <span class="pre">|</span> <span class="pre">climit</span></code>, default <code class="docutils literal notranslate"><span class="pre">tlimit</span></code>]</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>choose when to partition</p>
<p>PartitionWhen modes.</p>
<dl class="field-list simple">
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">tlimit</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>Partition when the time limit is exceeded.</p>
</dd>
<dt class="field-even"><code class="docutils literal notranslate"><span class="pre">climit</span></code><span class="colon">:</span></dt>
<dd class="field-even"><p>Partition when number of checks is exceeded.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-random-partitioning">
<dt><code class="docutils literal notranslate"><span class="pre">random-partitioning</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>create random partitions</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-write-partitions-to">
<dt><code class="docutils literal notranslate"><span class="pre">write-partitions-to</span> <span class="pre">|</span> <span class="pre">partitions-out</span></code> [custom <code class="docutils literal notranslate"><span class="pre">ManagedOut</span></code>, default <code class="docutils literal notranslate"><span class="pre">ManagedOut()</span></code>]</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>set the output channel for writing partitions</p>
</dd>
</dl>
</section>
<section id="parser-module">
<h3>Parser Module<a class="headerlink" href="#parser-module" title="Link to this heading"></a></h3>
<dl class="expert-option simple" id="lbl-option-filesystem-access">
<dt><code class="docutils literal notranslate"><span class="pre">filesystem-access</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">true</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>limits the file system access if set to false</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-fresh-binders">
<dt><code class="docutils literal notranslate"><span class="pre">fresh-binders</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>construct fresh variables always when parsing binders</p>
</dd>
</dl>
<dl class="simple" id="lbl-option-fresh-declarations">
<dt><code class="docutils literal notranslate"><span class="pre">fresh-declarations</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">true</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p>use API interface for fresh constants when parsing declarations and definitions</p>
</dd>
</dl>
<dl class="simple" id="lbl-option-global-declarations">
<dt><code class="docutils literal notranslate"><span class="pre">global-declarations</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p>force all declarations and definitions to be global when parsing</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-parse-skolem-definitions">
<dt><code class="docutils literal notranslate"><span class="pre">parse-skolem-definitions</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>allows the parsing of skolems in the input file</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-parsing-mode">
<dt><code class="docutils literal notranslate"><span class="pre">parsing-mode</span></code> [<code class="docutils literal notranslate"><span class="pre">default</span> <span class="pre">|</span> <span class="pre">strict</span> <span class="pre">|</span> <span class="pre">lenient</span></code>, default <code class="docutils literal notranslate"><span class="pre">default</span></code>]</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>choose parsing mode, see –parsing-mode=help</p>
<p>Parsing modes.</p>
<dl class="field-list simple">
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">default</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>Be reasonably tolerant of non-conforming inputs.</p>
</dd>
<dt class="field-even"><code class="docutils literal notranslate"><span class="pre">strict</span></code><span class="colon">:</span></dt>
<dd class="field-even"><p>Be less tolerant of non-conforming inputs.</p>
</dd>
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">lenient</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>Be more tolerant of non-conforming inputs.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-semantic-checks">
<dt><code class="docutils literal notranslate"><span class="pre">semantic-checks</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">DO_SEMANTIC_CHECKS_BY_DEFAULT</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>enable semantic checks, including type checks</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-term-sort-overload">
<dt><code class="docutils literal notranslate"><span class="pre">term-sort-overload</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">true</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>allow overloading of terms and sorts</p>
</dd>
</dl>
</section>
<section id="printing-module">
<h3>Printing Module<a class="headerlink" href="#printing-module" title="Link to this heading"></a></h3>
<dl class="simple" id="lbl-option-bv-print-consts-as-indexed-symbols">
<dt><code class="docutils literal notranslate"><span class="pre">bv-print-consts-as-indexed-symbols</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p>print bit-vector constants in decimal (e.g. (_ bv1 4)) instead of binary (e.g. #b0001), applies to SMT-LIB 2.x</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-flatten-ho-chains">
<dt><code class="docutils literal notranslate"><span class="pre">flatten-ho-chains</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>print (binary) application chains in a flattened way, e.g. (a b c) rather than ((a b) c)</p>
</dd>
</dl>
<dl id="lbl-option-model-u-print">
<dt><code class="docutils literal notranslate"><span class="pre">model-u-print</span></code> [<code class="docutils literal notranslate"><span class="pre">decl-sort-and-fun</span> <span class="pre">|</span> <span class="pre">decl-fun</span> <span class="pre">|</span> <span class="pre">dt</span> <span class="pre">|</span> <span class="pre">none</span></code>, default <code class="docutils literal notranslate"><span class="pre">none</span></code>]</dt><dd><p>determines how to print uninterpreted elements in models</p>
<p>uninterpreted elements in models printing modes.</p>
<dl class="field-list simple">
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">decl-sort-and-fun</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>print uninterpreted elements declare-fun, and also include a declare-sort for the sort</p>
</dd>
<dt class="field-even"><code class="docutils literal notranslate"><span class="pre">decl-fun</span></code><span class="colon">:</span></dt>
<dd class="field-even"><p>print uninterpreted elements declare-fun, but don’t include a declare-sort for the sort</p>
</dd>
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">dt</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>print uninterpreted elements as a declare-datatype</p>
</dd>
<dt class="field-even"><code class="docutils literal notranslate"><span class="pre">none</span></code><span class="colon">:</span></dt>
<dd class="field-even"><p>(default) do not print declarations of uninterpreted elements in models.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-print-arith-lit-token">
<dt><code class="docutils literal notranslate"><span class="pre">print-arith-lit-token</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>print rationals and negative arithmetic literals as lexed tokens, e.g. 1/4, -1.5</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-print-skolem-definitions">
<dt><code class="docutils literal notranslate"><span class="pre">print-skolem-definitions</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>print skolems based on their definitions e.g. &#64;ARRAY_DIFF_N prints instead as (&#64;array.diff A B)</p>
</dd>
</dl>
</section>
<section id="proof-module">
<h3>Proof Module<a class="headerlink" href="#proof-module" title="Link to this heading"></a></h3>
<dl class="expert-option simple" id="lbl-option-check-proof-steps">
<dt><code class="docutils literal notranslate"><span class="pre">check-proof-steps</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>Check proof steps for satisfiability, for refutation soundness testing. Note this checks only steps for non-core proof rules</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-check-proofs-complete">
<dt><code class="docutils literal notranslate"><span class="pre">check-proofs-complete</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>treat an incomplete proof as a failure (enabled by default in safe builds)</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-drat-binary-format">
<dt><code class="docutils literal notranslate"><span class="pre">drat-binary-format</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>Print the DRAT proof in binary format</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-lfsc-expand-trust">
<dt><code class="docutils literal notranslate"><span class="pre">lfsc-expand-trust</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>Print the children of trusted proof steps</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-lfsc-flatten">
<dt><code class="docutils literal notranslate"><span class="pre">lfsc-flatten</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>Flatten steps in the LFSC proof</p>
</dd>
</dl>
<dl class="simple" id="lbl-option-opt-res-reconstruction-size">
<dt><code class="docutils literal notranslate"><span class="pre">opt-res-reconstruction-size</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">true</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p>Optimize resolution reconstruction to reduce proof size</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-print-dot-clusters">
<dt><code class="docutils literal notranslate"><span class="pre">print-dot-clusters</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>Whether the proof node clusters (e.g. SAT, CNF, INPUT) will be printed when using the dot format or not.</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-proof-alethe-define-skolems">
<dt><code class="docutils literal notranslate"><span class="pre">proof-alethe-define-skolems</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>In Alethe proofs, use define-funs in proof preamble for Skolemization terms</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-proof-alethe-res-pivots">
<dt><code class="docutils literal notranslate"><span class="pre">proof-alethe-res-pivots</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>Add pivots to Alethe resolution steps</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-proof-allow-trust">
<dt><code class="docutils literal notranslate"><span class="pre">proof-allow-trust</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">true</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>Whether to allow trust in the proof printer (when applicable)</p>
</dd>
</dl>
<dl class="simple" id="lbl-option-proof-chain-m-res">
<dt><code class="docutils literal notranslate"><span class="pre">proof-chain-m-res</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">true</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p>Use chain multiset resolution</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-proof-dag-global">
<dt><code class="docutils literal notranslate"><span class="pre">proof-dag-global</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">true</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>Dagify terms in proofs using global definitions</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-proof-dot-dag">
<dt><code class="docutils literal notranslate"><span class="pre">proof-dot-dag</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>Indicates if the dot proof will be printed as a DAG or as a tree</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-proof-elim-subtypes">
<dt><code class="docutils literal notranslate"><span class="pre">proof-elim-subtypes</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">true</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>Eliminate subtypes (mixed arithmetic) in proofs</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-proof-format-mode">
<dt><code class="docutils literal notranslate"><span class="pre">proof-format-mode</span></code> [<code class="docutils literal notranslate"><span class="pre">none</span> <span class="pre">|</span> <span class="pre">dot</span> <span class="pre">|</span> <span class="pre">lfsc</span> <span class="pre">|</span> <span class="pre">alethe</span> <span class="pre">|</span> <span class="pre">cpc</span></code>, default <code class="docutils literal notranslate"><span class="pre">cpc</span></code>]</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>select language of proof output</p>
<p>Proof format modes.</p>
<dl class="field-list simple">
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">none</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>Do not translate proof output</p>
</dd>
<dt class="field-even"><code class="docutils literal notranslate"><span class="pre">dot</span></code><span class="colon">:</span></dt>
<dd class="field-even"><p>Output DOT proof</p>
</dd>
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">lfsc</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>Output LFSC proof</p>
</dd>
<dt class="field-even"><code class="docutils literal notranslate"><span class="pre">alethe</span></code><span class="colon">:</span></dt>
<dd class="field-even"><p>Output Alethe proof</p>
</dd>
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">cpc</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>Output Cooperating Proof Calculus proof</p>
</dd>
</dl>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-proof-log">
<dt><code class="docutils literal notranslate"><span class="pre">proof-log</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>Proof logging mode</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-proof-pedantic">
<dt><code class="docutils literal notranslate"><span class="pre">proof-pedantic</span></code> [type <code class="docutils literal notranslate"><span class="pre">uint64_t</span></code>, <code class="docutils literal notranslate"><span class="pre">N</span> <span class="pre">&lt;=</span> <span class="pre">100</span></code>, default <code class="docutils literal notranslate"><span class="pre">0</span></code>]</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>assertion failure for any incorrect rule application or untrusted lemma having pedantic level &lt;=N with proof</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-proof-pp-merge">
<dt><code class="docutils literal notranslate"><span class="pre">proof-pp-merge</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">true</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>merge subproofs in final proof post-processor</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-proof-pre-simp-lookahead">
<dt><code class="docutils literal notranslate"><span class="pre">proof-pre-simp-lookahead</span></code> [type <code class="docutils literal notranslate"><span class="pre">uint64_t</span></code>, default <code class="docutils literal notranslate"><span class="pre">2</span></code>]</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>the lookahead depth for merging proofs at previsit</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-proof-prune-input">
<dt><code class="docutils literal notranslate"><span class="pre">proof-prune-input</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>Prune unused input assumptions from final scope</p>
</dd>
</dl>
<dl class="simple" id="lbl-option-proof-rewrite-rcons-rec-limit">
<dt><code class="docutils literal notranslate"><span class="pre">proof-rewrite-rcons-rec-limit</span></code> [type <code class="docutils literal notranslate"><span class="pre">uint64_t</span></code>, default <code class="docutils literal notranslate"><span class="pre">5</span></code>]</dt><dd><p>the matching recursion limit for reconstructing proofs of theory rewrites</p>
</dd>
</dl>
<dl class="simple" id="lbl-option-proof-rewrite-rcons-step-limit">
<dt><code class="docutils literal notranslate"><span class="pre">proof-rewrite-rcons-step-limit</span></code> [type <code class="docutils literal notranslate"><span class="pre">uint64_t</span></code>, default <code class="docutils literal notranslate"><span class="pre">1000</span></code>]</dt><dd><p>the limit of steps considered for reconstructing proofs of theory rewrites</p>
</dd>
</dl>
<dl id="lbl-option-prop-proof-mode">
<dt><code class="docutils literal notranslate"><span class="pre">prop-proof-mode</span></code> [<code class="docutils literal notranslate"><span class="pre">proof</span> <span class="pre">|</span> <span class="pre">sat-external-prove</span></code>, default <code class="docutils literal notranslate"><span class="pre">proof</span></code>]</dt><dd><p>modes for the type of proof generated by the SAT solver</p>
<p>Modes for the type of proof generated by the SAT solver.</p>
<dl class="field-list simple">
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">proof</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>A proof computed by the SAT solver.</p>
</dd>
<dt class="field-even"><code class="docutils literal notranslate"><span class="pre">sat-external-prove</span></code><span class="colon">:</span></dt>
<dd class="field-even"><p>A proof containing a step that will be proven externally.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-sat-proof-min-dimacs">
<dt><code class="docutils literal notranslate"><span class="pre">sat-proof-min-dimacs</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">true</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>Minimize the DIMACs emitted when prop-proof-mode is set to sat-external-prove</p>
</dd>
</dl>
</section>
<section id="sat-layer-module">
<h3>SAT Layer Module<a class="headerlink" href="#sat-layer-module" title="Link to this heading"></a></h3>
<dl class="expert-option simple" id="lbl-option-minisat-dump-dimacs">
<dt><code class="docutils literal notranslate"><span class="pre">minisat-dump-dimacs</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>instead of solving minisat dumps the asserted clauses in Dimacs format</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-minisat-simplification">
<dt><code class="docutils literal notranslate"><span class="pre">minisat-simplification</span></code> [<code class="docutils literal notranslate"><span class="pre">all</span> <span class="pre">|</span> <span class="pre">clause-elim</span> <span class="pre">|</span> <span class="pre">none</span></code>, default <code class="docutils literal notranslate"><span class="pre">all</span></code>]</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>Simplifications to be performed by Minisat.</p>
<p>Modes for Minisat simplifications.</p>
<dl class="field-list simple">
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">all</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>Variable and clause elimination, plus other simplifications.</p>
</dd>
<dt class="field-even"><code class="docutils literal notranslate"><span class="pre">clause-elim</span></code><span class="colon">:</span></dt>
<dd class="field-even"><p>Caluse elimination and other simplifications, except variable elimination.</p>
</dd>
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">none</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>No simplifications.</p>
</dd>
</dl>
</dd>
</dl>
<dl id="lbl-option-preregister-mode">
<dt><code class="docutils literal notranslate"><span class="pre">preregister-mode</span></code> [<code class="docutils literal notranslate"><span class="pre">eager</span> <span class="pre">|</span> <span class="pre">lazy</span></code>, default <code class="docutils literal notranslate"><span class="pre">eager</span></code>]</dt><dd><p>Modes for when to preregister literals.</p>
<p>Modes for when to preregister literals.</p>
<dl class="field-list simple">
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">eager</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>Preregister literals when they are registered as literals in the SAT solver.</p>
</dd>
<dt class="field-even"><code class="docutils literal notranslate"><span class="pre">lazy</span></code><span class="colon">:</span></dt>
<dd class="field-even"><p>Preregister literals when they are asserted by the SAT solver.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-random-freq">
<dt><code class="docutils literal notranslate"><span class="pre">random-freq</span> <span class="pre">|</span> <span class="pre">random-frequency</span></code> [type <code class="docutils literal notranslate"><span class="pre">double</span></code>, <code class="docutils literal notranslate"><span class="pre">0.0</span> <span class="pre">&lt;=</span> <span class="pre">P</span> <span class="pre">&lt;=</span> <span class="pre">1.0</span></code>, default <code class="docutils literal notranslate"><span class="pre">0.0</span></code>]</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>sets the frequency of random decisions in the sat solver (P=0.0 by default)</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-restart-int-base">
<dt><code class="docutils literal notranslate"><span class="pre">restart-int-base</span></code> [type <code class="docutils literal notranslate"><span class="pre">uint64_t</span></code>, default <code class="docutils literal notranslate"><span class="pre">25</span></code>]</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>sets the base restart interval for the sat solver (N=25 by default)</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-restart-int-inc">
<dt><code class="docutils literal notranslate"><span class="pre">restart-int-inc</span></code> [type <code class="docutils literal notranslate"><span class="pre">double</span></code>, <code class="docutils literal notranslate"><span class="pre">0.0</span> <span class="pre">&lt;=</span> <span class="pre">F</span></code>, default <code class="docutils literal notranslate"><span class="pre">3.0</span></code>]</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>sets the restart interval increase factor for the sat solver (F=3.0 by default)</p>
</dd>
</dl>
<dl class="simple" id="lbl-option-sat-random-seed">
<dt><code class="docutils literal notranslate"><span class="pre">sat-random-seed</span></code> [type <code class="docutils literal notranslate"><span class="pre">uint64_t</span></code>, default <code class="docutils literal notranslate"><span class="pre">0</span></code>]</dt><dd><p>sets the random seed for the sat solver</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-sat-solver">
<dt><code class="docutils literal notranslate"><span class="pre">sat-solver</span></code> [<code class="docutils literal notranslate"><span class="pre">minisat</span> <span class="pre">|</span> <span class="pre">cadical</span></code>, default <code class="docutils literal notranslate"><span class="pre">minisat</span></code>]</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>choose which sat solver to use, see –sat-solver=help</p>
<p>CDCL(T) SAT solver backend.</p>
</dd>
</dl>
</section>
<section id="quantifiers-module">
<h3>Quantifiers Module<a class="headerlink" href="#quantifiers-module" title="Link to this heading"></a></h3>
<dl class="simple" id="lbl-option-cbqi">
<dt><code class="docutils literal notranslate"><span class="pre">cbqi</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">true</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p>enable conflict-based quantifier instantiation</p>
</dd>
</dl>
<dl class="simple" id="lbl-option-cbqi-all-conflict">
<dt><code class="docutils literal notranslate"><span class="pre">cbqi-all-conflict</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p>add all available conflicting instances during conflict-based instantiation</p>
</dd>
</dl>
<dl id="lbl-option-cbqi-mode">
<dt><code class="docutils literal notranslate"><span class="pre">cbqi-mode</span></code> [<code class="docutils literal notranslate"><span class="pre">conflict</span> <span class="pre">|</span> <span class="pre">prop-eq</span></code>, default <code class="docutils literal notranslate"><span class="pre">prop-eq</span></code>]</dt><dd><p>what effort to apply conflict find mechanism</p>
<p>Quantifier conflict find modes.</p>
<dl class="field-list simple">
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">conflict</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>Apply QCF algorithm to find conflicts only.</p>
</dd>
<dt class="field-even"><code class="docutils literal notranslate"><span class="pre">prop-eq</span></code><span class="colon">:</span></dt>
<dd class="field-even"><p>Apply QCF algorithm to propagate equalities as well as conflicts.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-cbqi-skip-rd">
<dt><code class="docutils literal notranslate"><span class="pre">cbqi-skip-rd</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>optimization, skip instances based on possibly irrelevant portions of quantified formulas</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-cbqi-tconstraint">
<dt><code class="docutils literal notranslate"><span class="pre">cbqi-tconstraint</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>enable entailment checks for t-constraints in cbqi algorithm</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-cbqi-vo-exp">
<dt><code class="docutils literal notranslate"><span class="pre">cbqi-vo-exp</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>cbqi experimental variable ordering</p>
</dd>
</dl>
<dl id="lbl-option-cegis-sample">
<dt><code class="docutils literal notranslate"><span class="pre">cegis-sample</span></code> [<code class="docutils literal notranslate"><span class="pre">none</span> <span class="pre">|</span> <span class="pre">use</span> <span class="pre">|</span> <span class="pre">trust</span></code>, default <code class="docutils literal notranslate"><span class="pre">none</span></code>]</dt><dd><p>mode for using samples in the counterexample-guided inductive synthesis loop</p>
<p>Modes for sampling with counterexample-guided inductive synthesis (CEGIS).</p>
<dl class="field-list simple">
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">none</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>Do not use sampling with CEGIS.</p>
</dd>
<dt class="field-even"><code class="docutils literal notranslate"><span class="pre">use</span></code><span class="colon">:</span></dt>
<dd class="field-even"><p>Use sampling to accelerate CEGIS. This will rule out solutions for a conjecture when they are not satisfied by a sample point.</p>
</dd>
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">trust</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>Trust that when a solution for a conjecture is always true under sampling, then it is indeed a solution. Note this option may print out spurious solutions for synthesis conjectures.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="simple" id="lbl-option-cegqi">
<dt><code class="docutils literal notranslate"><span class="pre">cegqi</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p>turns on counterexample-based quantifier instantiation</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-cegqi-all">
<dt><code class="docutils literal notranslate"><span class="pre">cegqi-all</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>apply counterexample-based instantiation to all quantified formulas</p>
</dd>
</dl>
<dl class="simple" id="lbl-option-cegqi-bv">
<dt><code class="docutils literal notranslate"><span class="pre">cegqi-bv</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">true</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p>use word-level inversion approach for counterexample-guided quantifier instantiation for bit-vectors</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-cegqi-bv-ineq">
<dt><code class="docutils literal notranslate"><span class="pre">cegqi-bv-ineq</span></code> [<code class="docutils literal notranslate"><span class="pre">eq-slack</span> <span class="pre">|</span> <span class="pre">eq-boundary</span> <span class="pre">|</span> <span class="pre">keep</span></code>, default <code class="docutils literal notranslate"><span class="pre">eq-boundary</span></code>]</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>choose mode for handling bit-vector inequalities with counterexample-guided instantiation</p>
<p>Modes for handling bit-vector inequalities in counterexample-guided instantiation.</p>
<dl class="field-list simple">
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">eq-slack</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>Solve for the inequality using the slack value in the model, e.g., t &gt; s becomes t = s + ( t-s )^M.</p>
</dd>
<dt class="field-even"><code class="docutils literal notranslate"><span class="pre">eq-boundary</span></code><span class="colon">:</span></dt>
<dd class="field-even"><p>Solve for the boundary point of the inequality, e.g., t &gt; s becomes t = s+1.</p>
</dd>
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">keep</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>Solve for the inequality directly using side conditions for invertibility.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-cegqi-bv-interleave-value">
<dt><code class="docutils literal notranslate"><span class="pre">cegqi-bv-interleave-value</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>interleave model value instantiation with word-level inversion approach</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-cegqi-bv-linear">
<dt><code class="docutils literal notranslate"><span class="pre">cegqi-bv-linear</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">true</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>linearize adder chains for variables</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-cegqi-bv-rm-extract">
<dt><code class="docutils literal notranslate"><span class="pre">cegqi-bv-rm-extract</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">true</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>replaces extract terms with variables for counterexample-guided instantiation for bit-vectors</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-cegqi-bv-solve-nl">
<dt><code class="docutils literal notranslate"><span class="pre">cegqi-bv-solve-nl</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>try to solve non-linear bv literals using model value projections</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-cegqi-full">
<dt><code class="docutils literal notranslate"><span class="pre">cegqi-full</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>turns on full effort counterexample-based quantifier instantiation, which may resort to model-value instantiation</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-cegqi-inf-int">
<dt><code class="docutils literal notranslate"><span class="pre">cegqi-inf-int</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>use integer infinity for vts in counterexample-based quantifier instantiation</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-cegqi-inf-real">
<dt><code class="docutils literal notranslate"><span class="pre">cegqi-inf-real</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>use real infinity for vts in counterexample-based quantifier instantiation</p>
</dd>
</dl>
<dl class="simple" id="lbl-option-cegqi-innermost">
<dt><code class="docutils literal notranslate"><span class="pre">cegqi-innermost</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">true</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p>only process innermost quantified formulas in counterexample-based quantifier instantiation</p>
</dd>
</dl>
<dl class="simple" id="lbl-option-cegqi-midpoint">
<dt><code class="docutils literal notranslate"><span class="pre">cegqi-midpoint</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p>choose substitutions based on midpoints of lower and upper bounds for counterexample-based quantifier instantiation</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-cegqi-min-bounds">
<dt><code class="docutils literal notranslate"><span class="pre">cegqi-min-bounds</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>use minimally constrained lower/upper bound for counterexample-based quantifier instantiation</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-cegqi-multi-inst">
<dt><code class="docutils literal notranslate"><span class="pre">cegqi-multi-inst</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>when applicable, do multi instantiations per quantifier per round in counterexample-based quantifier instantiation</p>
</dd>
</dl>
<dl class="simple" id="lbl-option-cegqi-nested-qe">
<dt><code class="docutils literal notranslate"><span class="pre">cegqi-nested-qe</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p>process nested quantified formulas with quantifier elimination in counterexample-based quantifier instantiation</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-cegqi-nopt">
<dt><code class="docutils literal notranslate"><span class="pre">cegqi-nopt</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">true</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>non-optimal bounds for counterexample-based quantifier instantiation</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-cegqi-round-up-lia">
<dt><code class="docutils literal notranslate"><span class="pre">cegqi-round-up-lia</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>round up integer lower bounds in substitutions for counterexample-based quantifier instantiation</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-cond-var-split-quant">
<dt><code class="docutils literal notranslate"><span class="pre">cond-var-split-quant</span></code> [<code class="docutils literal notranslate"><span class="pre">off</span> <span class="pre">|</span> <span class="pre">on</span> <span class="pre">|</span> <span class="pre">agg</span></code>, default <code class="docutils literal notranslate"><span class="pre">on</span></code>]</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>split quantified formulas that lead to variable eliminations</p>
<p>Modes for splitting quantified formulas that lead to variable eliminations.</p>
<dl class="field-list simple">
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">off</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>Do not split quantified formulas.</p>
</dd>
<dt class="field-even"><code class="docutils literal notranslate"><span class="pre">on</span></code><span class="colon">:</span></dt>
<dd class="field-even"><p>Split quantified formulas that lead to variable eliminations.</p>
</dd>
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">agg</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>Aggressively split quantified formulas that lead to variable eliminations.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-conjecture-gen">
<dt><code class="docutils literal notranslate"><span class="pre">conjecture-gen</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>generate candidate conjectures for inductive proofs</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-conjecture-gen-gt-enum">
<dt><code class="docutils literal notranslate"><span class="pre">conjecture-gen-gt-enum</span></code> [type <code class="docutils literal notranslate"><span class="pre">int64_t</span></code>, default <code class="docutils literal notranslate"><span class="pre">50</span></code>]</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>number of ground terms to generate for model filtering</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-conjecture-gen-max-depth">
<dt><code class="docutils literal notranslate"><span class="pre">conjecture-gen-max-depth</span></code> [type <code class="docutils literal notranslate"><span class="pre">int64_t</span></code>, default <code class="docutils literal notranslate"><span class="pre">3</span></code>]</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>maximum depth of terms to consider for conjectures</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-conjecture-gen-per-round">
<dt><code class="docutils literal notranslate"><span class="pre">conjecture-gen-per-round</span></code> [type <code class="docutils literal notranslate"><span class="pre">int64_t</span></code>, default <code class="docutils literal notranslate"><span class="pre">1</span></code>]</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>number of conjectures to generate per instantiation round</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-cons-exp-triggers">
<dt><code class="docutils literal notranslate"><span class="pre">cons-exp-triggers</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>use constructor expansion for single constructor datatypes triggers</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-dt-stc-ind">
<dt><code class="docutils literal notranslate"><span class="pre">dt-stc-ind</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>apply strengthening for existential quantification over datatypes based on structural induction</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-dt-var-exp-quant">
<dt><code class="docutils literal notranslate"><span class="pre">dt-var-exp-quant</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">true</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>expand datatype variables bound to one constructor in quantifiers</p>
</dd>
</dl>
<dl class="simple" id="lbl-option-e-matching">
<dt><code class="docutils literal notranslate"><span class="pre">e-matching</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">true</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p>whether to do heuristic E-matching</p>
</dd>
</dl>
<dl class="simple" id="lbl-option-elim-taut-quant">
<dt><code class="docutils literal notranslate"><span class="pre">elim-taut-quant</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">true</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p>eliminate tautological disjuncts of quantified formulas</p>
</dd>
</dl>
<dl class="simple" id="lbl-option-enum-inst-interleave">
<dt><code class="docutils literal notranslate"><span class="pre">enum-inst-interleave</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p>interleave enumerative instantiation with other techniques</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-enum-inst-limit">
<dt><code class="docutils literal notranslate"><span class="pre">enum-inst-limit</span></code> [type <code class="docutils literal notranslate"><span class="pre">int64_t</span></code>, default <code class="docutils literal notranslate"><span class="pre">-1</span></code>]</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>maximum number of rounds of enumerative instantiation to apply (-1 means no limit)</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-enum-inst-rd">
<dt><code class="docutils literal notranslate"><span class="pre">enum-inst-rd</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">true</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>whether to use relevant domain first for enumerative instantiation strategy</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-enum-inst-stratify">
<dt><code class="docutils literal notranslate"><span class="pre">enum-inst-stratify</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>stratify effort levels in enumerative instantiation, which favors speed over fairness</p>
</dd>
</dl>
<dl class="simple" id="lbl-option-enum-inst-sum">
<dt><code class="docutils literal notranslate"><span class="pre">enum-inst-sum</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p>enumerating tuples of quantifiers by increasing the sum of indices, rather than the maximum</p>
</dd>
</dl>
<dl class="simple" id="lbl-option-ext-rewrite-quant">
<dt><code class="docutils literal notranslate"><span class="pre">ext-rewrite-quant</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p>apply extended rewriting to bodies of quantified formulas</p>
</dd>
</dl>
<dl class="simple" id="lbl-option-finite-model-find">
<dt><code class="docutils literal notranslate"><span class="pre">finite-model-find</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p>use finite model finding heuristic for quantifier instantiation</p>
</dd>
</dl>
<dl class="simple" id="lbl-option-fmf-bound">
<dt><code class="docutils literal notranslate"><span class="pre">fmf-bound</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p>finite model finding on bounded quantification</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-fmf-bound-blast">
<dt><code class="docutils literal notranslate"><span class="pre">fmf-bound-blast</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>send all instantiations for bounded ranges in a single round</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-fmf-bound-lazy">
<dt><code class="docutils literal notranslate"><span class="pre">fmf-bound-lazy</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>enforce bounds for bounded quantification lazily via use of proxy variables</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-fmf-fun">
<dt><code class="docutils literal notranslate"><span class="pre">fmf-fun</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>find models for recursively defined functions, assumes functions are admissible</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-fmf-fun-rlv">
<dt><code class="docutils literal notranslate"><span class="pre">fmf-fun-rlv</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>find models for recursively defined functions, assumes functions are admissible, allows empty type when function is irrelevant</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-fmf-mbqi">
<dt><code class="docutils literal notranslate"><span class="pre">fmf-mbqi</span></code> [<code class="docutils literal notranslate"><span class="pre">none</span> <span class="pre">|</span> <span class="pre">fmc</span> <span class="pre">|</span> <span class="pre">trust</span></code>, default <code class="docutils literal notranslate"><span class="pre">fmc</span></code>]</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>choose mode for model-based quantifier instantiation</p>
<p>Model-based quantifier instantiation modes.</p>
<dl class="field-list simple">
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">none</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>Disable model-based quantifier instantiation.</p>
</dd>
<dt class="field-even"><code class="docutils literal notranslate"><span class="pre">fmc</span></code><span class="colon">:</span></dt>
<dd class="field-even"><p>Use algorithm from Section 5.4.2 of thesis Finite Model Finding in Satisfiability Modulo Theories.</p>
</dd>
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">trust</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>Do not instantiate quantified formulas (incomplete technique).</p>
</dd>
</dl>
</dd>
</dl>
<dl class="simple" id="lbl-option-fmf-type-completion-thresh">
<dt><code class="docutils literal notranslate"><span class="pre">fmf-type-completion-thresh</span></code> [type <code class="docutils literal notranslate"><span class="pre">int64_t</span></code>, default <code class="docutils literal notranslate"><span class="pre">1000</span></code>]</dt><dd><p>the maximum cardinality of an interpreted type for which exhaustive enumeration in finite model finding is attempted</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-full-sygus-verify">
<dt><code class="docutils literal notranslate"><span class="pre">full-sygus-verify</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>resort to full effort techniques instead of answering unknown when checking sygus candidates</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-global-negate">
<dt><code class="docutils literal notranslate"><span class="pre">global-negate</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>do global negation of input formula</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-ho-elim">
<dt><code class="docutils literal notranslate"><span class="pre">ho-elim</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>eagerly eliminate higher-order constraints</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-ho-elim-store-ax">
<dt><code class="docutils literal notranslate"><span class="pre">ho-elim-store-ax</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">true</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>use store axiom during ho-elim</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-ho-matching">
<dt><code class="docutils literal notranslate"><span class="pre">ho-matching</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">true</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>do higher-order matching algorithm for triggers with variable operators</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-ho-merge-term-db">
<dt><code class="docutils literal notranslate"><span class="pre">ho-merge-term-db</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">true</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>merge term indices modulo equality</p>
</dd>
</dl>
<dl id="lbl-option-ieval">
<dt><code class="docutils literal notranslate"><span class="pre">ieval</span></code> [<code class="docutils literal notranslate"><span class="pre">off</span> <span class="pre">|</span> <span class="pre">use</span> <span class="pre">|</span> <span class="pre">use-learn</span></code>, default <code class="docutils literal notranslate"><span class="pre">use</span></code>]</dt><dd><p>mode for using instantiation evaluation</p>
<p>Mode for using instantiation evaluation.</p>
<dl class="field-list simple">
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">off</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>Do not use instantiation evaluation.</p>
</dd>
<dt class="field-even"><code class="docutils literal notranslate"><span class="pre">use</span></code><span class="colon">:</span></dt>
<dd class="field-even"><p>Use instantiation evaluation.</p>
</dd>
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">use-learn</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>Use instantiation evaluation, and generalize learning.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-increment-triggers">
<dt><code class="docutils literal notranslate"><span class="pre">increment-triggers</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">true</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>generate additional triggers as needed during search</p>
</dd>
</dl>
<dl class="simple" id="lbl-option-inst-local">
<dt><code class="docutils literal notranslate"><span class="pre">inst-local</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p>Instantiations are local to the SAT context</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-inst-max-level">
<dt><code class="docutils literal notranslate"><span class="pre">inst-max-level</span></code> [type <code class="docutils literal notranslate"><span class="pre">int64_t</span></code>, default <code class="docutils literal notranslate"><span class="pre">-1</span></code>]</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>maximum inst level of terms used to instantiate quantified formulas with (-1 == no limit, default)</p>
</dd>
</dl>
<dl class="simple" id="lbl-option-inst-max-rounds">
<dt><code class="docutils literal notranslate"><span class="pre">inst-max-rounds</span></code> [type <code class="docutils literal notranslate"><span class="pre">int64_t</span></code>, default <code class="docutils literal notranslate"><span class="pre">-1</span></code>]</dt><dd><p>maximum number of instantiation rounds (-1 == no limit, default)</p>
</dd>
</dl>
<dl class="simple" id="lbl-option-inst-no-entail">
<dt><code class="docutils literal notranslate"><span class="pre">inst-no-entail</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">true</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p>do not consider instances of quantified formulas that are currently entailed</p>
</dd>
</dl>
<dl id="lbl-option-inst-when">
<dt><code class="docutils literal notranslate"><span class="pre">inst-when</span></code> [<code class="docutils literal notranslate"><span class="pre">full</span> <span class="pre">|</span> <span class="pre">full-delay</span> <span class="pre">|</span> <span class="pre">full-last-call</span> <span class="pre">|</span> <span class="pre">full-delay-last-call</span> <span class="pre">|</span> <span class="pre">last-call</span></code>, default <code class="docutils literal notranslate"><span class="pre">full-last-call</span></code>]</dt><dd><p>when to apply instantiation</p>
<p>Instantiation modes.</p>
<dl class="field-list simple">
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">full</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>Run instantiation round at full effort, before theory combination.</p>
</dd>
<dt class="field-even"><code class="docutils literal notranslate"><span class="pre">full-delay</span></code><span class="colon">:</span></dt>
<dd class="field-even"><p>Run instantiation round at full effort, before theory combination, after all other theories have finished.</p>
</dd>
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">full-last-call</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>Alternate running instantiation rounds at full effort and last call.  In other words, interleave instantiation and theory combination.</p>
</dd>
<dt class="field-even"><code class="docutils literal notranslate"><span class="pre">full-delay-last-call</span></code><span class="colon">:</span></dt>
<dd class="field-even"><p>Alternate running instantiation rounds at full effort after all other theories have finished, and last call.</p>
</dd>
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">last-call</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>Run instantiation at last call effort, after theory combination and and theories report sat.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-inst-when-phase">
<dt><code class="docutils literal notranslate"><span class="pre">inst-when-phase</span></code> [type <code class="docutils literal notranslate"><span class="pre">int64_t</span></code>, default <code class="docutils literal notranslate"><span class="pre">2</span></code>]</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>instantiation rounds quantifiers takes (&gt;=1) before allowing theory combination to happen</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-int-wf-ind">
<dt><code class="docutils literal notranslate"><span class="pre">int-wf-ind</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>apply strengthening for integers based on well-founded induction</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-ite-dtt-split-quant">
<dt><code class="docutils literal notranslate"><span class="pre">ite-dtt-split-quant</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>split ites with dt testers as conditions</p>
</dd>
</dl>
<dl id="lbl-option-ite-lift-quant">
<dt><code class="docutils literal notranslate"><span class="pre">ite-lift-quant</span></code> [<code class="docutils literal notranslate"><span class="pre">none</span> <span class="pre">|</span> <span class="pre">simple</span> <span class="pre">|</span> <span class="pre">all</span></code>, default <code class="docutils literal notranslate"><span class="pre">simple</span></code>]</dt><dd><p>ite lifting mode for quantified formulas</p>
<p>ITE lifting modes for quantified formulas.</p>
<dl class="field-list simple">
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">none</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>Do not lift if-then-else in quantified formulas.</p>
</dd>
<dt class="field-even"><code class="docutils literal notranslate"><span class="pre">simple</span></code><span class="colon">:</span></dt>
<dd class="field-even"><p>Lift if-then-else in quantified formulas if results in smaller term size.</p>
</dd>
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">all</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>Lift if-then-else in quantified formulas.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-leibniz-elim">
<dt><code class="docutils literal notranslate"><span class="pre">leibniz-elim</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>Leibniz equality elimination for quantified formulas</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-literal-matching">
<dt><code class="docutils literal notranslate"><span class="pre">literal-matching</span></code> [<code class="docutils literal notranslate"><span class="pre">none</span> <span class="pre">|</span> <span class="pre">use</span> <span class="pre">|</span> <span class="pre">agg-predicate</span> <span class="pre">|</span> <span class="pre">agg</span></code>, default <code class="docutils literal notranslate"><span class="pre">use</span></code>]</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>choose literal matching mode</p>
<p>Literal match modes.</p>
<dl class="field-list simple">
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">none</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>Do not use literal matching.</p>
</dd>
<dt class="field-even"><code class="docutils literal notranslate"><span class="pre">use</span></code><span class="colon">:</span></dt>
<dd class="field-even"><p>Consider phase requirements of triggers conservatively. For example, the trigger P( x ) in forall( x ). ( P( x ) V ~Q( x ) ) will not be matched with terms in the equivalence class of true, and likewise Q( x ) will not be matched terms in the equivalence class of false. Extends to equality.</p>
</dd>
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">agg-predicate</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>Consider phase requirements aggressively for predicates. In the above example, only match P( x ) with terms that are in the equivalence class of false.</p>
</dd>
<dt class="field-even"><code class="docutils literal notranslate"><span class="pre">agg</span></code><span class="colon">:</span></dt>
<dd class="field-even"><p>Consider the phase requirements aggressively for all triggers.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="simple" id="lbl-option-macros-quant">
<dt><code class="docutils literal notranslate"><span class="pre">macros-quant</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p>perform quantifiers macro expansion</p>
</dd>
</dl>
<dl id="lbl-option-macros-quant-mode">
<dt><code class="docutils literal notranslate"><span class="pre">macros-quant-mode</span></code> [<code class="docutils literal notranslate"><span class="pre">all</span> <span class="pre">|</span> <span class="pre">ground</span> <span class="pre">|</span> <span class="pre">ground-uf</span></code>, default <code class="docutils literal notranslate"><span class="pre">ground-uf</span></code>]</dt><dd><p>mode for quantifiers macro expansion</p>
<p>Modes for quantifiers macro expansion.</p>
<dl class="field-list simple">
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">all</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>Infer definitions for functions, including those containing quantified formulas.</p>
</dd>
<dt class="field-even"><code class="docutils literal notranslate"><span class="pre">ground</span></code><span class="colon">:</span></dt>
<dd class="field-even"><p>Only infer ground definitions for functions.</p>
</dd>
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">ground-uf</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>Only infer ground definitions for functions that result in triggers for all free variables.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="simple" id="lbl-option-mbqi">
<dt><code class="docutils literal notranslate"><span class="pre">mbqi</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p>use model-based quantifier instantiation</p>
</dd>
</dl>
<dl class="simple" id="lbl-option-mbqi-check-timeout">
<dt><code class="docutils literal notranslate"><span class="pre">mbqi-check-timeout</span></code> [type <code class="docutils literal notranslate"><span class="pre">uint64_t</span></code>, default <code class="docutils literal notranslate"><span class="pre">500</span></code>]</dt><dd><p>timeout (in milliseconds) for verifying subcalls for model-based instantiation (0 == no limit)</p>
</dd>
</dl>
<dl class="simple" id="lbl-option-mbqi-enum">
<dt><code class="docutils literal notranslate"><span class="pre">mbqi-enum</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p>use fast enumeration to augment instantiations from MBQI</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-mbqi-enum-ext-vars-grammar">
<dt><code class="docutils literal notranslate"><span class="pre">mbqi-enum-ext-vars-grammar</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">true</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>include variables defined in terms of others in grammars for fast enumerative mbqi</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-mbqi-enum-free-syms-grammar">
<dt><code class="docutils literal notranslate"><span class="pre">mbqi-enum-free-syms-grammar</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">true</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>include free symbols from the body of the quantified formula in grammars for fast enumerative mbqi</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-mbqi-enum-global-syms-grammar">
<dt><code class="docutils literal notranslate"><span class="pre">mbqi-enum-global-syms-grammar</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>include global symbols from all available assertions in grammars for fast enumerative mbqi</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-mbqi-interleave">
<dt><code class="docutils literal notranslate"><span class="pre">mbqi-interleave</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>interleave model-based quantifier instantiation with other techniques</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-mbqi-nested-check">
<dt><code class="docutils literal notranslate"><span class="pre">mbqi-nested-check</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">true</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>check nested quantified formulas in MBQI</p>
</dd>
</dl>
<dl class="simple" id="lbl-option-mbqi-one-inst-per-round">
<dt><code class="docutils literal notranslate"><span class="pre">mbqi-one-inst-per-round</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p>only add one instantiation per quantifier per round for mbqi</p>
</dd>
</dl>
<dl id="lbl-option-miniscope-quant">
<dt><code class="docutils literal notranslate"><span class="pre">miniscope-quant</span></code> [<code class="docutils literal notranslate"><span class="pre">off</span> <span class="pre">|</span> <span class="pre">conj</span> <span class="pre">|</span> <span class="pre">fv</span> <span class="pre">|</span> <span class="pre">conj-and-fv</span> <span class="pre">|</span> <span class="pre">agg</span></code>, default <code class="docutils literal notranslate"><span class="pre">conj-and-fv</span></code>]</dt><dd><p>miniscope mode for quantified formulas</p>
<p>Miniscope quantifiers modes.</p>
<dl class="field-list simple">
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">off</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>Do not miniscope quantifiers.</p>
</dd>
<dt class="field-even"><code class="docutils literal notranslate"><span class="pre">conj</span></code><span class="colon">:</span></dt>
<dd class="field-even"><p>Use miniscoping of conjunctions only.</p>
</dd>
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">fv</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>Use free variable miniscoping only.</p>
</dd>
<dt class="field-even"><code class="docutils literal notranslate"><span class="pre">conj-and-fv</span></code><span class="colon">:</span></dt>
<dd class="field-even"><p>Enable both conjunction and free variable miniscoping.</p>
</dd>
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">agg</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>Enable aggressive miniscope, which further may rewrite quantified formulas into a form where miniscoping is possible.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="simple" id="lbl-option-miniscope-quant-user">
<dt><code class="docutils literal notranslate"><span class="pre">miniscope-quant-user</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p>miniscope quantified formulas with user patterns</p>
</dd>
</dl>
<dl class="simple" id="lbl-option-multi-trigger-cache">
<dt><code class="docutils literal notranslate"><span class="pre">multi-trigger-cache</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p>caching version of multi triggers</p>
</dd>
</dl>
<dl class="simple" id="lbl-option-multi-trigger-linear">
<dt><code class="docutils literal notranslate"><span class="pre">multi-trigger-linear</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">true</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p>implementation of multi triggers where maximum number of instantiations is linear wrt number of ground terms</p>
</dd>
</dl>
<dl class="simple" id="lbl-option-multi-trigger-priority">
<dt><code class="docutils literal notranslate"><span class="pre">multi-trigger-priority</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p>only try multi triggers if single triggers give no instantiations</p>
</dd>
</dl>
<dl class="simple" id="lbl-option-multi-trigger-when-single">
<dt><code class="docutils literal notranslate"><span class="pre">multi-trigger-when-single</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p>select multi triggers when single triggers exist</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-oracles">
<dt><code class="docutils literal notranslate"><span class="pre">oracles</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>Enable interface to external oracles</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-partial-triggers">
<dt><code class="docutils literal notranslate"><span class="pre">partial-triggers</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>use triggers that do not contain all free variables</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-pool-inst">
<dt><code class="docutils literal notranslate"><span class="pre">pool-inst</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">true</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>pool-based instantiation: instantiate with ground terms occurring in user-specified pools</p>
</dd>
</dl>
<dl id="lbl-option-pre-skolem-quant">
<dt><code class="docutils literal notranslate"><span class="pre">pre-skolem-quant</span></code> [<code class="docutils literal notranslate"><span class="pre">off</span> <span class="pre">|</span> <span class="pre">on</span> <span class="pre">|</span> <span class="pre">agg</span></code>, default <code class="docutils literal notranslate"><span class="pre">off</span></code>]</dt><dd><p>modes to apply skolemization eagerly to bodies of quantified formulas</p>
<p>Modes to apply skolemization eagerly to bodies of quantified formulas.</p>
<dl class="field-list simple">
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">off</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>Do not apply Skolemization eagerly.</p>
</dd>
<dt class="field-even"><code class="docutils literal notranslate"><span class="pre">on</span></code><span class="colon">:</span></dt>
<dd class="field-even"><p>Apply Skolemization eagerly to top-level (negatively asserted) quantified formulas.</p>
</dd>
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">agg</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>Apply Skolemization eagerly and aggressively during preprocessing.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-pre-skolem-quant-nested">
<dt><code class="docutils literal notranslate"><span class="pre">pre-skolem-quant-nested</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">true</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>apply skolemization to nested quantified formulas</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-prenex-quant">
<dt><code class="docutils literal notranslate"><span class="pre">prenex-quant</span></code> [<code class="docutils literal notranslate"><span class="pre">none</span> <span class="pre">|</span> <span class="pre">simple</span> <span class="pre">|</span> <span class="pre">norm</span></code>, default <code class="docutils literal notranslate"><span class="pre">simple</span></code>]</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>prenex mode for quantified formulas</p>
<p>Prenex quantifiers modes.</p>
<dl class="field-list simple">
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">none</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>Do not prenex nested quantifiers.</p>
</dd>
<dt class="field-even"><code class="docutils literal notranslate"><span class="pre">simple</span></code><span class="colon">:</span></dt>
<dd class="field-even"><p>Do simple prenexing of same sign quantifiers.</p>
</dd>
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">norm</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>Prenex to prenex normal form.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="simple" id="lbl-option-prenex-quant-user">
<dt><code class="docutils literal notranslate"><span class="pre">prenex-quant-user</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p>prenex quantified formulas with user patterns</p>
</dd>
</dl>
<dl class="simple" id="lbl-option-print-inst-full">
<dt><code class="docutils literal notranslate"><span class="pre">print-inst-full</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">true</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p>print instantiations for formulas that do not have given identifiers</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-purify-triggers">
<dt><code class="docutils literal notranslate"><span class="pre">purify-triggers</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>purify triggers, e.g. f( x+1 ) becomes f( y ), x mapsto y-1</p>
</dd>
</dl>
<dl class="simple" id="lbl-option-quant-alpha-equiv">
<dt><code class="docutils literal notranslate"><span class="pre">quant-alpha-equiv</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">true</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p>infer alpha equivalence between quantified formulas</p>
</dd>
</dl>
<dl id="lbl-option-quant-dsplit">
<dt><code class="docutils literal notranslate"><span class="pre">quant-dsplit</span></code> [<code class="docutils literal notranslate"><span class="pre">none</span> <span class="pre">|</span> <span class="pre">default</span> <span class="pre">|</span> <span class="pre">agg</span></code>, default <code class="docutils literal notranslate"><span class="pre">default</span></code>]</dt><dd><p>mode for dynamic quantifiers splitting</p>
<p>Modes for quantifiers splitting.</p>
<dl class="field-list simple">
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">none</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>Never split quantified formulas.</p>
</dd>
<dt class="field-even"><code class="docutils literal notranslate"><span class="pre">default</span></code><span class="colon">:</span></dt>
<dd class="field-even"><p>Split quantified formulas over some finite datatypes when finite model finding is enabled.</p>
</dd>
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">agg</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>Aggressively split quantified formulas.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-quant-fun-wd">
<dt><code class="docutils literal notranslate"><span class="pre">quant-fun-wd</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>assume that function defined by quantifiers are well defined</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-quant-ind">
<dt><code class="docutils literal notranslate"><span class="pre">quant-ind</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>use all available techniques for inductive reasoning</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-quant-rep-mode">
<dt><code class="docutils literal notranslate"><span class="pre">quant-rep-mode</span></code> [<code class="docutils literal notranslate"><span class="pre">ee</span> <span class="pre">|</span> <span class="pre">first</span> <span class="pre">|</span> <span class="pre">depth</span></code>, default <code class="docutils literal notranslate"><span class="pre">first</span></code>]</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>selection mode for representatives in quantifiers engine</p>
<p>Modes for quantifiers representative selection.</p>
<dl class="field-list simple">
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">ee</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>Let equality engine choose representatives.</p>
</dd>
<dt class="field-even"><code class="docutils literal notranslate"><span class="pre">first</span></code><span class="colon">:</span></dt>
<dd class="field-even"><p>Choose terms that appear first.</p>
</dd>
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">depth</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>Choose terms that are of minimal depth.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-register-quant-body-terms">
<dt><code class="docutils literal notranslate"><span class="pre">register-quant-body-terms</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>consider ground terms within bodies of quantified formulas for matching</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-relational-triggers">
<dt><code class="docutils literal notranslate"><span class="pre">relational-triggers</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>choose relational triggers such as x = f(y), x &gt;= f(y)</p>
</dd>
</dl>
<dl class="simple" id="lbl-option-relevant-triggers">
<dt><code class="docutils literal notranslate"><span class="pre">relevant-triggers</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p>prefer triggers that are more relevant based on SInE style analysis</p>
</dd>
</dl>
<dl class="simple" id="lbl-option-sub-cbqi">
<dt><code class="docutils literal notranslate"><span class="pre">sub-cbqi</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p>Enable conflict-based instantiation subsolver strategy</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-sub-cbqi-timeout">
<dt><code class="docutils literal notranslate"><span class="pre">sub-cbqi-timeout</span></code> [type <code class="docutils literal notranslate"><span class="pre">uint64_t</span></code>, default <code class="docutils literal notranslate"><span class="pre">0</span></code>]</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>Timeout (in milliseconds) for subsolver calls for sub-cbqi</p>
</dd>
</dl>
<dl class="simple" id="lbl-option-sygus">
<dt><code class="docutils literal notranslate"><span class="pre">sygus</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p>support SyGuS commands</p>
</dd>
</dl>
<dl class="simple" id="lbl-option-sygus-add-const-grammar">
<dt><code class="docutils literal notranslate"><span class="pre">sygus-add-const-grammar</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">true</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p>statically add constants appearing in conjecture to grammars</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-sygus-arg-relevant">
<dt><code class="docutils literal notranslate"><span class="pre">sygus-arg-relevant</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>static inference techniques for computing whether arguments of functions-to-synthesize are relevant</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-sygus-auto-unfold">
<dt><code class="docutils literal notranslate"><span class="pre">sygus-auto-unfold</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">true</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>enable approach which automatically unfolds transition systems for directly solving invariant synthesis problems</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-sygus-bool-ite-return-const">
<dt><code class="docutils literal notranslate"><span class="pre">sygus-bool-ite-return-const</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">true</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>Only use Boolean constants for return values in unification-based function synthesis</p>
</dd>
</dl>
<dl class="simple" id="lbl-option-sygus-core-connective">
<dt><code class="docutils literal notranslate"><span class="pre">sygus-core-connective</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">true</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p>use unsat core analysis to construct Boolean connective to sygus conjectures</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-sygus-crepair-abort">
<dt><code class="docutils literal notranslate"><span class="pre">sygus-crepair-abort</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>abort if constant repair techniques are not applicable</p>
</dd>
</dl>
<dl id="lbl-option-sygus-enum">
<dt><code class="docutils literal notranslate"><span class="pre">sygus-enum</span></code> [<code class="docutils literal notranslate"><span class="pre">smart</span> <span class="pre">|</span> <span class="pre">fast</span> <span class="pre">|</span> <span class="pre">random</span> <span class="pre">|</span> <span class="pre">var-agnostic</span> <span class="pre">|</span> <span class="pre">auto</span></code>, default <code class="docutils literal notranslate"><span class="pre">auto</span></code>]</dt><dd><p>mode for sygus enumeration</p>
<p>Modes for sygus enumeration.</p>
<dl class="field-list simple">
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">smart</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>Use smart enumeration based on datatype constraints.</p>
</dd>
<dt class="field-even"><code class="docutils literal notranslate"><span class="pre">fast</span></code><span class="colon">:</span></dt>
<dd class="field-even"><p>Use optimized enumerator for sygus enumeration.</p>
</dd>
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">random</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>Use basic random enumerator for sygus enumeration.</p>
</dd>
<dt class="field-even"><code class="docutils literal notranslate"><span class="pre">var-agnostic</span></code><span class="colon">:</span></dt>
<dd class="field-even"><p>Use sygus solver to enumerate terms that are agnostic to variables.</p>
</dd>
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">auto</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>Internally decide the best policy for each enumerator.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-sygus-enum-fast-num-consts">
<dt><code class="docutils literal notranslate"><span class="pre">sygus-enum-fast-num-consts</span></code> [type <code class="docutils literal notranslate"><span class="pre">uint64_t</span></code>, default <code class="docutils literal notranslate"><span class="pre">5</span></code>]</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>the branching factor for the number of interpreted constants to consider for each size when using –sygus-enum=fast</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-sygus-enum-random-p">
<dt><code class="docutils literal notranslate"><span class="pre">sygus-enum-random-p</span></code> [type <code class="docutils literal notranslate"><span class="pre">double</span></code>, <code class="docutils literal notranslate"><span class="pre">0.0</span> <span class="pre">&lt;=</span> <span class="pre">P</span> <span class="pre">&lt;=</span> <span class="pre">1.0</span></code>, default <code class="docutils literal notranslate"><span class="pre">0.5</span></code>]</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>the parameter of the geometric distribution used to determine the size of terms generated by –sygus-enum=random</p>
</dd>
</dl>
<dl id="lbl-option-sygus-eval-unfold">
<dt><code class="docutils literal notranslate"><span class="pre">sygus-eval-unfold</span></code> [<code class="docutils literal notranslate"><span class="pre">none</span> <span class="pre">|</span> <span class="pre">single</span> <span class="pre">|</span> <span class="pre">single-bool</span> <span class="pre">|</span> <span class="pre">multi</span></code>, default <code class="docutils literal notranslate"><span class="pre">single-bool</span></code>]</dt><dd><p>modes for sygus evaluation unfolding</p>
<p>Modes for sygus evaluation unfolding.</p>
<dl class="field-list simple">
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">none</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>Do not use sygus evaluation unfolding.</p>
</dd>
<dt class="field-even"><code class="docutils literal notranslate"><span class="pre">single</span></code><span class="colon">:</span></dt>
<dd class="field-even"><p>Do single-step unfolding for all evaluation functions.</p>
</dd>
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">single-bool</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>Do single-step unfolding for Boolean functions and ITEs, and multi-step unfolding for all others.</p>
</dd>
<dt class="field-even"><code class="docutils literal notranslate"><span class="pre">multi</span></code><span class="colon">:</span></dt>
<dd class="field-even"><p>Do multi-step unfolding for all evaluation functions.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-sygus-expr-miner-check-timeout">
<dt><code class="docutils literal notranslate"><span class="pre">sygus-expr-miner-check-timeout</span></code> [type <code class="docutils literal notranslate"><span class="pre">uint64_t</span></code>, default <code class="docutils literal notranslate"><span class="pre">0</span></code>]</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>timeout (in milliseconds) for satisfiability checks in expression miners</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-sygus-filter-sol">
<dt><code class="docutils literal notranslate"><span class="pre">sygus-filter-sol</span></code> [<code class="docutils literal notranslate"><span class="pre">none</span> <span class="pre">|</span> <span class="pre">strong</span> <span class="pre">|</span> <span class="pre">weak</span></code>, default <code class="docutils literal notranslate"><span class="pre">none</span></code>]</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>mode for filtering sygus solutions</p>
<p>Modes for filtering sygus solutions.</p>
<dl class="field-list simple">
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">none</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>Do not filter sygus solutions.</p>
</dd>
<dt class="field-even"><code class="docutils literal notranslate"><span class="pre">strong</span></code><span class="colon">:</span></dt>
<dd class="field-even"><p>Filter solutions that are logically stronger than others.</p>
</dd>
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">weak</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>Filter solutions that are logically weaker than others.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-sygus-filter-sol-rev">
<dt><code class="docutils literal notranslate"><span class="pre">sygus-filter-sol-rev</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>compute backwards filtering to compute whether previous solutions are filtered based on later ones</p>
</dd>
</dl>
<dl id="lbl-option-sygus-grammar-cons">
<dt><code class="docutils literal notranslate"><span class="pre">sygus-grammar-cons</span></code> [<code class="docutils literal notranslate"><span class="pre">simple</span> <span class="pre">|</span> <span class="pre">any-const</span> <span class="pre">|</span> <span class="pre">any-term</span> <span class="pre">|</span> <span class="pre">any-term-concise</span></code>, default <code class="docutils literal notranslate"><span class="pre">simple</span></code>]</dt><dd><p>mode for SyGuS grammar construction</p>
<p>Modes for default SyGuS grammars.</p>
<dl class="field-list simple">
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">simple</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>Use simple grammar construction (no symbolic terms or constants).</p>
</dd>
<dt class="field-even"><code class="docutils literal notranslate"><span class="pre">any-const</span></code><span class="colon">:</span></dt>
<dd class="field-even"><p>Use symoblic constant constructors.</p>
</dd>
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">any-term</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>When applicable, use constructors corresponding to any symbolic term. This option enables a sum-of-monomials grammar for arithmetic. For all other types, it enables symbolic constant constructors.</p>
</dd>
<dt class="field-even"><code class="docutils literal notranslate"><span class="pre">any-term-concise</span></code><span class="colon">:</span></dt>
<dd class="field-even"><p>When applicable, use constructors corresponding to any symbolic term, favoring conciseness over generality. This option is equivalent to any-term but enables a polynomial grammar for arithmetic when not in a combined theory.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-sygus-grammar-ho-partial">
<dt><code class="docutils literal notranslate"><span class="pre">sygus-grammar-ho-partial</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>add partial function applications to the grammar</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-sygus-grammar-norm">
<dt><code class="docutils literal notranslate"><span class="pre">sygus-grammar-norm</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>statically normalize sygus grammars based on flattening (linearization)</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-sygus-grammar-use-disj">
<dt><code class="docutils literal notranslate"><span class="pre">sygus-grammar-use-disj</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">true</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>use disjunctions in internally generated grammars. this is set to false when solving abduction queries.</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-sygus-inference">
<dt><code class="docutils literal notranslate"><span class="pre">sygus-inference</span></code> [<code class="docutils literal notranslate"><span class="pre">off</span> <span class="pre">|</span> <span class="pre">try</span> <span class="pre">|</span> <span class="pre">on</span></code>, default <code class="docutils literal notranslate"><span class="pre">off</span></code>]</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>mode for preprocessing arbitrary inputs to sygus conjectures</p>
<p>Modes  for preprocessing arbitrary inputs to sygus conjectures.</p>
<dl class="field-list simple">
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">off</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>Do not use sygus inference techniques.</p>
</dd>
<dt class="field-even"><code class="docutils literal notranslate"><span class="pre">try</span></code><span class="colon">:</span></dt>
<dd class="field-even"><p>Try to use sygus inference techniques but resort to ordinary SMT solving if it does not apply.</p>
</dd>
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">on</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>Try to sygus inference and abort if it does not apply.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="simple" id="lbl-option-sygus-inst">
<dt><code class="docutils literal notranslate"><span class="pre">sygus-inst</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p>Enable SyGuS instantiation quantifiers module</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-sygus-inst-mode">
<dt><code class="docutils literal notranslate"><span class="pre">sygus-inst-mode</span></code> [<code class="docutils literal notranslate"><span class="pre">priority-inst</span> <span class="pre">|</span> <span class="pre">priority-eval</span> <span class="pre">|</span> <span class="pre">interleave</span></code>, default <code class="docutils literal notranslate"><span class="pre">priority-inst</span></code>]</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>select instantiation lemma mode</p>
<p>SyGuS instantiation lemma modes.</p>
<dl class="field-list simple">
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">priority-inst</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>add instantiation lemmas first, add evaluation unfolding if instantiation fails.</p>
</dd>
<dt class="field-even"><code class="docutils literal notranslate"><span class="pre">priority-eval</span></code><span class="colon">:</span></dt>
<dd class="field-even"><p>add evaluation unfolding lemma first, add instantiation lemma if unfolding lemmas already added.</p>
</dd>
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">interleave</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>add instantiation and evaluation unfolding lemmas in the same step.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-sygus-inst-scope">
<dt><code class="docutils literal notranslate"><span class="pre">sygus-inst-scope</span></code> [<code class="docutils literal notranslate"><span class="pre">in</span> <span class="pre">|</span> <span class="pre">out</span> <span class="pre">|</span> <span class="pre">both</span></code>, default <code class="docutils literal notranslate"><span class="pre">in</span></code>]</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>select scope of ground terms</p>
<p>scope for collecting ground terms for the grammar.</p>
<dl class="field-list simple">
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">in</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>use ground terms inside given quantified formula only.</p>
</dd>
<dt class="field-even"><code class="docutils literal notranslate"><span class="pre">out</span></code><span class="colon">:</span></dt>
<dd class="field-even"><p>use ground terms outside of quantified formulas only.</p>
</dd>
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">both</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>combines inside and outside.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-sygus-inst-term-sel">
<dt><code class="docutils literal notranslate"><span class="pre">sygus-inst-term-sel</span></code> [<code class="docutils literal notranslate"><span class="pre">min</span> <span class="pre">|</span> <span class="pre">max</span> <span class="pre">|</span> <span class="pre">both</span></code>, default <code class="docutils literal notranslate"><span class="pre">min</span></code>]</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>granularity for ground terms</p>
<p>Ground term selection modes.</p>
<dl class="field-list simple">
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">min</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>collect minimal ground terms only.</p>
</dd>
<dt class="field-even"><code class="docutils literal notranslate"><span class="pre">max</span></code><span class="colon">:</span></dt>
<dd class="field-even"><p>collect maximal ground terms only.</p>
</dd>
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">both</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>combines minimal and maximal .</p>
</dd>
</dl>
</dd>
</dl>
<dl id="lbl-option-sygus-inv-templ">
<dt><code class="docutils literal notranslate"><span class="pre">sygus-inv-templ</span></code> [<code class="docutils literal notranslate"><span class="pre">none</span> <span class="pre">|</span> <span class="pre">pre</span> <span class="pre">|</span> <span class="pre">post</span></code>, default <code class="docutils literal notranslate"><span class="pre">post</span></code>]</dt><dd><p>template mode for sygus invariant synthesis (weaken pre-condition, strengthen post-condition, or none)</p>
<p>Template modes for sygus invariant synthesis.</p>
<dl class="field-list simple">
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">none</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>Synthesize invariant directly.</p>
</dd>
<dt class="field-even"><code class="docutils literal notranslate"><span class="pre">pre</span></code><span class="colon">:</span></dt>
<dd class="field-even"><p>Synthesize invariant based on weakening of precondition.</p>
</dd>
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">post</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>Synthesize invariant based on strengthening of postcondition.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-sygus-inv-templ-when-sg">
<dt><code class="docutils literal notranslate"><span class="pre">sygus-inv-templ-when-sg</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>use invariant templates (with solution reconstruction) for syntax guided problems</p>
</dd>
</dl>
<dl class="simple" id="lbl-option-sygus-min-grammar">
<dt><code class="docutils literal notranslate"><span class="pre">sygus-min-grammar</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">true</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p>statically minimize sygus grammars</p>
</dd>
</dl>
<dl id="lbl-option-sygus-out">
<dt><code class="docutils literal notranslate"><span class="pre">sygus-out</span></code> [<code class="docutils literal notranslate"><span class="pre">status</span> <span class="pre">|</span> <span class="pre">status-and-def</span> <span class="pre">|</span> <span class="pre">sygus-standard</span></code>, default <code class="docutils literal notranslate"><span class="pre">sygus-standard</span></code>]</dt><dd><p>output mode for sygus</p>
<p>Modes for sygus solution output.</p>
<dl class="field-list simple">
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">status</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>Print only status for check-synth calls.</p>
</dd>
<dt class="field-even"><code class="docutils literal notranslate"><span class="pre">status-and-def</span></code><span class="colon">:</span></dt>
<dd class="field-even"><p>Print status followed by definition corresponding to solution.</p>
</dd>
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">sygus-standard</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>Print based on SyGuS standard.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="simple" id="lbl-option-sygus-pbe">
<dt><code class="docutils literal notranslate"><span class="pre">sygus-pbe</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">true</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p>enable approach which unifies conditional solutions, specialized for programming-by-examples (pbe) conjectures</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-sygus-pbe-multi-fair">
<dt><code class="docutils literal notranslate"><span class="pre">sygus-pbe-multi-fair</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>when using multiple enumerators, ensure that we only register value of minimial term size</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-sygus-pbe-multi-fair-diff">
<dt><code class="docutils literal notranslate"><span class="pre">sygus-pbe-multi-fair-diff</span></code> [type <code class="docutils literal notranslate"><span class="pre">int64_t</span></code>, default <code class="docutils literal notranslate"><span class="pre">0</span></code>]</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>when using multiple enumerators, ensure that we only register values of minimial term size plus this value (default 0)</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-sygus-qe-preproc">
<dt><code class="docutils literal notranslate"><span class="pre">sygus-qe-preproc</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>use quantifier elimination as a preprocessing step for sygus</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-sygus-query-gen">
<dt><code class="docutils literal notranslate"><span class="pre">sygus-query-gen</span></code> [<code class="docutils literal notranslate"><span class="pre">basic</span> <span class="pre">|</span> <span class="pre">sample-sat</span> <span class="pre">|</span> <span class="pre">unsat</span></code>, default <code class="docutils literal notranslate"><span class="pre">basic</span></code>]</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>mode for generating interesting satisfiability queries using SyGuS, for internal fuzzing</p>
<p>Modes for generating interesting satisfiability queries using SyGuS.</p>
<dl class="field-list simple">
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">basic</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>Generate all queries using SyGuS enumeration of the given grammar</p>
</dd>
<dt class="field-even"><code class="docutils literal notranslate"><span class="pre">sample-sat</span></code><span class="colon">:</span></dt>
<dd class="field-even"><p>Generate interesting SAT queries based on sampling, for e.g. soundness testing.</p>
</dd>
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">unsat</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>Generate interesting UNSAT queries, for e.g. proof testing.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-sygus-query-gen-dump-files">
<dt><code class="docutils literal notranslate"><span class="pre">sygus-query-gen-dump-files</span></code> [<code class="docutils literal notranslate"><span class="pre">none</span> <span class="pre">|</span> <span class="pre">all</span> <span class="pre">|</span> <span class="pre">unsolved</span></code>, default <code class="docutils literal notranslate"><span class="pre">none</span></code>]</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>mode for dumping external files corresponding to interesting satisfiability queries with sygus-query-gen</p>
<p>Query file options.</p>
<dl class="field-list simple">
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">none</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>Do not dump query files when using –sygus-query-gen.</p>
</dd>
<dt class="field-even"><code class="docutils literal notranslate"><span class="pre">all</span></code><span class="colon">:</span></dt>
<dd class="field-even"><p>Dump all query files.</p>
</dd>
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">unsolved</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>Dump query files that the subsolver did not solve.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-sygus-query-gen-filter-solved">
<dt><code class="docutils literal notranslate"><span class="pre">sygus-query-gen-filter-solved</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>do not print queries that are solved</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-sygus-query-gen-thresh">
<dt><code class="docutils literal notranslate"><span class="pre">sygus-query-gen-thresh</span></code> [type <code class="docutils literal notranslate"><span class="pre">uint64_t</span></code>, default <code class="docutils literal notranslate"><span class="pre">5</span></code>]</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>number of points that we allow to be equal for enumerating satisfiable queries with sygus-query-gen</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-sygus-rec-fun">
<dt><code class="docutils literal notranslate"><span class="pre">sygus-rec-fun</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">true</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>enable efficient support for recursive functions in sygus</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-sygus-rec-fun-eval-limit">
<dt><code class="docutils literal notranslate"><span class="pre">sygus-rec-fun-eval-limit</span></code> [type <code class="docutils literal notranslate"><span class="pre">uint64_t</span></code>, default <code class="docutils literal notranslate"><span class="pre">1000</span></code>]</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>use a hard limit for how many times in a given evaluator call a recursive function can be evaluated (so infinite loops can be avoided)</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-sygus-rec-fun-infer">
<dt><code class="docutils literal notranslate"><span class="pre">sygus-rec-fun-infer</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">true</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>automatically infer recursive definitions for sygus</p>
</dd>
</dl>
<dl class="simple" id="lbl-option-sygus-repair-const">
<dt><code class="docutils literal notranslate"><span class="pre">sygus-repair-const</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">true</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p>use approach to repair constants in sygus candidate solutions</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-sygus-repair-const-timeout">
<dt><code class="docutils literal notranslate"><span class="pre">sygus-repair-const-timeout</span></code> [type <code class="docutils literal notranslate"><span class="pre">uint64_t</span></code>, default <code class="docutils literal notranslate"><span class="pre">0</span></code>]</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>timeout (in milliseconds) for the satisfiability check to repair constants in sygus candidate solutions</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-sygus-rr-synth-accel">
<dt><code class="docutils literal notranslate"><span class="pre">sygus-rr-synth-accel</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>add dynamic symmetry breaking clauses based on candidate rewrites</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-sygus-rr-synth-check">
<dt><code class="docutils literal notranslate"><span class="pre">sygus-rr-synth-check</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">true</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>use satisfiability check to verify correctness of candidate rewrites</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-sygus-rr-synth-filter-cong">
<dt><code class="docutils literal notranslate"><span class="pre">sygus-rr-synth-filter-cong</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">true</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>filter candidate rewrites based on congruence</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-sygus-rr-synth-filter-match">
<dt><code class="docutils literal notranslate"><span class="pre">sygus-rr-synth-filter-match</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">true</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>filter candidate rewrites based on matching</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-sygus-rr-synth-filter-nl">
<dt><code class="docutils literal notranslate"><span class="pre">sygus-rr-synth-filter-nl</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>filter non-linear candidate rewrites</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-sygus-rr-synth-filter-order">
<dt><code class="docutils literal notranslate"><span class="pre">sygus-rr-synth-filter-order</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">true</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>filter candidate rewrites based on variable ordering</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-sygus-rr-synth-input-nvars">
<dt><code class="docutils literal notranslate"><span class="pre">sygus-rr-synth-input-nvars</span></code> [type <code class="docutils literal notranslate"><span class="pre">int64_t</span></code>, default <code class="docutils literal notranslate"><span class="pre">3</span></code>]</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>the maximum number of variables per type that appear in rewrites from sygus-rr-synth-input</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-sygus-rr-synth-rec">
<dt><code class="docutils literal notranslate"><span class="pre">sygus-rr-synth-rec</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>synthesize rewrite rules over all sygus grammar types recursively</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-sygus-sample-fp-uniform">
<dt><code class="docutils literal notranslate"><span class="pre">sygus-sample-fp-uniform</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>sample floating-point values uniformly instead of in a biased fashion</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-sygus-sample-grammar">
<dt><code class="docutils literal notranslate"><span class="pre">sygus-sample-grammar</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">true</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>when applicable, use grammar for choosing sample points</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-sygus-samples">
<dt><code class="docutils literal notranslate"><span class="pre">sygus-samples</span></code> [type <code class="docutils literal notranslate"><span class="pre">int64_t</span></code>, default <code class="docutils literal notranslate"><span class="pre">1000</span></code>]</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>number of points to consider when doing sygus rewriter sample testing</p>
</dd>
</dl>
<dl id="lbl-option-sygus-si">
<dt><code class="docutils literal notranslate"><span class="pre">sygus-si</span></code> [<code class="docutils literal notranslate"><span class="pre">none</span> <span class="pre">|</span> <span class="pre">use</span> <span class="pre">|</span> <span class="pre">all</span></code>, default <code class="docutils literal notranslate"><span class="pre">none</span></code>]</dt><dd><p>mode for processing single invocation synthesis conjectures</p>
<p>Modes for single invocation techniques.</p>
<dl class="field-list simple">
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">none</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>Do not use single invocation techniques.</p>
</dd>
<dt class="field-even"><code class="docutils literal notranslate"><span class="pre">use</span></code><span class="colon">:</span></dt>
<dd class="field-even"><p>Use single invocation techniques only if grammar is not restrictive.</p>
</dd>
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">all</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>Always use single invocation techniques.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="simple" id="lbl-option-sygus-si-abort">
<dt><code class="docutils literal notranslate"><span class="pre">sygus-si-abort</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p>abort if synthesis conjecture is not single invocation</p>
</dd>
</dl>
<dl id="lbl-option-sygus-si-rcons">
<dt><code class="docutils literal notranslate"><span class="pre">sygus-si-rcons</span></code> [<code class="docutils literal notranslate"><span class="pre">none</span> <span class="pre">|</span> <span class="pre">try</span> <span class="pre">|</span> <span class="pre">all-limit</span> <span class="pre">|</span> <span class="pre">all</span></code>, default <code class="docutils literal notranslate"><span class="pre">all</span></code>]</dt><dd><p>policy for reconstructing solutions for single invocation conjectures</p>
<p>Modes for reconstruction solutions while using single invocation techniques.</p>
<dl class="field-list simple">
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">none</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>Do not try to reconstruct solutions in the original (user-provided) grammar when using single invocation techniques. In this mode, solutions produced by cvc5 may violate grammar restrictions.</p>
</dd>
<dt class="field-even"><code class="docutils literal notranslate"><span class="pre">try</span></code><span class="colon">:</span></dt>
<dd class="field-even"><p>Try to reconstruct solutions in the original grammar when using single invocation techniques in an incomplete (fail-fast) manner.</p>
</dd>
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">all-limit</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>Try to reconstruct solutions in the original grammar, but terminate if a maximum number of rounds for reconstruction is exceeded.</p>
</dd>
<dt class="field-even"><code class="docutils literal notranslate"><span class="pre">all</span></code><span class="colon">:</span></dt>
<dd class="field-even"><p>Try to reconstruct solutions in the original grammar. In this mode, we do not terminate until a solution is successfully reconstructed.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-sygus-si-rcons-limit">
<dt><code class="docutils literal notranslate"><span class="pre">sygus-si-rcons-limit</span></code> [type <code class="docutils literal notranslate"><span class="pre">int64_t</span></code>, default <code class="docutils literal notranslate"><span class="pre">10000</span></code>]</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>number of rounds of enumeration to use during solution reconstruction (negative means unlimited)</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-sygus-si-rcons-p">
<dt><code class="docutils literal notranslate"><span class="pre">sygus-si-rcons-p</span></code> [type <code class="docutils literal notranslate"><span class="pre">double</span></code>, <code class="docutils literal notranslate"><span class="pre">0.0</span> <span class="pre">&lt;=</span> <span class="pre">P</span> <span class="pre">&lt;=</span> <span class="pre">1.0</span></code>, default <code class="docutils literal notranslate"><span class="pre">0.5</span></code>]</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>the parameter of the geometric distribution used to determine the number of unification patterns generated by single invocation techniques.</p>
</dd>
</dl>
<dl class="simple" id="lbl-option-sygus-stream">
<dt><code class="docutils literal notranslate"><span class="pre">sygus-stream</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p>enumerate a stream of solutions instead of terminating after the first one</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-sygus-unif-cond-independent-no-repeat-sol">
<dt><code class="docutils literal notranslate"><span class="pre">sygus-unif-cond-independent-no-repeat-sol</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">true</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>Do not try repeated solutions when using independent synthesis of conditions in unification-based function synthesis</p>
</dd>
</dl>
<dl id="lbl-option-sygus-unif-pi">
<dt><code class="docutils literal notranslate"><span class="pre">sygus-unif-pi</span></code> [<code class="docutils literal notranslate"><span class="pre">none</span> <span class="pre">|</span> <span class="pre">complete</span> <span class="pre">|</span> <span class="pre">cond-enum</span> <span class="pre">|</span> <span class="pre">cond-enum-igain</span></code>, default <code class="docutils literal notranslate"><span class="pre">none</span></code>]</dt><dd><p>mode for synthesis via piecewise-indepedent unification</p>
<p>Modes for piecewise-independent unification.</p>
<dl class="field-list simple">
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">none</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>Do not use piecewise-independent unification.</p>
</dd>
<dt class="field-even"><code class="docutils literal notranslate"><span class="pre">complete</span></code><span class="colon">:</span></dt>
<dd class="field-even"><p>Use complete approach for piecewise-independent unification (see Section 3 of Barbosa et al FMCAD 2019)</p>
</dd>
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">cond-enum</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>Use unconstrained condition enumeration for piecewise-independent unification (see Section 4 of Barbosa et al FMCAD 2019).</p>
</dd>
<dt class="field-even"><code class="docutils literal notranslate"><span class="pre">cond-enum-igain</span></code><span class="colon">:</span></dt>
<dd class="field-even"><p>Same as cond-enum, but additionally uses an information gain heuristic when doing decision tree learning.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-sygus-unif-shuffle-cond">
<dt><code class="docutils literal notranslate"><span class="pre">sygus-unif-shuffle-cond</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>Shuffle condition pool when building solutions (may change solutions sizes)</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-sygus-verify-inst-max-rounds">
<dt><code class="docutils literal notranslate"><span class="pre">sygus-verify-inst-max-rounds</span></code> [type <code class="docutils literal notranslate"><span class="pre">int64_t</span></code>, default <code class="docutils literal notranslate"><span class="pre">10</span></code>]</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>maximum number of instantiation rounds for sygus verification calls (-1 == no limit, default is 10)</p>
</dd>
</dl>
<dl class="simple" id="lbl-option-sygus-verify-timeout">
<dt><code class="docutils literal notranslate"><span class="pre">sygus-verify-timeout</span></code> [type <code class="docutils literal notranslate"><span class="pre">uint64_t</span></code>, default <code class="docutils literal notranslate"><span class="pre">0</span></code>]</dt><dd><p>timeout (in milliseconds) for verifying satisfiability of synthesized terms (0 == no limit)</p>
</dd>
</dl>
<dl id="lbl-option-term-db-mode">
<dt><code class="docutils literal notranslate"><span class="pre">term-db-mode</span></code> [<code class="docutils literal notranslate"><span class="pre">all</span> <span class="pre">|</span> <span class="pre">relevant</span></code>, default <code class="docutils literal notranslate"><span class="pre">relevant</span></code>]</dt><dd><p>which ground terms to consider for instantiation</p>
<p>Modes for terms included in the quantifiers term database.</p>
<dl class="field-list simple">
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">all</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>Quantifiers module considers all ground terms.</p>
</dd>
<dt class="field-even"><code class="docutils literal notranslate"><span class="pre">relevant</span></code><span class="colon">:</span></dt>
<dd class="field-even"><p>Quantifiers module considers only ground terms connected to current assertions.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-trigger-active-sel">
<dt><code class="docutils literal notranslate"><span class="pre">trigger-active-sel</span></code> [<code class="docutils literal notranslate"><span class="pre">all</span> <span class="pre">|</span> <span class="pre">min</span> <span class="pre">|</span> <span class="pre">max</span></code>, default <code class="docutils literal notranslate"><span class="pre">all</span></code>]</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>selection mode to activate triggers</p>
<p>Trigger active selection modes.</p>
<dl class="field-list simple">
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">all</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>Make all triggers active.</p>
</dd>
<dt class="field-even"><code class="docutils literal notranslate"><span class="pre">min</span></code><span class="colon">:</span></dt>
<dd class="field-even"><p>Activate triggers with minimal ground terms.</p>
</dd>
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">max</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>Activate triggers with maximal ground terms.</p>
</dd>
</dl>
</dd>
</dl>
<dl id="lbl-option-trigger-sel">
<dt><code class="docutils literal notranslate"><span class="pre">trigger-sel</span></code> [<code class="docutils literal notranslate"><span class="pre">min</span> <span class="pre">|</span> <span class="pre">max</span> <span class="pre">|</span> <span class="pre">min-s-max</span> <span class="pre">|</span> <span class="pre">min-s-all</span> <span class="pre">|</span> <span class="pre">all</span></code>, default <code class="docutils literal notranslate"><span class="pre">min</span></code>]</dt><dd><p>selection mode for triggers</p>
<p>Trigger selection modes.</p>
<dl class="field-list simple">
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">min</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>Consider only minimal subterms that meet criteria for triggers.</p>
</dd>
<dt class="field-even"><code class="docutils literal notranslate"><span class="pre">max</span></code><span class="colon">:</span></dt>
<dd class="field-even"><p>Consider only maximal subterms that meet criteria for triggers.</p>
</dd>
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">min-s-max</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>Consider only minimal subterms that meet criteria for single triggers, maximal otherwise.</p>
</dd>
<dt class="field-even"><code class="docutils literal notranslate"><span class="pre">min-s-all</span></code><span class="colon">:</span></dt>
<dd class="field-even"><p>Consider only minimal subterms that meet criteria for single triggers, all otherwise.</p>
</dd>
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">all</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>Consider all subterms that meet criteria for triggers.</p>
</dd>
</dl>
</dd>
</dl>
<dl id="lbl-option-user-pat">
<dt><code class="docutils literal notranslate"><span class="pre">user-pat</span></code> [<code class="docutils literal notranslate"><span class="pre">use</span> <span class="pre">|</span> <span class="pre">trust</span> <span class="pre">|</span> <span class="pre">strict</span> <span class="pre">|</span> <span class="pre">resort</span> <span class="pre">|</span> <span class="pre">ignore</span> <span class="pre">|</span> <span class="pre">interleave</span></code>, default <code class="docutils literal notranslate"><span class="pre">trust</span></code>]</dt><dd><p>policy for handling user-provided patterns for quantifier instantiation</p>
<p>These modes determine how user provided patterns (triggers) are used during E-matching. The modes vary on when instantiation based on user-provided triggers is combined with instantiation based on automatically selected triggers.</p>
<dl class="field-list simple">
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">use</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>Use both user-provided and auto-generated patterns when patterns are provided for a quantified formula.</p>
</dd>
<dt class="field-even"><code class="docutils literal notranslate"><span class="pre">trust</span></code><span class="colon">:</span></dt>
<dd class="field-even"><p>When provided, use only user-provided patterns for a quantified formula.</p>
</dd>
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">strict</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>When provided, use only user-provided patterns for a quantified formula, and do not use any other instantiation techniques.</p>
</dd>
<dt class="field-even"><code class="docutils literal notranslate"><span class="pre">resort</span></code><span class="colon">:</span></dt>
<dd class="field-even"><p>Use user-provided patterns only after auto-generated patterns saturate.</p>
</dd>
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">ignore</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>Ignore user-provided patterns.</p>
</dd>
<dt class="field-even"><code class="docutils literal notranslate"><span class="pre">interleave</span></code><span class="colon">:</span></dt>
<dd class="field-even"><p>Alternate between use/resort.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-user-pool">
<dt><code class="docutils literal notranslate"><span class="pre">user-pool</span></code> [<code class="docutils literal notranslate"><span class="pre">use</span> <span class="pre">|</span> <span class="pre">trust</span> <span class="pre">|</span> <span class="pre">ignore</span></code>, default <code class="docutils literal notranslate"><span class="pre">trust</span></code>]</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>policy for handling user-provided pools for quantifier instantiation</p>
<p>These modes determine how user provided pools are used in combination with other instantiation techniques.</p>
<dl class="field-list simple">
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">use</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>Use both user-provided pool and other instantiation strategies when pools are provided for a quantified formula.</p>
</dd>
<dt class="field-even"><code class="docutils literal notranslate"><span class="pre">trust</span></code><span class="colon">:</span></dt>
<dd class="field-even"><p>When provided, use only user-provided pool for a quantified formula.</p>
</dd>
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">ignore</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>Ignore user-provided pool.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="simple" id="lbl-option-var-elim-quant">
<dt><code class="docutils literal notranslate"><span class="pre">var-elim-quant</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">true</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p>enable simple variable elimination for quantified formulas</p>
</dd>
</dl>
<dl class="simple" id="lbl-option-var-ent-eq-elim-quant">
<dt><code class="docutils literal notranslate"><span class="pre">var-ent-eq-elim-quant</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">true</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p>enable variable elimination for quantified formulas that infers entailed equalities corresponding to eliminations</p>
</dd>
</dl>
<dl class="simple" id="lbl-option-var-ineq-elim-quant">
<dt><code class="docutils literal notranslate"><span class="pre">var-ineq-elim-quant</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">true</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p>enable variable elimination based on infinite projection of unbound arithmetic variables</p>
</dd>
</dl>
</section>
<section id="separation-logic-theory-module">
<h3>Separation Logic Theory Module<a class="headerlink" href="#separation-logic-theory-module" title="Link to this heading"></a></h3>
<dl class="expert-option simple" id="lbl-option-sep">
<dt><code class="docutils literal notranslate"><span class="pre">sep</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">true</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>enables the separation logic solver in applicable logics</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-sep-min-refine">
<dt><code class="docutils literal notranslate"><span class="pre">sep-min-refine</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>only add refinement lemmas for minimal (innermost) assertions</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-sep-pre-skolem-emp">
<dt><code class="docutils literal notranslate"><span class="pre">sep-pre-skolem-emp</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>eliminate emp constraint at preprocess time</p>
</dd>
</dl>
</section>
<section id="sets-theory-module">
<h3>Sets Theory Module<a class="headerlink" href="#sets-theory-module" title="Link to this heading"></a></h3>
<dl class="expert-option simple" id="lbl-option-rels-exp">
<dt><code class="docutils literal notranslate"><span class="pre">rels-exp</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">true</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>enable the relations extension of the theory of sets</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-sets-card-exp">
<dt><code class="docutils literal notranslate"><span class="pre">sets-card-exp</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">true</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>enable the cardinality extension of the theory of sets</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-sets-exp">
<dt><code class="docutils literal notranslate"><span class="pre">sets-exp</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>enable extended symbols such as complement and universe in theory of sets</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-sets-proxy-lemmas">
<dt><code class="docutils literal notranslate"><span class="pre">sets-proxy-lemmas</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>introduce proxy variables eagerly to shorten lemmas</p>
</dd>
</dl>
</section>
<section id="smt-layer-module">
<h3>SMT Layer Module<a class="headerlink" href="#smt-layer-module" title="Link to this heading"></a></h3>
<dl class="expert-option simple" id="lbl-option-abstract-values">
<dt><code class="docutils literal notranslate"><span class="pre">abstract-values</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>in models, output arrays (and in future, maybe others) using abstract values, as required by the SMT-LIB standard</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-ackermann">
<dt><code class="docutils literal notranslate"><span class="pre">ackermann</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>eliminate functions by ackermannization</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-bv-to-int-use-pow2">
<dt><code class="docutils literal notranslate"><span class="pre">bv-to-int-use-pow2</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>use internal pow2 operator when translating shift notes</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-bvand-integer-granularity">
<dt><code class="docutils literal notranslate"><span class="pre">bvand-integer-granularity</span></code> [type <code class="docutils literal notranslate"><span class="pre">uint64_t</span></code>, <code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">&lt;=</span> <span class="pre">N</span> <span class="pre">&lt;=</span> <span class="pre">8</span></code>, default <code class="docutils literal notranslate"><span class="pre">1</span></code>]</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>granularity to use in –solve-bv-as-int mode and for iand operator (experimental)</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-deep-restart">
<dt><code class="docutils literal notranslate"><span class="pre">deep-restart</span></code> [<code class="docutils literal notranslate"><span class="pre">none</span> <span class="pre">|</span> <span class="pre">input</span> <span class="pre">|</span> <span class="pre">input-and-solvable</span> <span class="pre">|</span> <span class="pre">input-and-prop</span> <span class="pre">|</span> <span class="pre">all</span></code>, default <code class="docutils literal notranslate"><span class="pre">none</span></code>]</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>mode for deep restarts</p>
<p>Mode for deep restarts</p>
<dl class="field-list simple">
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">none</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>do not use deep restart</p>
</dd>
<dt class="field-even"><code class="docutils literal notranslate"><span class="pre">input</span></code><span class="colon">:</span></dt>
<dd class="field-even"><p>learn literals that appear in the input</p>
</dd>
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">input-and-solvable</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>learn literals that appear in the input and those that can be solved for variables that appear in the input</p>
</dd>
<dt class="field-even"><code class="docutils literal notranslate"><span class="pre">input-and-prop</span></code><span class="colon">:</span></dt>
<dd class="field-even"><p>learn literals that appear in the input and those that can be solved for variables, or correspond to constant propagations for terms that appear in the input</p>
</dd>
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">all</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>learn all literals</p>
</dd>
</dl>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-deep-restart-factor">
<dt><code class="docutils literal notranslate"><span class="pre">deep-restart-factor</span></code> [type <code class="docutils literal notranslate"><span class="pre">double</span></code>, <code class="docutils literal notranslate"><span class="pre">0.0</span> <span class="pre">&lt;=</span> <span class="pre">F</span> <span class="pre">&lt;=</span> <span class="pre">1000.0</span></code>, default <code class="docutils literal notranslate"><span class="pre">3.0</span></code>]</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>sets the threshold for average assertions per literal before a deep restart</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-difficulty-mode">
<dt><code class="docutils literal notranslate"><span class="pre">difficulty-mode</span></code> [<code class="docutils literal notranslate"><span class="pre">lemma-literal</span> <span class="pre">|</span> <span class="pre">lemma-literal-all</span> <span class="pre">|</span> <span class="pre">model-check</span></code>, default <code class="docutils literal notranslate"><span class="pre">lemma-literal-all</span></code>]</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>choose output mode for get-difficulty, see –difficulty-mode=help</p>
<p>difficulty output modes.</p>
<dl class="field-list simple">
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">lemma-literal</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>Difficulty of an assertion is how many lemmas (at full effort) use a literal that the assertion depends on to be satisfied.</p>
</dd>
<dt class="field-even"><code class="docutils literal notranslate"><span class="pre">lemma-literal-all</span></code><span class="colon">:</span></dt>
<dd class="field-even"><p>Difficulty of an assertion is how many lemmas use a literal that the assertion depends on to be satisfied.</p>
</dd>
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">model-check</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>Difficulty of an assertion is how many times it was not satisfied in a candidate model.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-early-ite-removal">
<dt><code class="docutils literal notranslate"><span class="pre">early-ite-removal</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>remove ITEs early in preprocessing</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-ext-rew-prep">
<dt><code class="docutils literal notranslate"><span class="pre">ext-rew-prep</span></code> [<code class="docutils literal notranslate"><span class="pre">off</span> <span class="pre">|</span> <span class="pre">use</span> <span class="pre">|</span> <span class="pre">agg</span></code>, default <code class="docutils literal notranslate"><span class="pre">off</span></code>]</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>mode for using extended rewriter as a preprocessing pass, see –ext-rew-prep=help</p>
<p>extended rewriter preprocessing pass modes.</p>
<dl class="field-list simple">
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">off</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>do not use extended rewriter as a preprocessing pass.</p>
</dd>
<dt class="field-even"><code class="docutils literal notranslate"><span class="pre">use</span></code><span class="colon">:</span></dt>
<dd class="field-even"><p>use extended rewriter as a preprocessing pass.</p>
</dd>
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">agg</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>use aggressive extended rewriter as a preprocessing pass.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-foreign-theory-rewrite">
<dt><code class="docutils literal notranslate"><span class="pre">foreign-theory-rewrite</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>Cross-theory rewrites</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-iand-mode">
<dt><code class="docutils literal notranslate"><span class="pre">iand-mode</span></code> [<code class="docutils literal notranslate"><span class="pre">value</span> <span class="pre">|</span> <span class="pre">sum</span> <span class="pre">|</span> <span class="pre">bitwise</span></code>, default <code class="docutils literal notranslate"><span class="pre">value</span></code>]</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>Set the refinement scheme for integer AND</p>
<p>Refinement modes for integer AND</p>
<dl class="field-list simple">
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">value</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>value-based refinement</p>
</dd>
<dt class="field-even"><code class="docutils literal notranslate"><span class="pre">sum</span></code><span class="colon">:</span></dt>
<dd class="field-even"><p>use sum to represent integer AND in refinement</p>
</dd>
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">bitwise</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>use bitwise comparisons on binary representation of integer for refinement (experimental)</p>
</dd>
</dl>
</dd>
</dl>
<dl id="lbl-option-interpolants-mode">
<dt><code class="docutils literal notranslate"><span class="pre">interpolants-mode</span></code> [<code class="docutils literal notranslate"><span class="pre">default</span> <span class="pre">|</span> <span class="pre">assumptions</span> <span class="pre">|</span> <span class="pre">conjecture</span> <span class="pre">|</span> <span class="pre">shared</span> <span class="pre">|</span> <span class="pre">all</span></code>, default <code class="docutils literal notranslate"><span class="pre">default</span></code>]</dt><dd><p>choose interpolants production mode, see –interpolants-mode=help</p>
<p>Interpolants grammar mode</p>
<dl class="field-list simple">
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">default</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>use the default grammar for the theory or the user-defined grammar if given</p>
</dd>
<dt class="field-even"><code class="docutils literal notranslate"><span class="pre">assumptions</span></code><span class="colon">:</span></dt>
<dd class="field-even"><p>use only operators that occur in the assumptions</p>
</dd>
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">conjecture</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>use only operators that occur in the conjecture</p>
</dd>
<dt class="field-even"><code class="docutils literal notranslate"><span class="pre">shared</span></code><span class="colon">:</span></dt>
<dd class="field-even"><p>use only operators that occur both in the assumptions and the conjecture</p>
</dd>
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">all</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>use only operators that occur either in the assumptions or the conjecture</p>
</dd>
</dl>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-ite-simp">
<dt><code class="docutils literal notranslate"><span class="pre">ite-simp</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>turn on ite simplification (Kim (and Somenzi) et al., SAT 2009)</p>
</dd>
</dl>
<dl class="simple" id="lbl-option-learned-rewrite">
<dt><code class="docutils literal notranslate"><span class="pre">learned-rewrite</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p>rewrite the input based on learned literals</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-minimal-unsat-cores">
<dt><code class="docutils literal notranslate"><span class="pre">minimal-unsat-cores</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>if an unsat core is produced, it is reduced to a minimal unsat core</p>
</dd>
</dl>
<dl id="lbl-option-model-cores">
<dt><code class="docutils literal notranslate"><span class="pre">model-cores</span></code> [<code class="docutils literal notranslate"><span class="pre">none</span> <span class="pre">|</span> <span class="pre">simple</span> <span class="pre">|</span> <span class="pre">non-implied</span></code>, default <code class="docutils literal notranslate"><span class="pre">none</span></code>]</dt><dd><p>mode for producing model cores</p>
<p>Model cores modes.</p>
<dl class="field-list simple">
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">none</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>Do not compute model cores.</p>
</dd>
<dt class="field-even"><code class="docutils literal notranslate"><span class="pre">simple</span></code><span class="colon">:</span></dt>
<dd class="field-even"><p>Only include a subset of variables whose values are sufficient to show the input formula is satisfied by the given model.</p>
</dd>
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">non-implied</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>Only include a subset of variables whose values, in addition to the values of variables whose values are implied, are sufficient to show the input formula is satisfied by the given model.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-model-var-elim-uneval">
<dt><code class="docutils literal notranslate"><span class="pre">model-var-elim-uneval</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">true</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>allow variable elimination based on unevaluatable terms to variables</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-on-repeat-ite-simp">
<dt><code class="docutils literal notranslate"><span class="pre">on-repeat-ite-simp</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>do the ite simplification pass again if repeating simplification</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-output-print-defs">
<dt><code class="docutils literal notranslate"><span class="pre">output-print-defs</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">true</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>print define-fun commands for top-level substitutions when dumping assertions</p>
</dd>
</dl>
<dl class="simple" id="lbl-option-print-cores-full">
<dt><code class="docutils literal notranslate"><span class="pre">print-cores-full</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p>print all formulas regardless of whether they are named, e.g. in unsat cores</p>
</dd>
</dl>
<dl class="simple" id="lbl-option-produce-abducts">
<dt><code class="docutils literal notranslate"><span class="pre">produce-abducts</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p>support the get-abduct command</p>
</dd>
</dl>
<dl class="simple" id="lbl-option-produce-assertions">
<dt><code class="docutils literal notranslate"><span class="pre">produce-assertions</span> <span class="pre">|</span> <span class="pre">interactive-mode</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">true</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p>keep an assertions list. Note this option is always enabled.</p>
</dd>
</dl>
<dl class="simple" id="lbl-option-produce-assignments">
<dt><code class="docutils literal notranslate"><span class="pre">produce-assignments</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p>support the get-assignment command</p>
</dd>
</dl>
<dl class="simple" id="lbl-option-produce-difficulty">
<dt><code class="docutils literal notranslate"><span class="pre">produce-difficulty</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p>enable tracking of difficulty.</p>
</dd>
</dl>
<dl class="simple" id="lbl-option-produce-interpolants">
<dt><code class="docutils literal notranslate"><span class="pre">produce-interpolants</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p>turn on interpolation generation.</p>
</dd>
</dl>
<dl class="simple" id="lbl-option-produce-learned-literals">
<dt><code class="docutils literal notranslate"><span class="pre">produce-learned-literals</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p>produce learned literals, support get-learned-literals</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-proof-mode">
<dt><code class="docutils literal notranslate"><span class="pre">proof-mode</span></code> [<code class="docutils literal notranslate"><span class="pre">off</span> <span class="pre">|</span> <span class="pre">pp-only</span> <span class="pre">|</span> <span class="pre">sat-proof</span> <span class="pre">|</span> <span class="pre">full-proof</span> <span class="pre">|</span> <span class="pre">full-proof-strict</span></code>, default <code class="docutils literal notranslate"><span class="pre">off</span></code>]</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>choose proof mode, see –proof-mode=help</p>
<p>proof modes.</p>
<dl class="field-list simple">
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">off</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>Do not produce proofs.</p>
</dd>
<dt class="field-even"><code class="docutils literal notranslate"><span class="pre">pp-only</span></code><span class="colon">:</span></dt>
<dd class="field-even"><p>Only produce proofs for preprocessing.</p>
</dd>
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">sat-proof</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>Produce proofs for preprocessing and for the SAT solver.</p>
</dd>
<dt class="field-even"><code class="docutils literal notranslate"><span class="pre">full-proof</span></code><span class="colon">:</span></dt>
<dd class="field-even"><p>Produce full proofs of preprocessing, SAT and theory lemmas.</p>
</dd>
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">full-proof-strict</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>Produce full proofs of preprocessing, SAT and theory lemmas. Additionally disable techniques that will lead to incomplete proofs.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-repeat-simp">
<dt><code class="docutils literal notranslate"><span class="pre">repeat-simp</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>make multiple passes with nonclausal simplifier</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-simp-ite-compress">
<dt><code class="docutils literal notranslate"><span class="pre">simp-ite-compress</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>enables compressing ites after ite simplification</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-simp-with-care">
<dt><code class="docutils literal notranslate"><span class="pre">simp-with-care</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>enables simplifyWithCare in ite simplificiation</p>
</dd>
</dl>
<dl id="lbl-option-simplification">
<dt><code class="docutils literal notranslate"><span class="pre">simplification</span> <span class="pre">|</span> <span class="pre">simplification-mode</span></code> [<code class="docutils literal notranslate"><span class="pre">none</span> <span class="pre">|</span> <span class="pre">batch</span></code>, default <code class="docutils literal notranslate"><span class="pre">batch</span></code>]</dt><dd><p>choose simplification mode, see –simplification=help</p>
<p>Simplification modes.</p>
<dl class="field-list simple">
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">none</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>Do not perform nonclausal simplification.</p>
</dd>
<dt class="field-even"><code class="docutils literal notranslate"><span class="pre">batch</span></code><span class="colon">:</span></dt>
<dd class="field-even"><p>Save up all ASSERTions; run nonclausal simplification and clausal (MiniSat) propagation for all of them only after reaching a querying command (CHECKSAT or QUERY or predicate SUBTYPE declaration).</p>
</dd>
</dl>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-simplification-bcp">
<dt><code class="docutils literal notranslate"><span class="pre">simplification-bcp</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>apply Boolean constant propagation as a substitution during simplification</p>
</dd>
</dl>
<dl id="lbl-option-solve-bv-as-int">
<dt><code class="docutils literal notranslate"><span class="pre">solve-bv-as-int</span></code> [<code class="docutils literal notranslate"><span class="pre">off</span> <span class="pre">|</span> <span class="pre">sum</span> <span class="pre">|</span> <span class="pre">iand</span> <span class="pre">|</span> <span class="pre">bv</span> <span class="pre">|</span> <span class="pre">bitwise</span></code>, default <code class="docutils literal notranslate"><span class="pre">off</span></code>]</dt><dd><p>mode for translating BVAnd to integer</p>
<p>solve-bv-as-int modes.</p>
<dl class="field-list simple">
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">off</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>Do not translate bit-vectors to integers</p>
</dd>
<dt class="field-even"><code class="docutils literal notranslate"><span class="pre">sum</span></code><span class="colon">:</span></dt>
<dd class="field-even"><p>Generate a sum expression for each bvand instance, based on the value in –solve-bv-as-int-granularity</p>
</dd>
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">iand</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>Translate bvand to the iand operator</p>
</dd>
<dt class="field-even"><code class="docutils literal notranslate"><span class="pre">bv</span></code><span class="colon">:</span></dt>
<dd class="field-even"><p>Translate bvand back to bit-vectors</p>
</dd>
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">bitwise</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>Introduce a UF operator for bvand, and eagerly add bitwise lemmas</p>
</dd>
</dl>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-solve-int-as-bv">
<dt><code class="docutils literal notranslate"><span class="pre">solve-int-as-bv</span></code> [type <code class="docutils literal notranslate"><span class="pre">uint64_t</span></code>, <code class="docutils literal notranslate"><span class="pre">N</span> <span class="pre">&lt;=</span> <span class="pre">4294967295</span></code>, default <code class="docutils literal notranslate"><span class="pre">0</span></code>]</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>attempt to solve a pure integer satisfiable problem by bitblasting in sufficient bitwidth (experimental)</p>
</dd>
</dl>
<dl class="simple" id="lbl-option-solve-real-as-int">
<dt><code class="docutils literal notranslate"><span class="pre">solve-real-as-int</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p>attempt to solve a pure real satisfiable problem as an integer problem (for non-linear)</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-sort-inference">
<dt><code class="docutils literal notranslate"><span class="pre">sort-inference</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>calculate sort inference of input problem, convert the input based on monotonic sorts</p>
</dd>
</dl>
<dl class="simple" id="lbl-option-static-learning">
<dt><code class="docutils literal notranslate"><span class="pre">static-learning</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">true</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p>use static learning (on by default)</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-timeout-core-timeout">
<dt><code class="docutils literal notranslate"><span class="pre">timeout-core-timeout</span></code> [type <code class="docutils literal notranslate"><span class="pre">uint64_t</span></code>, default <code class="docutils literal notranslate"><span class="pre">10000</span></code>]</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>timeout (in milliseconds) for satisfiability checks for timeout cores</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-unconstrained-simp">
<dt><code class="docutils literal notranslate"><span class="pre">unconstrained-simp</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>turn on unconstrained simplification (see Bruttomesso/Brummayer PhD thesis). Fully supported only in (subsets of) the logic QF_ABV.</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-unsat-cores-mode">
<dt><code class="docutils literal notranslate"><span class="pre">unsat-cores-mode</span></code> [<code class="docutils literal notranslate"><span class="pre">off</span> <span class="pre">|</span> <span class="pre">sat-proof</span> <span class="pre">|</span> <span class="pre">assumptions</span></code>, default <code class="docutils literal notranslate"><span class="pre">off</span></code>]</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>choose unsat core mode, see –unsat-cores-mode=help</p>
<p>unsat cores modes.</p>
<dl class="field-list simple">
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">off</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>Do not produce unsat cores.</p>
</dd>
<dt class="field-even"><code class="docutils literal notranslate"><span class="pre">sat-proof</span></code><span class="colon">:</span></dt>
<dd class="field-even"><p>Produce unsat cores from the SAT proof and prepocessing proofs.</p>
</dd>
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">assumptions</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>Produce unsat cores using solving under assumptions and preprocessing proofs.</p>
</dd>
</dl>
</dd>
</dl>
</section>
<section id="strings-theory-module">
<h3>Strings Theory Module<a class="headerlink" href="#strings-theory-module" title="Link to this heading"></a></h3>
<dl id="lbl-option-re-elim">
<dt><code class="docutils literal notranslate"><span class="pre">re-elim</span></code> [<code class="docutils literal notranslate"><span class="pre">off</span> <span class="pre">|</span> <span class="pre">on</span> <span class="pre">|</span> <span class="pre">agg</span></code>, default <code class="docutils literal notranslate"><span class="pre">off</span></code>]</dt><dd><p>regular expression elimination mode</p>
<p>Regular expression elimination modes.</p>
<dl class="field-list simple">
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">off</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>Do not use regular expression elimination.</p>
</dd>
<dt class="field-even"><code class="docutils literal notranslate"><span class="pre">on</span></code><span class="colon">:</span></dt>
<dd class="field-even"><p>Use regular expression elimination.</p>
</dd>
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">agg</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>Use aggressive regular expression elimination.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-re-first-class">
<dt><code class="docutils literal notranslate"><span class="pre">re-first-class</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>allow regular expressions as first class terms</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-re-inter-mode">
<dt><code class="docutils literal notranslate"><span class="pre">re-inter-mode</span></code> [<code class="docutils literal notranslate"><span class="pre">all</span> <span class="pre">|</span> <span class="pre">constant</span> <span class="pre">|</span> <span class="pre">one-constant</span> <span class="pre">|</span> <span class="pre">none</span></code>, default <code class="docutils literal notranslate"><span class="pre">none</span></code>]</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>determines which regular expressions intersections to compute</p>
<p>Regular expression intersection modes.</p>
<dl class="field-list simple">
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">all</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>Compute intersections for all regular expressions.</p>
</dd>
<dt class="field-even"><code class="docutils literal notranslate"><span class="pre">constant</span></code><span class="colon">:</span></dt>
<dd class="field-even"><p>Compute intersections only between regular expressions that do not contain re.allchar or re.range.</p>
</dd>
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">one-constant</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>Compute intersections only between regular expressions such that at least one side does not contain re.allchar or re.range.</p>
</dd>
<dt class="field-even"><code class="docutils literal notranslate"><span class="pre">none</span></code><span class="colon">:</span></dt>
<dd class="field-even"><p>Do not compute intersections for regular expressions.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-seq-array">
<dt><code class="docutils literal notranslate"><span class="pre">seq-array</span></code> [<code class="docutils literal notranslate"><span class="pre">lazy</span> <span class="pre">|</span> <span class="pre">eager</span> <span class="pre">|</span> <span class="pre">none</span></code>, default <code class="docutils literal notranslate"><span class="pre">none</span></code>]</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>use array-inspired solver for sequence updates in eager or lazy mode</p>
<p>use array-inspired solver for sequence updates in eager or lazy mode</p>
<dl class="field-list simple">
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">lazy</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>use array-inspired solver for sequence updates in lazy mode</p>
</dd>
<dt class="field-even"><code class="docutils literal notranslate"><span class="pre">eager</span></code><span class="colon">:</span></dt>
<dd class="field-even"><p>use array-inspired solver for sequence updates in eager mode</p>
</dd>
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">none</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>do not use array-inspired solver for sequence updates</p>
</dd>
</dl>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-strings-alpha-card">
<dt><code class="docutils literal notranslate"><span class="pre">strings-alpha-card</span></code> [type <code class="docutils literal notranslate"><span class="pre">uint64_t</span></code>, <code class="docutils literal notranslate"><span class="pre">N</span> <span class="pre">&lt;=</span> <span class="pre">196608</span></code>, default <code class="docutils literal notranslate"><span class="pre">196608</span></code>]</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>the assumed cardinality of the alphabet of characters for strings, which is a prefix of the interval of unicode code points in the SMT-LIB standard</p>
</dd>
</dl>
<dl class="simple" id="lbl-option-strings-check-entail-len">
<dt><code class="docutils literal notranslate"><span class="pre">strings-check-entail-len</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">true</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p>check entailment between length terms to reduce splitting</p>
</dd>
</dl>
<dl class="simple" id="lbl-option-strings-deq-ext">
<dt><code class="docutils literal notranslate"><span class="pre">strings-deq-ext</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p>use extensionality for string disequalities</p>
</dd>
</dl>
<dl class="simple" id="lbl-option-strings-eager-eval">
<dt><code class="docutils literal notranslate"><span class="pre">strings-eager-eval</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">true</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p>perform eager context-dependent evaluation for applications of string kinds in the equality engine</p>
</dd>
</dl>
<dl class="simple" id="lbl-option-strings-eager-len-re">
<dt><code class="docutils literal notranslate"><span class="pre">strings-eager-len-re</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p>use regular expressions for eager length conflicts</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-strings-eager-reg">
<dt><code class="docutils literal notranslate"><span class="pre">strings-eager-reg</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">true</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>do registration lemmas for terms during preregistration. If false, do registration lemmas for terms when they appear in asserted literals</p>
</dd>
</dl>
<dl class="simple" id="lbl-option-strings-eager-solver">
<dt><code class="docutils literal notranslate"><span class="pre">strings-eager-solver</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">true</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p>use the eager solver</p>
</dd>
</dl>
<dl class="simple" id="lbl-option-strings-exp">
<dt><code class="docutils literal notranslate"><span class="pre">strings-exp</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p>experimental features in the theory of strings</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-strings-ff">
<dt><code class="docutils literal notranslate"><span class="pre">strings-ff</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">true</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>do flat form inferences</p>
</dd>
</dl>
<dl class="simple" id="lbl-option-strings-fmf">
<dt><code class="docutils literal notranslate"><span class="pre">strings-fmf</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p>the finite model finding used by the theory of strings</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-strings-infer-as-lemmas">
<dt><code class="docutils literal notranslate"><span class="pre">strings-infer-as-lemmas</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>always send lemmas out instead of making internal inferences</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-strings-infer-sym">
<dt><code class="docutils literal notranslate"><span class="pre">strings-infer-sym</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">true</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>generalized inferences in strings based on proxy symbols</p>
</dd>
</dl>
<dl class="simple" id="lbl-option-strings-lazy-pp">
<dt><code class="docutils literal notranslate"><span class="pre">strings-lazy-pp</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">true</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p>perform string preprocessing lazily</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-strings-len-norm">
<dt><code class="docutils literal notranslate"><span class="pre">strings-len-norm</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">true</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>strings length normalization lemma</p>
</dd>
</dl>
<dl class="simple" id="lbl-option-strings-mbr">
<dt><code class="docutils literal notranslate"><span class="pre">strings-mbr</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">true</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p>use models to avoid reductions for extended functions that introduce quantified formulas</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-strings-model-max-len">
<dt><code class="docutils literal notranslate"><span class="pre">strings-model-max-len</span></code> [type <code class="docutils literal notranslate"><span class="pre">uint64_t</span></code>, <code class="docutils literal notranslate"><span class="pre">N</span> <span class="pre">&lt;=</span> <span class="pre">2147483647</span></code>, default <code class="docutils literal notranslate"><span class="pre">65536</span></code>]</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>The maximum size of string values in models</p>
</dd>
</dl>
<dl id="lbl-option-strings-process-loop-mode">
<dt><code class="docutils literal notranslate"><span class="pre">strings-process-loop-mode</span></code> [<code class="docutils literal notranslate"><span class="pre">full</span> <span class="pre">|</span> <span class="pre">simple</span> <span class="pre">|</span> <span class="pre">simple-abort</span> <span class="pre">|</span> <span class="pre">none</span> <span class="pre">|</span> <span class="pre">abort</span></code>, default <code class="docutils literal notranslate"><span class="pre">full</span></code>]</dt><dd><p>determines how to process looping string equations</p>
<p>Loop processing modes.</p>
<dl class="field-list simple">
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">full</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>Perform full processing of looping word equations.</p>
</dd>
<dt class="field-even"><code class="docutils literal notranslate"><span class="pre">simple</span></code><span class="colon">:</span></dt>
<dd class="field-even"><p>Omit normal loop breaking (default with –strings-fmf).</p>
</dd>
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">simple-abort</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>Abort when normal loop breaking is required.</p>
</dd>
<dt class="field-even"><code class="docutils literal notranslate"><span class="pre">none</span></code><span class="colon">:</span></dt>
<dd class="field-even"><p>Omit loop processing.</p>
</dd>
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">abort</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>Abort if looping word equations are encountered.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-strings-re-derive-conf">
<dt><code class="docutils literal notranslate"><span class="pre">strings-re-derive-conf</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>use regular expression derive for conflict finding</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-strings-re-posc-eager">
<dt><code class="docutils literal notranslate"><span class="pre">strings-re-posc-eager</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>eager reduction of positive membership into concatenation</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-strings-rec-arith-approx">
<dt><code class="docutils literal notranslate"><span class="pre">strings-rec-arith-approx</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>use possibly recursive reasoning when finding approximations for arithmetic string terms</p>
</dd>
</dl>
<dl class="simple" id="lbl-option-strings-regexp-inclusion">
<dt><code class="docutils literal notranslate"><span class="pre">strings-regexp-inclusion</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">true</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p>use regular expression inclusion for finding conflicts and avoiding regular expression unfolding</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-strings-rexplain-lemmas">
<dt><code class="docutils literal notranslate"><span class="pre">strings-rexplain-lemmas</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">true</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>regression explanations for string lemmas</p>
</dd>
</dl>
</section>
<section id="theory-layer-module">
<h3>Theory Layer Module<a class="headerlink" href="#theory-layer-module" title="Link to this heading"></a></h3>
<dl class="expert-option simple" id="lbl-option-assign-function-values">
<dt><code class="docutils literal notranslate"><span class="pre">assign-function-values</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">true</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>assign values for uninterpreted functions in models</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-conflict-process">
<dt><code class="docutils literal notranslate"><span class="pre">conflict-process</span></code> [<code class="docutils literal notranslate"><span class="pre">none</span> <span class="pre">|</span> <span class="pre">min</span> <span class="pre">|</span> <span class="pre">min-ext</span></code>, default <code class="docutils literal notranslate"><span class="pre">none</span></code>]</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>mode for processing theory conflicts</p>
<p>Defines mode for processing theory conflicts.</p>
<dl class="field-list simple">
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">none</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>Do not post-process conflicts from theory solvers.</p>
</dd>
<dt class="field-even"><code class="docutils literal notranslate"><span class="pre">min</span></code><span class="colon">:</span></dt>
<dd class="field-even"><p>Do simple minimization for conflicts from theory solvers.</p>
</dd>
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">min-ext</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>Do minimization for conflicts from theory solvers, relying on the extended rewriter.</p>
</dd>
</dl>
</dd>
</dl>
<dl id="lbl-option-ee-mode">
<dt><code class="docutils literal notranslate"><span class="pre">ee-mode</span></code> [<code class="docutils literal notranslate"><span class="pre">distributed</span> <span class="pre">|</span> <span class="pre">central</span></code>, default <code class="docutils literal notranslate"><span class="pre">distributed</span></code>]</dt><dd><p>mode for managing equalities across theory solvers</p>
<p>Defines mode for managing equalities across theory solvers.</p>
<dl class="field-list simple">
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">distributed</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>Each theory maintains its own equality engine.</p>
</dd>
<dt class="field-even"><code class="docutils literal notranslate"><span class="pre">central</span></code><span class="colon">:</span></dt>
<dd class="field-even"><p>All applicable theories use the central equality engine.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-lemma-inprocess">
<dt><code class="docutils literal notranslate"><span class="pre">lemma-inprocess</span></code> [<code class="docutils literal notranslate"><span class="pre">full</span> <span class="pre">|</span> <span class="pre">light</span> <span class="pre">|</span> <span class="pre">none</span></code>, default <code class="docutils literal notranslate"><span class="pre">none</span></code>]</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>Modes for inprocessing lemmas.</p>
<p>Modes for inprocessing lemmas.</p>
<dl class="field-list simple">
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">full</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>Full inprocessing.</p>
</dd>
<dt class="field-even"><code class="docutils literal notranslate"><span class="pre">light</span></code><span class="colon">:</span></dt>
<dd class="field-even"><p>Light inprocessing.</p>
</dd>
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">none</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>No inprocessing.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-lemma-inprocess-infer-eq-lit">
<dt><code class="docutils literal notranslate"><span class="pre">lemma-inprocess-infer-eq-lit</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>Infer equivalent literals when using lemma inprocess</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-lemma-inprocess-subs">
<dt><code class="docutils literal notranslate"><span class="pre">lemma-inprocess-subs</span></code> [<code class="docutils literal notranslate"><span class="pre">all</span> <span class="pre">|</span> <span class="pre">simple</span></code>, default <code class="docutils literal notranslate"><span class="pre">simple</span></code>]</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>Modes for substitutions for inprocessing lemmas.</p>
<p>Modes for substitutions for inprocessing lemmas.</p>
<dl class="field-list simple">
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">all</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>All substitutions.</p>
</dd>
<dt class="field-even"><code class="docutils literal notranslate"><span class="pre">simple</span></code><span class="colon">:</span></dt>
<dd class="field-even"><p>Simple substitutions.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-relevance-filter">
<dt><code class="docutils literal notranslate"><span class="pre">relevance-filter</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>enable analysis of relevance of asserted literals with respect to the input formula</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-tc-mode">
<dt><code class="docutils literal notranslate"><span class="pre">tc-mode</span></code> [<code class="docutils literal notranslate"><span class="pre">care-graph</span></code>, default <code class="docutils literal notranslate"><span class="pre">care-graph</span></code>]</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>mode for theory combination</p>
<p>Defines mode for theory combination.</p>
<dl class="field-list simple">
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">care-graph</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>Use care graphs for theory combination.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-theoryof-mode">
<dt><code class="docutils literal notranslate"><span class="pre">theoryof-mode</span></code> [<code class="docutils literal notranslate"><span class="pre">type</span> <span class="pre">|</span> <span class="pre">term</span></code>, default <code class="docutils literal notranslate"><span class="pre">type</span></code>]</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>mode for Theory::theoryof()</p>
<p>Defines how we associate theories with terms.</p>
<dl class="field-list simple">
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">type</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>Type variables, constants and equalities by type.</p>
</dd>
<dt class="field-even"><code class="docutils literal notranslate"><span class="pre">term</span></code><span class="colon">:</span></dt>
<dd class="field-even"><p>Type variables as uninterpreted, type constants by theory, equalities by the parametric theory.</p>
</dd>
</dl>
</dd>
</dl>
</section>
<section id="uninterpreted-functions-theory-module">
<h3>Uninterpreted Functions Theory Module<a class="headerlink" href="#uninterpreted-functions-theory-module" title="Link to this heading"></a></h3>
<dl class="simple" id="lbl-option-eager-arith-bv-conv">
<dt><code class="docutils literal notranslate"><span class="pre">eager-arith-bv-conv</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p>eagerly expand bit-vector to arithmetic conversions during preprocessing</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-model-based-arith-bv-conv">
<dt><code class="docutils literal notranslate"><span class="pre">model-based-arith-bv-conv</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>model-based inferences for bit-vector to arithmetic conversions</p>
</dd>
</dl>
<dl class="simple" id="lbl-option-symmetry-breaker">
<dt><code class="docutils literal notranslate"><span class="pre">symmetry-breaker</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">true</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p>use UF symmetry breaker (Deharbe et al., CADE 2011)</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-uf-card-exp">
<dt><code class="docutils literal notranslate"><span class="pre">uf-card-exp</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">true</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>allows logics with UF+cardinality</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-uf-ho-exp">
<dt><code class="docutils literal notranslate"><span class="pre">uf-ho-exp</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">true</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>enables the higher-order logic solver in applicable logics</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-uf-ho-ext">
<dt><code class="docutils literal notranslate"><span class="pre">uf-ho-ext</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">true</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>apply extensionality on function symbols</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-uf-lambda-qe">
<dt><code class="docutils literal notranslate"><span class="pre">uf-lambda-qe</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>apply quantifier elimination eagerly when two lambdas are equated</p>
</dd>
</dl>
<dl class="simple" id="lbl-option-uf-lazy-ll">
<dt><code class="docutils literal notranslate"><span class="pre">uf-lazy-ll</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">true</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p>do lambda lifting lazily</p>
</dd>
</dl>
<dl id="lbl-option-uf-ss">
<dt><code class="docutils literal notranslate"><span class="pre">uf-ss</span></code> [<code class="docutils literal notranslate"><span class="pre">full</span> <span class="pre">|</span> <span class="pre">no-minimal</span> <span class="pre">|</span> <span class="pre">none</span></code>, default <code class="docutils literal notranslate"><span class="pre">full</span></code>]</dt><dd><p>mode of operation for uf with cardinality solver.</p>
<p>UF with cardinality options currently supported by the –uf-ss option when combined with finite model finding.</p>
<dl class="field-list simple">
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">full</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>Default, use UF with cardinality to find minimal models for uninterpreted sorts.</p>
</dd>
<dt class="field-even"><code class="docutils literal notranslate"><span class="pre">no-minimal</span></code><span class="colon">:</span></dt>
<dd class="field-even"><p>Use UF with cardinality to shrink models, but do no enforce minimality.</p>
</dd>
<dt class="field-odd"><code class="docutils literal notranslate"><span class="pre">none</span></code><span class="colon">:</span></dt>
<dd class="field-odd"><p>Do not use UF with cardinality to shrink model sizes.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="simple" id="lbl-option-uf-ss-abort-card">
<dt><code class="docutils literal notranslate"><span class="pre">uf-ss-abort-card</span></code> [type <code class="docutils literal notranslate"><span class="pre">int64_t</span></code>, default <code class="docutils literal notranslate"><span class="pre">-1</span></code>]</dt><dd><p>tells the uf with cardinality to only consider models that interpret uninterpreted sorts of cardinality at most N (-1 == no limit, default)</p>
</dd>
</dl>
<dl class="simple" id="lbl-option-uf-ss-fair">
<dt><code class="docutils literal notranslate"><span class="pre">uf-ss-fair</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">true</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p>use fair strategy for finite model finding multiple sorts</p>
</dd>
</dl>
<dl class="expert-option simple" id="lbl-option-uf-ss-fair-monotone">
<dt><code class="docutils literal notranslate"><span class="pre">uf-ss-fair-monotone</span></code> [type <code class="docutils literal notranslate"><span class="pre">bool</span></code>, default <code class="docutils literal notranslate"><span class="pre">false</span></code>] (also <code class="docutils literal notranslate"><span class="pre">--no-*</span></code>)</dt><dd><p class="float-right"><strong>[experts only]</strong></p>
<p>group monotone sorts when enforcing fairness for finite model finding</p>
</dd>
</dl>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="api/python/base/unknownexplanation.html" class="btn btn-neutral float-left" title="UnknownExplanation" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="output-tags.html" class="btn btn-neutral float-right" title="Output tags" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2026, the authors of cvc5.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>